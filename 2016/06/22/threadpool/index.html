<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ThreadPoolExcutor | lifeloner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="线程池将任务的提交与任务的执行解耦开来，它对线程进行管理和调度，通过合理的设置能够避免创建过多的线程，提高资源利用率和系统吞吐量。">
<meta name="keywords" content="Java,Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPoolExcutor">
<meta property="og:url" content="https://lifeloner.github.io/2016/06/22/threadpool/index.html">
<meta property="og:site_name" content="lifeloner">
<meta property="og:description" content="线程池将任务的提交与任务的执行解耦开来，它对线程进行管理和调度，通过合理的设置能够避免创建过多的线程，提高资源利用率和系统吞吐量。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/threadpool.png">
<meta property="og:updated_time" content="2017-11-19T08:39:36.067Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThreadPoolExcutor">
<meta name="twitter:description" content="线程池将任务的提交与任务的执行解耦开来，它对线程进行管理和调度，通过合理的设置能够避免创建过多的线程，提高资源利用率和系统吞吐量。">
<meta name="twitter:image" content="http://oqcre1dsl.bkt.clouddn.com/threadpool.png">
  
    <link rel="alternate" href="/atom.xml" title="lifeloner" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lifeloner</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lifeloner.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-threadpool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/22/threadpool/" class="article-date">
  <time datetime="2016-06-22T15:44:40.000Z" itemprop="datePublished">2016-06-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Concurrent/">Concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ThreadPoolExcutor
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>线程池将任务的提交与任务的执行解耦开来，它对线程进行管理和调度，通过合理的设置能够避免创建过多的线程，提高资源利用率和系统吞吐量。<br><a id="more"></a></p>
<h2 id="ThreadPoolExecutor源码分析"><a href="#ThreadPoolExecutor源码分析" class="headerlink" title="ThreadPoolExecutor源码分析"></a>ThreadPoolExecutor源码分析</h2><p>Java中线程池为ThreadPoolExecutor，通过不同的参数设置来实现不同的线程池机制。首先ThreadPoolExcutor继承自AbstractExecutorService，而AbstractExecutorService实现了ExecutorService接口，它最核心构造函数如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</div><div class="line">                               <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                               <span class="keyword">long</span> keepAliveTime,</div><div class="line">                               TimeUnit unit,</div><div class="line">                               BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                               ThreadFactory threadFactory,</div><div class="line">                               RejectedExecutionHandler <span class="keyword">handler</span>) &#123;</div><div class="line">         <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">             maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">             maximumPoolSize &lt; corePoolSize ||</div><div class="line">             keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">         <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || <span class="keyword">handler</span> == <span class="keyword">null</span>)</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">         <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">         <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">         <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">         <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">         <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">         <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">corePoolSize</td>
<td style="text-align:center">核心线程池大小</td>
</tr>
<tr>
<td style="text-align:left">maximumPoolSize</td>
<td style="text-align:center">最大线程池大小</td>
</tr>
<tr>
<td style="text-align:left">keepAliveTime</td>
<td style="text-align:center">线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间</td>
</tr>
<tr>
<td style="text-align:left">TimeUnit</td>
<td style="text-align:center">keepAliveTime时间单位</td>
</tr>
<tr>
<td style="text-align:left">workQueue</td>
<td style="text-align:center">阻塞任务队列</td>
</tr>
<tr>
<td style="text-align:left">threadFactory</td>
<td style="text-align:center">新建线程工厂</td>
</tr>
<tr>
<td style="text-align:left">RejectedExecutionHandler</td>
<td style="text-align:center">当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理</td>
</tr>
</tbody>
</table>
<p>先看一下线程池的基本信息：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用一个线程安全的整数类型来保存线程池状态，并且前3位代表线程池状态，后面低位表示线程的数目</span></div><div class="line"><span class="comment">// 线程池的状态有：RUNNING，SHUTDOWN，STOP，TIDYING，TERMINATED</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> ctl = <span class="keyword">new</span> <span class="type">AtomicInteger</span>(ctlOf(<span class="type">RUNNING</span>, <span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">// 其中worker类对Runnable进行了封装，并且实现了AQS，其中lock方法主要用来判断线程池中的线程的状态（空闲、运行）,以便线程池shutdown时进行中断判断</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="title">implements</span> <span class="title">Runnable</span></span></div></pre></td></tr></table></figure></p>
<p>下面分析一下其核心方法execute：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>) </span>&#123;</div><div class="line">       <span class="keyword">if</span> (command == <span class="literal">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">       <span class="keyword">int</span> c = ctl.<span class="keyword">get</span>();</div><div class="line">       <span class="comment">// 小于核心线程数，则增加一个线程</span></div><div class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">           <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           c = ctl.<span class="keyword">get</span>();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 线程池Running状态，达到核心大小则加入阻塞队列</span></div><div class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">           <span class="keyword">int</span> recheck = ctl.<span class="keyword">get</span>();</div><div class="line">           <span class="comment">// double check，防止加入队列过程中突然shutdown，则删除该任务，成功后拒绝</span></div><div class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))</div><div class="line">               reject(command);</div><div class="line">           <span class="comment">// 若Running状态，或者shutdown但是队列还有任务，则必须增加新的线程处理，任务是null是由于shutdown状态下不能接受新的任务</span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">               addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 非Running状态，或队列满了，增加线程来处理，若达到最大线程大小，拒绝</span></div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</div><div class="line">           reject(command);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>由以上代码可知，线程处理、管理流程如下图：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/threadpool.png" alt="img"><br></center><br>下面简单总结下线程池在提交一个任务时的处理方法：<br>1.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。<br>2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行<br>3.当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务<br>4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理<br>5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程<br>6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</p>
<p>下面继续分析一下addWorker方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// core表示是否为核心线程池</span></div><div class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;</div><div class="line">        retry:</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</div><div class="line">            <span class="built_in">int</span> rs = runStateOf(c);</div><div class="line">            <span class="comment">// 线程池状态为shutdown以上， 或者为shutdown但是任务不为空（shutdown下不能接受新任务） 或队列为空  此时返回null，添加失败</span></div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="built_in">int</span> wc = workerCountOf(c);</div><div class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="comment">// 添加新的线程    </span></div><div class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                    <span class="keyword">break</span> retry;</div><div class="line">                c = ctl.<span class="built_in">get</span>();  <span class="comment">// Re-read ctl</span></div><div class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                    <span class="keyword">continue</span> retry;</div><div class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">        <span class="built_in">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">        Worker w = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">            <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">                mainLock.lock();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// Recheck while holding lock.</span></div><div class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></div><div class="line">                    <span class="comment">// shut down before lock acquired.</span></div><div class="line">                    <span class="built_in">int</span> rs = runStateOf(ctl.<span class="built_in">get</span>());</div><div class="line">                    <span class="comment">// running状态 或者 shutdown状态任务为空，添加新的线程</span></div><div class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                        workers.<span class="built_in">add</span>(w);</div><div class="line">                        <span class="built_in">int</span> s = workers.<span class="built_in">size</span>();</div><div class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                            largestPoolSize = s;</div><div class="line">                        workerAdded = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    mainLock.unlock();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                    <span class="comment">// 新线程执行，最终调用runWorker方法</span></div><div class="line">                    t.start();</div><div class="line">                    workerStarted = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (! workerStarted)</div><div class="line">                addWorkerFailed(w);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> workerStarted;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>下面继续看看worker如何执行任务：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable <span class="keyword">task</span> = w.firstTask;</div><div class="line">        w.firstTask = <span class="keyword">null</span>;</div><div class="line">        w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 不断从阻塞队列获取新的任务</span></div><div class="line">            <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">                w.lock();</div><div class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></div><div class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></div><div class="line">                <span class="comment">// requires a recheck in second case to deal with</span></div><div class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></div><div class="line">                <span class="comment">// stop后需要中断线程</span></div><div class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    beforeExecute(wt, <span class="keyword">task</span>);</div><div class="line">                    Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//直接执行任务的run方法</span></div><div class="line">                        <span class="keyword">task</span>.run();</div><div class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        afterExecute(<span class="keyword">task</span>, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">task</span> = <span class="keyword">null</span>;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>线程池的线程如何不断获取任务：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = ctl.get();</div><div class="line">            <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">            <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">            <span class="comment">// 线程池状态为STOP以上或者shutdown并且队列为空，此时直接结束当前线程，线程数减1</span></div><div class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">            <span class="comment">// Are workers subject to culling?</span></div><div class="line">            <span class="comment">// 获取任务是否允许超时</span></div><div class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line">            <span class="comment">// 当获取任务超时并且还有其他线程或队列为空，终止当前线程</span></div><div class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">// 允许超时时间poll 否则直接阻塞take直到有新任务到</span></div><div class="line">                Runnable r = timed ?</div><div class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                    workQueue.take();</div><div class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> r;</div><div class="line">                timedOut = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">                timedOut = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当runWorker执行异常时：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> processWorkerExit(Worker w, <span class="built_in">boolean</span> completedAbruptly) &#123;</div><div class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></div><div class="line">            decrementWorkerCount();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// 统计完成的任务，清除异常线程</span></div><div class="line">            completedTaskCount += w.completedTasks;</div><div class="line">            workers.remove(w);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tryTerminate();</div><div class="line"></div><div class="line">        <span class="built_in">int</span> c = ctl.<span class="built_in">get</span>();</div><div class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</div><div class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</div><div class="line">                <span class="built_in">int</span> <span class="built_in">min</span> = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</div><div class="line">                    <span class="built_in">min</span> = <span class="number">1</span>;</div><div class="line">                <span class="comment">// 线程池不为空，直接返回</span></div><div class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= <span class="built_in">min</span>)</div><div class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 线程池异常，防止队列有任务而没有worker，需要增加一个新的线程处理任务</span></div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当线程池异常或shutdown或减少线程池线程数量时，会调用tryTerminate方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> void tryTerminate() &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            int c = ctl.<span class="keyword">get</span>();</div><div class="line">            <span class="comment">// Running状态，TIDTYING，shutdown但是队列非空直接返回</span></div><div class="line">            <span class="keyword">if</span> (isRunning(c) ||</div><div class="line">                runStateAtLeast(c, TIDYING) ||</div><div class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">                <span class="keyword">return</span>; </div><div class="line">            <span class="comment">// shotdown状态并且队列非空，清除空闲线程</span></div><div class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></div><div class="line">                interruptIdleWorkers(ONLY_ONE);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">// CAS设置状态为TIDYING</span></div><div class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        terminated();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        ctl.<span class="keyword">set</span>(ctlOf(TERMINATED, <span class="number">0</span>));</div><div class="line">                        termination.signalAll();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// else retry on failed CAS</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span> void interruptIdleWorkers(boolean onlyOne) &#123;</div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</div><div class="line">                Thread t = w.thread;</div><div class="line">                <span class="comment">// 通过aqs的lock方法判断是否空闲，在runWoker（）方法可以看到</span></div><div class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        t.interrupt();</div><div class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        w.unlock();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (onlyOne)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后看下shutdown方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            checkShutdownAccess();</div><div class="line">            <span class="comment">// 设置shutdown状态并中断空闲线程</span></div><div class="line">            advanceRunState(SHUTDOWN);</div><div class="line">            interruptIdleWorkers();</div><div class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 剩下的任务继续执行</span></div><div class="line">        tryTerminate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        List&lt;Runnable&gt; tasks;</div><div class="line">        final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            checkShutdownAccess();</div><div class="line">            <span class="comment">// 设置stop状态</span></div><div class="line">            advanceRunState(STOP);</div><div class="line">            <span class="comment">//终止所有线程</span></div><div class="line">            interruptWorkers();</div><div class="line">            tasks = drainQueue();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        tryTerminate();</div><div class="line">        <span class="keyword">return</span> tasks;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (Worker w : workers)</div><div class="line">                w.interruptIfStarted();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="WorkQueue的类型"><a href="#WorkQueue的类型" class="headerlink" title="WorkQueue的类型"></a>WorkQueue的类型</h2><p>1.直接提交。SynchronousQueue它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes或者可以拒绝的。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。<br>2.无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。<br>3.有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p>
<h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>每当线程池需要创建一个线程时，都会通过threadFactory的工厂方法newThreadFactory来创建一个新的、非守护线程，当然可以继承ThreadFactory来自定义创建的线程，设置线程的优先级、名字、增加日志等功能。</p>
<h2 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h2><p>当当提交任务数超过maximumPoolSize、队列已满时将采取拒绝策略，这将调用RejectedExecutionHandler的rejectedExecution方法，ThreadPoolExcutor 提供了4种预定义的拒绝策略：</p>
<ol>
<li>在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时 RejectedExecutionException</li>
<li>在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的 execute 本身即在excute本身的线程中执行run方法。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。<br>3.在 ThreadPoolExecutor.DiscardPolicy 中，当前的任务将被抛弃。<br>4.在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部（注意优先级队列）的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li>
</ol>
<h2 id="Executors常用的线程池配置"><a href="#Executors常用的线程池配置" class="headerlink" title="Executors常用的线程池配置"></a>Executors常用的线程池配置</h2><p>1.构造一个固定线程数目的线程池，配置的corePoolSize与maximumPoolSize大小相同，同时使用了一个无界LinkedBlockingQueue存放阻塞任务，因此多余的任务将存在再阻塞队列，不会由RejectedExecutionHandler处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                       0L, TimeUnit.MILLISECONDS,</div><div class="line">                                       new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.构造一个缓冲功能的线程池，配置corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s,以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的线程执行；线程空闲超过60s将会销毁<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                      <span class="number">60</span>L, TimeUnit.SECONDS,</div><div class="line">                                      <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.构造一个只支持一个线程的线程池，配置corePoolSize=maximumPoolSize=1，无界阻塞队列LinkedBlockingQueue；保证任务由一个线程串行执行<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></div><div class="line"><span class="type"></span>            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                     <span class="number">0</span>L, TimeUnit.MILLISECONDS,</div><div class="line">                                     <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.构造有定时功能的线程池，配置corePoolSize，无界延迟阻塞队列DelayedWorkQueue；有意思的是：maximumPoolSize=Integer.MAX_VALUE，由于DelayedWorkQueue是无界队列，所以这个值是没有意义的<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(int corePoolSize) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="keyword">new</span><span class="type">ScheduledThreadPool</span>(</div><div class="line">             int corePoolSize, ThreadFactory threadFactory) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor(int corePoolSize,</div><div class="line">                              ThreadFactory threadFactory) &#123;</div><div class="line">         <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</div><div class="line">               <span class="keyword">new</span> <span class="type">DelayedWorkQueue</span>(), threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们自定义写一个线程池：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.meituan.concurrent;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Author:fuyang@meituan.com</span></div><div class="line"><span class="comment"> * Date:16/7/20</span></div><div class="line"><span class="comment"> * Time:下午2:13</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecuotrTest</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong executeTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecuotrTest</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, <span class="keyword">new</span> MyThreadFactory(), <span class="keyword">new</span> RejectHandler());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" before"</span>);</div><div class="line">        startTime.set(System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        executeTime.addAndGet(endTime - startTime.get());</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" after"</span>);</div><div class="line">        <span class="keyword">super</span>.afterExecute(r, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"time "</span> + executeTime.get());</div><div class="line">        <span class="keyword">super</span>.terminated();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ThreadPoolExecuotrTest threadPoolExecuotrTest = <span class="keyword">new</span> ThreadPoolExecuotrTest(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">2</span>));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</div><div class="line">           threadPoolExecuotrTest.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       System.out.println(Thread.currentThread().getName() + <span class="string">" execute"</span>);</div><div class="line">                       Thread.sleep(<span class="number">6000</span>);</div><div class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                       e.printStackTrace();</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">        &#125;</div><div class="line">        threadPoolExecuotrTest.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行8次任务，那么线程池中达到最大线程数，队列也会打满，那么剩下的2个任务将会采取拒绝策略，我们复写了rejectExecution方法，将任务put阻塞提交到队列，所以所有的任务的都会执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.meituan.concurrent;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Author:fuyang@meituan.com</span></div><div class="line"><span class="comment"> * Date:16/7/20</span></div><div class="line"><span class="comment"> * Time:下午3:23</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"reject"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            executor.getQueue().put(r);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Connected to the target VM, <span class="selector-tag">address</span>: <span class="string">'127.0.0.1:54007'</span>, transport: <span class="string">'socket'</span></div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-1</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-4</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-1</span> execute</div><div class="line">reject</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-3</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-3</span> execute</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-2</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-4</span> execute</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-2</span> execute</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-4</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-2</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-1</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-3</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-2</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-2</span> execute</div><div class="line">reject</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-4</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-4</span> execute</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-3</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-3</span> execute</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-1</span> before</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-1</span> execute</div><div class="line">Disconnected from the target VM, <span class="selector-tag">address</span>: <span class="string">'127.0.0.1:54007'</span>, transport: <span class="string">'socket'</span></div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-4</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-3</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-2</span> after</div><div class="line">com<span class="selector-class">.meituan</span><span class="selector-class">.concurrent</span><span class="selector-class">.MyThreadFactory-1</span> after</div><div class="line"><span class="selector-tag">time</span> <span class="number">48016</span></div></pre></td></tr></table></figure></p>
<p>另外，线程池中shutdown方法通过interrupt中断线程，设置为shutdown状态，但只能中断空闲线程，阻止继续提交任务，队列中的任务仍会执行，shutdownNow会interrupt所有的线程，设置为stop 状态，但不能保证所有的线程马上结束（参考interrupt作用），队列中的任务也会丢弃不执行。awaitTermination阻塞等待shutdown后线程结束。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>一般来说，最好使用Executors提供的4种线程池，除非有特别的需求可以定义独特的线程池，线程池的大小确定是重点，线程池过大导致竞争激烈，线程池过小吞吐量较低。所以在任务量较少可以使用无界的队列，任务量很大使用有介的队列防止OOM，也有一种通用的计算方法：N（thread）＝N（cpu）＊U（cpu）（1+W / C），其中分别为cpu数量，cpu利用率，等待时间和计算时间，最大线程数一般设为2N+1，N是CPU核数。当然线程池大小还受到内存，io等其他因素影响。</p>
<p>最后注意线程间的依赖，在有界线程池中容易产生死锁现象。</p>
<p>线程池这部分知识感觉有些复杂，掌握起来有些困难，底层一些机制源码不太容易理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lifeloner.github.io/2016/06/22/threadpool/" data-id="cjap2worm0021k0xf8ccqjxal" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/14/jvmtools/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          JVM性能监控工具
        
      </div>
    </a>
  
  
    <a href="/2016/06/18/hashmap/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Hashmap线程安全性分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Basic/">Basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frameworks/">Frameworks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common/">Common</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataStructure/">DataStructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed/">Distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Midware/">Midware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/">Thread</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Common/" style="font-size: 10px;">Common</a> <a href="/tags/DataStructure/" style="font-size: 17.5px;">DataStructure</a> <a href="/tags/Distributed/" style="font-size: 15px;">Distributed</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Midware/" style="font-size: 10px;">Midware</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SpringMVC/" style="font-size: 12.5px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 17.5px;">Thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/10/midwares/">大型系统中的中间件</a>
          </li>
        
          <li>
            <a href="/2017/09/10/consistency/">分布式一致性协议</a>
          </li>
        
          <li>
            <a href="/2017/08/10/distributed/">大型网站架构概念</a>
          </li>
        
          <li>
            <a href="/2017/06/26/io/">Java IO浅析</a>
          </li>
        
          <li>
            <a href="/2017/06/10/AQS/">Java并发之AQS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lifeloner<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>