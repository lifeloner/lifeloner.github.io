<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>B Tree | lifeloner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="背景动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低">
<meta name="keywords" content="DataStructure">
<meta property="og:type" content="article">
<meta property="og:title" content="B Tree">
<meta property="og:url" content="https://lifeloner.github.io/2017/05/21/btree/index.html">
<meta property="og:site_name" content="lifeloner">
<meta property="og:description" content="背景动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低树的深度很重要，那么就需要采用多叉树结构！而B树使得树深度较低，所以查找效率较高">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/disk.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree1.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree2.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree3.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree4.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree5.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree6.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree7.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree8.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree9.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree10.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree11.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree12.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btreea.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btreeb.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btreec.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/btree+.png">
<meta property="og:updated_time" content="2017-11-19T09:19:47.527Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B Tree">
<meta name="twitter:description" content="背景动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低树的深度很重要，那么就需要采用多叉树结构！而B树使得树深度较低，所以查找效率较高">
<meta name="twitter:image" content="http://oqcre1dsl.bkt.clouddn.com/disk.png">
  
    <link rel="alternate" href="/atom.xml" title="lifeloner" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lifeloner</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lifeloner.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-btree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/21/btree/" class="article-date">
  <time datetime="2017-05-21T12:48:59.000Z" itemprop="datePublished">2017-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic/">Basic</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      B Tree
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！<br>在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低树的深度很重要，那么就需要采用多叉树结构！而B树使得树深度较低，所以查找效率较高！<br><a id="more"></a></p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>磁盘作为外存储器，读取效率比内存慢很多，它的结构如下图所示：</p>
<center><br><img src="http://oqcre1dsl.bkt.clouddn.com/disk.png" alt="img"><br></center><br>磁盘有多个盘片组成，盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了，每个盘面有一个磁头，它可以从一个磁到移到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。<br>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。读/写磁盘上某一指定数据需要下面3个步骤：<br>(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。<br>(2)  如上图11.3中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。<br>(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。<br>访问某一具体信息，由3部分时间组成：<br>● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。<br>● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一）因此一般旋转一圈大约0.0083s。<br>● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s<br>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts<br><br>##B-树<br><br>B-树是一种多路查找树，能极大降低树的深度，许多数据库系统都一般使用B树或者B树的各种变形结构。B-树的定义如下：<br>一颗m阶的b-树结构<br>1）若根结点不是叶子结点，则至少有2个孩子，最多含有m个孩子（m&gt;=2）（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）<br>2）除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子，最多含有m个孩子（其中ceil(x)是一个取上限的函数）；<br>3）所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)<br>4）每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>       a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki<br>       b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)<br>       c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1<br><br>一颗3阶B树示例如下图所示：<br><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/btree.png" alt="img"><br></center><br>首先节点定义为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="comment">/*文件数*/</span> 关键字个数</div><div class="line">    <span class="keyword">int</span>  file_num;</div><div class="line">    <span class="comment">/*文件名(key)*/</span>  即 key</div><div class="line">    <span class="keyword">char</span> * file_name[max_file_num];</div><div class="line">    <span class="comment">/*指向子节点的指针*/</span>  孩子指针</div><div class="line">     BTNode * BTptr[max_file_num+<span class="number">1</span>];</div><div class="line">     <span class="comment">/*文件在硬盘中的存储位置*/</span>  实际数据磁盘地址</div><div class="line">     FILE_HARD_ADDR offset[max_file_num];</div><div class="line">&#125;BTNode;</div></pre></td></tr></table></figure><br><br>B树包含N个关键字时，最大深度为：h=log┌m/2┐((N+1)/2 )+1，每一个非叶子结点含有ceil（m／2）个孩子<br><br>### 插入过程<br><br>    插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。<br><br>以一颗5阶B-树来展示插入过程：<br>插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S<br>   （1）首先根节点空间充足，直接插入4个节点<br>   （2）插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中<br>   （3）插入E,K,Q时，不需要任何分裂操作<br>   （4）插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<br>   <center><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree1.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree2.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree3.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree4.png" alt="img"><br>   </center><br>   （5）插入F,W,L,T不需要任何分裂操作<br>   （6）插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中<br>   （7）插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作<br>   （8）当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中<br>   <center><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree5.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree6.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree7.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree8.png" alt="img"><br>   </center>

<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况<br>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）（还记得第一节中关于B树的第5个特性中的c点么?： c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： （ceil(m / 2)-1）&lt;= n &lt;= m-1。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：2&lt;=n&lt;=4），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点。</p>
<p>下面看删除H,T,R,E过程：<br> （9）首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br> （10）删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作<br> （11）删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。<br> <center><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree9.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree10.png" alt="img"><br>   <img src="http://oqcre1dsl.bkt.clouddn.com/btree11.png" alt="img"><br>  </center></p>
<p> （12）删除E， 删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点<br>然后发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于2=&lt;n&lt;=4，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。</p>
<center><br>  <img src="http://oqcre1dsl.bkt.clouddn.com/btree12.png" alt="img"><br></center>

<p>  在看一个删除操作：5阶B树，删除C<br>（a）先删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。<br>（b）这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质</p>
<center><br> <img src="http://oqcre1dsl.bkt.clouddn.com/btreea.png" alt="img"><br> <img src="http://oqcre1dsl.bkt.clouddn.com/btreeb.png" alt="img"><br> <img src="http://oqcre1dsl.bkt.clouddn.com/btreec.png" alt="img"><br></center>

<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>特点:<br>  (1）有n棵子树的结点中含有n-1 个关键字<br>  (2）所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)<br>  (3）所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br>      <center><br>       <img src="http://oqcre1dsl.bkt.clouddn.com/btree+.png" alt="img"><br>      </center></p>
<p>优点：<br>（1）B+-tree的磁盘读写代价更低<br>        B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br>（2）B+-tree的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<br>（3）B+树支持范围查询<br>    B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>B树：有序数组+平衡多叉树；<br>B+树：有序数组链表+平衡多叉树；<br>（1）对于单个查询，b树可能更早的返回数据，因为内节点也存储了数据信息，而b+树需要查到叶子结点，但是b+树节点需要更少的空间所以磁盘I／O会少一点，除此之外，b+树支持范围查询和扫描，所以更加方便！<br>（2）b树和b+树在内存中没有任何优势，不如AVL和红黑树，但是在磁盘降低了树的深度，其I／O次数明显减少，所以大大降低了查询时间，被广泛用于数据库索引（Mysql）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lifeloner.github.io/2017/05/21/btree/" data-id="cjap2wopj0002k0xfnjvayo2c" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataStructure/">DataStructure</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/10/AQS/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          Java并发之AQS
        
      </div>
    </a>
  
  
    <a href="/2017/05/21/clone/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Clone</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Basic/">Basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frameworks/">Frameworks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common/">Common</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataStructure/">DataStructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed/">Distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Midware/">Midware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/">Thread</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Common/" style="font-size: 10px;">Common</a> <a href="/tags/DataStructure/" style="font-size: 17.5px;">DataStructure</a> <a href="/tags/Distributed/" style="font-size: 15px;">Distributed</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Midware/" style="font-size: 10px;">Midware</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SpringMVC/" style="font-size: 12.5px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 17.5px;">Thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/10/midwares/">大型系统中的中间件</a>
          </li>
        
          <li>
            <a href="/2017/09/10/consistency/">分布式一致性协议</a>
          </li>
        
          <li>
            <a href="/2017/08/10/distributed/">大型网站架构概念</a>
          </li>
        
          <li>
            <a href="/2017/06/26/io/">Java IO浅析</a>
          </li>
        
          <li>
            <a href="/2017/06/10/AQS/">Java并发之AQS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lifeloner<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>