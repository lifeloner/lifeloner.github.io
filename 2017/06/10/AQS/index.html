<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java并发之AQS | lifeloner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。">
<meta name="keywords" content="Java,Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发之AQS">
<meta property="og:url" content="https://lifeloner.github.io/2017/06/10/AQS/index.html">
<meta property="og:site_name" content="lifeloner">
<meta property="og:description" content="并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/aqs.png?imageMogr2/thumbnail/!70p">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/CLH.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/acquire.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/acquireNano.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/condition.jpg">
<meta property="og:updated_time" content="2017-11-19T08:08:42.895Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发之AQS">
<meta name="twitter:description" content="并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。">
<meta name="twitter:image" content="http://oqcre1dsl.bkt.clouddn.com/aqs.png?imageMogr2/thumbnail/!70p">
  
    <link rel="alternate" href="/atom.xml" title="lifeloner" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lifeloner</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lifeloner.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-AQS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/10/AQS/" class="article-date">
  <time datetime="2017-06-10T12:44:40.000Z" itemprop="datePublished">2017-06-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Concurrent/">Concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java并发之AQS
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。<br><a id="more"></a></p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/aqs.png?imageMogr2/thumbnail/!70p" alt="img"><br></center><br>上图从下到上描述了Java并发的整个体系：首先是JVM的violate可见性读写以及操作系统CAS原子操作的支持，在这一基础上出现了基础并发框架AQS以及一些简单的原子变量类，最后对AQS进行扩展完善，出现了大量的并发容器、同步器、锁结构。</p>
<h2 id="AQS公共方法"><a href="#AQS公共方法" class="headerlink" title="AQS公共方法"></a>AQS公共方法</h2><p>AQS提供了许多公用的方法来管理同步，并且也提供了一些抽象方法，子类通过继承AQS来实现它的抽象方法来管理同步状态，AQS提供的主要方法有：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">getState</span><span class="params">()</span></span>：返回同步状态的当前值；</div><div class="line"><span class="function"><span class="title">setState</span><span class="params">(int newState)</span></span>：设置当前同步状态；</div><div class="line"><span class="function"><span class="title">compareAndSetState</span><span class="params">(int expect, int update)</span></span>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</div><div class="line"><span class="function"><span class="title">tryAcquire</span><span class="params">(int arg)</span></span>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</div><div class="line"><span class="function"><span class="title">tryRelease</span><span class="params">(int arg)</span></span>：独占式释放同步状态；</div><div class="line"><span class="function"><span class="title">tryAcquireShared</span><span class="params">(int arg)</span></span>：共享式获取同步状态，返回值大于等于<span class="number">0</span>则表示获取成功，否则获取失败；</div><div class="line"><span class="function"><span class="title">tryReleaseShared</span><span class="params">(int arg)</span></span>：共享式释放同步状态；</div><div class="line"><span class="function"><span class="title">isHeldExclusively</span><span class="params">()</span></span>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</div><div class="line"><span class="function"><span class="title">acquire</span><span class="params">(int arg)</span></span>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</div><div class="line"><span class="function"><span class="title">acquireInterruptibly</span><span class="params">(int arg)</span></span>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</div><div class="line"><span class="function"><span class="title">tryAcquireNanos</span><span class="params">(int arg,long nanos)</span></span>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</div><div class="line"><span class="function"><span class="title">acquireShared</span><span class="params">(int arg)</span></span>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</div><div class="line"><span class="function"><span class="title">acquireSharedInterruptibly</span><span class="params">(int arg)</span></span>：共享式获取同步状态，响应中断；</div><div class="line"><span class="function"><span class="title">tryAcquireSharedNanos</span><span class="params">(int arg, long nanosTimeout)</span></span>：共享式获取同步状态，增加超时限制；</div><div class="line"><span class="function"><span class="title">release</span><span class="params">(int arg)</span></span>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</div><div class="line"><span class="function"><span class="title">releaseShared</span><span class="params">(int arg)</span></span>：共享式释放同步状态；</div></pre></td></tr></table></figure></p>
<h2 id="同步队列CLH"><a href="#同步队列CLH" class="headerlink" title="同步队列CLH"></a>同步队列CLH</h2><p>此外AQS内部维护着一个CLH同步队列，该队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。CLH结构如下图所示：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/CLH.png" alt="img"><br></center><br>在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 共享 *</span>/</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 独占 *</span>/</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">    <span class="comment">//后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> SIGNAL    = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CONDITION = <span class="number">-2</span>;</div><div class="line">    <span class="comment">//表示下一次共享式同步状态获取将会无条件地传播下去</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PROPAGATE = <span class="number">-3</span>;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 等待状态 *</span>/</span></span></div><div class="line">    volatile <span class="built_in">int</span> waitStatus;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 前驱节点 *</span>/</span></span></div><div class="line">    volatile Node prev;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 后继节点 *</span>/</span></span></div><div class="line">    volatile Node next;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 获取同步状态的线程 *</span>/</span></span></div><div class="line">    volatile Thread thread;</div><div class="line">    Node nextWaiter;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>acquire方法为AQS提供的模板方法，该方法为独占式获取同步状态，该方法对中断不敏感，即由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法由子类去实现<br>addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部<br>acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过，其代码如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            // 自旋，直到满足下面条件</div><div class="line">            for (;;) &#123;</div><div class="line">                final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">                // 其前驱节点是头节点并且获取同步状态成功</div><div class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">                    p</span>.next = null; // help GC</div><div class="line">                    failed = <span class="literal">false</span>;</div><div class="line">                    return interrupted;</div><div class="line">                &#125;</div><div class="line">                // 获取同步失败，等待</div><div class="line">                if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line"><span class="title">                    parkAndCheckInterrupt</span>())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>
<p>可以看出只有其前驱节点为头结点才能够尝试获取同步状态，原因在于1）FIFO队列2）头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点,acquire流程如下图所示：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/acquire.png" alt="img"><br></center><br>AQS提供了acquire独占式获取同步状态，但该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了acquireInterruptibly方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常InterruptedException：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="comment">// 中断直接跑出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">            doAcquireInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> doAcquireInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 中断后抛出异常</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AQS也提供了超时处理，tryAcquireNanos，该方法为acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">            doAcquireNanos(arg, nanosTimeout);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> doAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="comment">//nanosTimeout &lt;= 0</span></div><div class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//超时时间</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">        <span class="comment">//新增Node节点</span></div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//自旋</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="comment">//获取同步状态成功</span></div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//重新计算需要休眠的时间</span></div><div class="line">                nanosTimeout = deadline - System.nanoTime();</div><div class="line">                <span class="comment">//已经超时，返回false</span></div><div class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//如果没有超时，则等待nanosTimeout纳秒，该线程会直接从LockSupport.parkNanos中返回</span></div><div class="line">                <span class="comment">//如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold</span></div><div class="line">                <span class="comment">//已经非常小了，非常短的时间等待无法做到十分精确直接自旋</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">                <span class="comment">//线程是否已经中断了，中断直接抛出异常</span></div><div class="line">                <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireNanos的流程如下图所示：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/acquireNano.png" alt="img"><br></center><br>独占式同步状态释放<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="comment">// 尝试释放，子类实现</span></div><div class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">            Node h = head;</div><div class="line">            <span class="comment">// 唤醒后继节点</span></div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">                unparkSuccessor(h);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p>AQS提供acquireShared方法共享式获取同步状态：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="comment">// tryAcquireShared由子类实现</span></div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">//获取失败，自旋获取同步状态</span></div><div class="line">            doAcquireShared(arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        /共享式节点</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    <span class="comment">//尝试获取同步</span></div><div class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h2><p>在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞，其主要方法在acquireQueued<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line"><span class="title">                    parkAndCheckInterrupt</span>())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line"></div><div class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //前驱节点</div><div class="line">        int ws = pred.waitStatus;</div><div class="line">        //状态为signal，表示当前线程处于等待状态，直接放回<span class="literal">true</span></div><div class="line">        if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</div><div class="line">            return <span class="literal">true</span>;</div><div class="line">        //前驱节点状态 &gt; <span class="number">0</span> ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</div><div class="line">        if (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">            do &#123;</div><div class="line">                <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</div><div class="line">            &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">            pred.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">        &#125; </span></div><div class="line"><span class="title">        //前驱节点状态为Condition</span>、propagate</div><div class="line">        else &#123;</div><div class="line">            compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</div><div class="line">        &#125;</div><div class="line">        return <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 shouldParkAfterFailedAcquire，该算法的步骤如下：<br>1）如果当前线程的前驱节点状态为SINNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞<br>2）如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false<br>3）如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false<br>shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// LockSupport调用UNSAFE类park方法来挂起当前线程</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">        <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当线程释放同步状态后需要唤醒其后继节点：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">//当前节点状态</span></div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">        <span class="comment">//当前状态 &lt; 0 则设置为 0</span></div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">//当前节点的后继节点</span></div><div class="line">        Node s = node.next;</div><div class="line">        <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//从tail节点来找可用节点</span></div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//唤醒后继节点</span></div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能会存在当前线程的后继节点为null，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，从tail尾节点开始，原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock，可重入锁。它可以等同于synchronized的使用，但是ReentrantLock提供了比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率.<br>ReentrantLock实现了Lock接口，依赖内部类Sync类来管理同步状态，Sync继承了AQS，同时Sync有2个子类，分别支持公平锁和非公平锁NonfairSync与FairSync。下面我们看看Lock的常用方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    sync.<span class="keyword">lock</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReentrantLock里面大部分的功能都是委托给Sync来实现的，同时Sync内部定义了lock()抽象方法由其子类去实现，默认实现了nonfairTryAcquire(int acquires)方法，可以看出它是非公平锁的默认实现方式。下面我们看非公平锁的lock()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//尝试获取锁CAS</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">//获取失败，调用AQS的acquire(int arg)方法,acquire在AQS中定义，子类实现tryAcquire</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认非公平锁</span></div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">//当前线程</span></div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="comment">//state == 0,表示没有该锁处于空闲状态</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//获取锁成功，设置为当前线程所有</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//线程重入</span></div><div class="line">        <span class="comment">//判断锁持有的线程是否为当前线程，是则增加次数，可重入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>释放锁：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// release在AQS中定义，包括了tryRelease，unparkSuccessor2个主要操作</span></div><div class="line">        sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 子类实现tryRelease</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">//减掉releases</span></div><div class="line">        <span class="keyword">int</span> c = getState() - releases;</div><div class="line">        <span class="comment">//如果释放的不是持有锁的线程，抛出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//state == 0 表示已经释放完全了，其他线程可以获取同步状态了</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            free = <span class="keyword">true</span>;</div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        setState(c);</div><div class="line">        <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>公平锁的tryAcquire方法：其实只是多了一个hasQueuedPredecessors判断，即节点是否为头节点<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node t = tail;  <span class="comment">//尾节点</span></div><div class="line">        Node h = head;  <span class="comment">//头节点</span></div><div class="line">        Node s;</div><div class="line">        <span class="comment">//头节点 != 尾节点</span></div><div class="line">        <span class="comment">//同步队列第一个节点不为null</span></div><div class="line">        <span class="comment">//当前线程是同步队列第一个节点</span></div><div class="line">        <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们继续分析一下Lock的阻塞和唤醒:Condition<br>实现等待/通知模式二种方式：1）Synchronized来控制同步，配合Object的wait()、notify()。2）Lock提供了条件Condition，其线程的等待、唤醒操作更加详细和灵活。下图是Condition与Object的监视器方法的对比</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/condition.jpg" alt="img"><br></center><br>Condition提供了一系列的方法来对阻塞和唤醒线程：<br>await() ：造成当前线程在接到信号或被中断之前一直处于等待状态。<br>await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。<br>awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout – 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。<br>awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。<br>signal()：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。<br>signal()All：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。<br>Condition接口有一个实现类ConditionObject，其位于AQS内部类：<br>每个Condition对象都包含着一个FIFO队列，该队列是Condition对象通知/等待功能的关键。在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程,其中Node和CLH同步队列的Node相同<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</div><div class="line">        private static final long serialVersionUID = <span class="number">1173984872572414699</span>L;</div><div class="line">        /** First <span class="keyword">node</span> <span class="title">of</span> condition queue. */</div><div class="line">        private transient <span class="keyword">Node</span> <span class="title">firstWaiter</span>;</div><div class="line">        /** Last <span class="keyword">node</span> <span class="title">of</span> condition queue. */</div><div class="line">        private transient <span class="keyword">Node</span> <span class="title">lastWaiter</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列同时释放锁。当从await()方法返回时，当前线程一定是获取了Condition相关连的锁,awaitl流程：首先将当前线程新建一个节点同时加入到条件队列中，然后释放当前线程持有的同步状态。然后则是不断检测该节点代表的线程释放出现在CLH同步队列中（收到signal信号之后就会在AQS队列中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 当前线程中断</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="comment">//当前线程加入等待队列</span></div><div class="line">        Node node = addConditionWaiter();</div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        <span class="keyword">long</span> savedState = fullyRelease(node);</div><div class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待</span></div><div class="line"><span class="comment">         * 直到检测到此节点在同步队列上</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">            <span class="comment">//线程挂起</span></div><div class="line">            LockSupport.park(<span class="keyword">this</span>);</div><div class="line">            <span class="comment">//如果已经中断了，则退出</span></div><div class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//竞争同步状态</span></div><div class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">            interruptMode = REINTERRUPT;</div><div class="line">        <span class="comment">//清理下条件队列中的不是在等待条件的节点</span></div><div class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">            unlinkCancelledWaiters();</div><div class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">            reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fullyRelease(Node node)，负责释放该线程持有的锁：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">long</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//节点状态--其实就是持有锁的数量</span></div><div class="line">            <span class="keyword">long</span> savedState = getState();</div><div class="line">            <span class="comment">//调用rlease释放锁</span></div><div class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> savedState;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                node.waitStatus = Node.CANCELLED;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isOnSyncQueue(Node node)：如果一个节点同步队列上获取锁则返回true<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final boolean isOnSyncQueue(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //状态为Condition，获取前驱节点为null，返回<span class="literal">false</span></div><div class="line">        if (<span class="keyword">node</span>.<span class="title">waitStatus</span> == <span class="keyword">Node</span>.<span class="title">CONDITION</span> || <span class="keyword">node</span>.<span class="title">prev</span> == null)</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //后继节点不为null，肯定在CLH同步队列中，</div><div class="line">        if (<span class="keyword">node</span>.<span class="title">next</span> != null)</div><div class="line">            return <span class="literal">true</span>;</div><div class="line"></div><div class="line">        return findNodeFromTail(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>
<p>通知唤醒：<br>调用Condition的signal()方法，将会唤醒在等待队列里的头节点，在唤醒节点前，会将节点移到CLH同步队列中<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public final void signal() &#123;</div><div class="line">        //检测当前线程是否为拥有锁的独</div><div class="line">        if (!isHeldExclusively())</div><div class="line">            throw new IllegalMonitorStateException();</div><div class="line">        //头节点，唤醒条件队列中的第一个节点</div><div class="line">        <span class="keyword">Node</span> <span class="title">first</span> = firstWaiter;</div><div class="line">        if (first != null)</div><div class="line">            doSignal(first);    //唤醒</div><div class="line">&#125;</div><div class="line">//doSignal(<span class="keyword">Node</span> <span class="title">first</span>)主要是做两件事：<span class="number">1</span>.修改头节点，<span class="number">2</span>.调用transferForSignal(<span class="keyword">Node</span> <span class="title">first</span>) 方法将节点移动到CLH同步队列中</div><div class="line">private void doSignal(<span class="keyword">Node</span> <span class="title">first</span>) &#123;</div><div class="line">        do &#123;</div><div class="line">            //修改头结点，完成旧头结点的移出工作</div><div class="line">            if ( (firstWaiter = first.nextWaiter) == null)</div><div class="line">                lastWaiter = null;</div><div class="line">            first.nextWaiter = null;</div><div class="line">        &#125; while (!transferForSignal(first) &amp;&amp;</div><div class="line">                (first = firstWaiter) != null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //将该节点从状态CONDITION改变为初始状态<span class="number">0</span>,</div><div class="line">        if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //将节点加入到CLH队列中去，返回的是CLH队列中<span class="keyword">node</span><span class="title">节点前面的一个节点</span></div><div class="line"><span class="title">        Node</span> p = enq(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">        int</span> ws = p.waitStatus;</div><div class="line">        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</div><div class="line">        if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</div><div class="line">            LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</div><div class="line">        return <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Condition总结：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是则尝试获取锁，否则一直挂起。当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒条件队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch功能：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待<br>CountDownlatch与CyclicBarrier区别：<br>1）CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待<br>2）CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier<br>CountDownLatch在实现上同样依赖内部类Sync，Sync继承AQS，CountDownLatch仅有一个int类型的构造函数<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374</span>L;</div><div class="line"></div><div class="line">        Sync(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">            setState(<span class="keyword">count</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">int</span> getCount() &#123;</div><div class="line">            <span class="keyword">return</span> getState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//释放同步状态</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个内部类Sync我们可以清楚地看到CountDownLatch是采用共享锁来实现的,下面我们看看它的核心方法await方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//AQS定义acquireSharedInterruptibly</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="comment">//tryAcquireShared见上面Sync类内部，若state不为0（countdown未减为0）则调用AQS的doAcquireSharedInterruptibly方法自旋等待同步状态</span></div></pre></td></tr></table></figure></p>
<p>countdown方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// releaseShared见上面Sync内部，若state为0直接返回fasle，若countdown减1后为0，则调用AQS的doReleaseShared唤醒，await继续执行</span></div></pre></td></tr></table></figure></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore的实现也是依赖Sync，包含公平锁（FairSync）和非公平锁（NonfairSync），继承内部类Sync，其中Sync继承AQS<br>Semaphore提供了两个构造函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建具有给定的许可数和非公平的公平设置的 Semaphore,默认非公平</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建具有给定的许可数和给定的公平设置的 Semaphore</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过acquire来获取信号量：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 共享的可中断</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS定义的 acquireSharedInterruptibly，依赖sync实现的tryAcquireShared</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="comment">//  公平的tryAcquireShared</span></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">//判断该线程是否位于CLH队列的列头</span></div><div class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            <span class="comment">//获取当前的信号量许可</span></div><div class="line">            <span class="keyword">int</span> available = getState();</div><div class="line"></div><div class="line">            <span class="comment">//设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span></div><div class="line">            <span class="keyword">int</span> remaining = available - acquires;</div><div class="line"></div><div class="line">            <span class="comment">//CAS设置信号量</span></div><div class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                <span class="keyword">return</span> remaining;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 非公平的tryAcquireShared方法，少了一个头节点的判断</span></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> available = getState();</div><div class="line">                <span class="keyword">int</span> remaining = available - acquires;</div><div class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                    <span class="keyword">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>信号量释放：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS的releaseShared，子类sync实现tryReleaseShared</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> current = getState();</div><div class="line">            <span class="comment">//信号量的许可数 = 当前信号许可数 + 待释放的信号许可数</span></div><div class="line">            <span class="keyword">int</span> next = current + releases;</div><div class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</div><div class="line">            <span class="comment">//设置可获取的信号许可数为next</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier：允许一组线程互相等待，直到到达某个公共屏障点。在一组固定大小的线程的程序中，这些线程必须不时地互相等待，barrier 在释放等待线程后可以重用。<br>构造函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="comment">// barrier数量</span></div><div class="line">        <span class="keyword">this</span>.parties = parties;</div><div class="line">        <span class="keyword">this</span>.count = parties;</div><div class="line">        <span class="comment">// 最后到达公共屏障点执行的任务</span></div><div class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用lock和condition来管理同步状态</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</div></pre></td></tr></table></figure></p>
<p>最重要的wait方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;<span class="comment">//不超时等待</span></div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</div><div class="line">            <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">            TimeoutException &#123;</div><div class="line">        <span class="comment">//获取锁</span></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//分代</span></div><div class="line">            <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">            <span class="comment">//当前generation“已损坏”，抛出BrokenBarrierException异常</span></div><div class="line">            <span class="comment">//抛出该异常一般都是某个线程在等待某个处于“断开”状态的CyclicBarrie</span></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="comment">//当某个线程试图等待处于断开状态的 barrier 时，或者 barrier 进入断开状态而线程处于等待状态时，抛出该异常</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="comment">//如果线程中断，终止CyclicBarrier</span></div><div class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//进来一个线程 count - 1</span></div><div class="line">            <span class="keyword">int</span> index = --count;</div><div class="line">            <span class="comment">//count == 0 表示所有线程均已到位，触发Runnable任务</span></div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                    <span class="comment">//触发任务</span></div><div class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                        command.run();</div><div class="line">                    ranAction = <span class="keyword">true</span>;</div><div class="line">                    <span class="comment">//唤醒所有等待线程，并更新generation</span></div><div class="line">                    nextGeneration();</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 自旋直到所有线程到达，超时，broken，中断</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//如果不是超时等待，则调用Condition.await()方法等待</span></div><div class="line">                    <span class="keyword">if</span> (!timed)</div><div class="line">                        trip.await();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</div><div class="line">                        <span class="comment">//超时等待，调用Condition.awaitNanos()方法等待</span></div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        <span class="keyword">throw</span> ie;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                        <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (g.broken)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">                <span class="comment">//generation已经更新，返回index</span></div><div class="line">                <span class="keyword">if</span> (g != generation)</div><div class="line">                    <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">                <span class="comment">//“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</span></div><div class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//释放锁</span></div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>await处理流程：<br>如果该线程不是到达的最后一个线程，则他会一直处于等待状态，除非发生以下情况：<br>最后一个线程到达，即index == 0<br>超出了指定时间（超时等待）<br>其他的某个线程中断当前线程<br>其他的某个线程中断另一个等待的线程<br>其他的某个线程在等待barrier超时<br>其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态<br>此外，Generation描述着CyclicBarrier的更显换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。其中broken标识该当前CyclicBarrier是否已经处于损坏状态。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程,在breakBarrier()中除了将broken设置为true，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void <span class="keyword">breakBarrier() </span>&#123;</div><div class="line">        generation.<span class="keyword">broken </span>= true<span class="comment">;</span></div><div class="line">        <span class="built_in">count</span> = parties<span class="comment">;</span></div><div class="line">        trip.signalAll()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当所有线程都已经到达barrier处（index == 0），则会通过nextGeneration()进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置count，generation<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">        trip.signalAll();</div><div class="line">        count = parties;</div><div class="line">        generation = <span class="keyword">new</span> Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS作为Java并发基础的框架提供获取状态，acquire，release等公共方法，子类通过实现具体的逻辑来达到不同的同步目的，此外Lock，CyclicBarrier，Semaphore，CountDownLatch作为最基础的同步类为其他同步类提供了基础。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lifeloner.github.io/2017/06/10/AQS/" data-id="cjap2wopp0005k0xfozj5i5zg" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/26/io/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          Java IO浅析
        
      </div>
    </a>
  
  
    <a href="/2017/05/21/btree/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">B Tree</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Basic/">Basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frameworks/">Frameworks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common/">Common</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataStructure/">DataStructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed/">Distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Midware/">Midware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/">Thread</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Common/" style="font-size: 10px;">Common</a> <a href="/tags/DataStructure/" style="font-size: 17.5px;">DataStructure</a> <a href="/tags/Distributed/" style="font-size: 15px;">Distributed</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Midware/" style="font-size: 10px;">Midware</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SpringMVC/" style="font-size: 12.5px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 17.5px;">Thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/10/midwares/">大型系统中的中间件</a>
          </li>
        
          <li>
            <a href="/2017/09/10/consistency/">分布式一致性协议</a>
          </li>
        
          <li>
            <a href="/2017/08/10/distributed/">大型网站架构概念</a>
          </li>
        
          <li>
            <a href="/2017/06/26/io/">Java IO浅析</a>
          </li>
        
          <li>
            <a href="/2017/06/10/AQS/">Java并发之AQS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lifeloner<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>