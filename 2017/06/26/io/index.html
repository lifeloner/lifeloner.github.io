<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java IO浅析 | lifeloner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处">
<meta name="keywords" content="Java,IO">
<meta property="og:type" content="article">
<meta property="og:title" content="Java IO浅析">
<meta property="og:url" content="https://lifeloner.github.io/2017/06/26/io/index.html">
<meta property="og:site_name" content="lifeloner">
<meta property="og:description" content="Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处理字符流和字节流的转换。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/io.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/io_stream.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/bio.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/nio.jpg">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/io_sb.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/io_sn.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/io_sm.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/io_an.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/reactor.jpeg">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/reactor_1.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/reactor_2.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/reactor_3.png">
<meta property="og:image" content="http://oqcre1dsl.bkt.clouddn.com/proactor.jpeg">
<meta property="og:updated_time" content="2017-11-19T08:37:06.377Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java IO浅析">
<meta name="twitter:description" content="Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处理字符流和字节流的转换。">
<meta name="twitter:image" content="http://oqcre1dsl.bkt.clouddn.com/io.png">
  
    <link rel="alternate" href="/atom.xml" title="lifeloner" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lifeloner</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lifeloner.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-io" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/26/io/" class="article-date">
  <time datetime="2017-06-26T12:44:40.000Z" itemprop="datePublished">2017-06-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Basic/">Basic</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java IO浅析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处理字符流和字节流的转换。<br><a id="more"></a><br>而Java IO按照阻塞/非阻塞，同步／异步又可以分为BIO，NIO，AIO，下面我们简单介绍下这几类IO。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>下图展示了Java BIO的体系结构，主要相关部分分为流式结构、非流式结构(file相关)、其他(socket等)：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/io.png" alt="img"><br></center><br>字节流和字符流的常见类如下图所示，主要采用了装饰者及适配器设计模式：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/io_stream.png" alt="img"><br></center></p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流的基础抽象类是InputStream和OutputStream，下面简单看看它们的主要方法和具体实现类<br>1.InputStream<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//方法是读取一个byte字节,但是返回的是int</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//一次性读取内容到缓冲字节数组</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//从stream中跳过long类型参数个位置</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//关闭stream方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> available() <span class="keyword">throws</span> IOExceptionpublic <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span>;<span class="comment">//返回stream中的可读字节数</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> mark(<span class="keyword">int</span> readlimit) <span class="comment">//用于标记stream的作用,readlimit表示调用mark最多可以读多少字节</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//这个方法和mark方法一起使用的，让stream回到mark的位置判断</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span></span>;<span class="comment">//stream是否可以调用mark方法和reset方法</span></div></pre></td></tr></table></figure></p>
<p>这里需要注意下：mark(int readlimit)的参数并不是说读取readlimit个字节标记位才失效，也和BufferedInputStream类的缓冲区大小有关。若BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效，即是取readlimit和BufferedInputStream类的缓冲区大小（BufferedInputStream bis=new BufferedInputStream(in,2)）两者中的最大值。<br>下面介绍一些常用的具体实现类吧：<br>1）.ByteArrayInputStream ：把内存中的一个缓冲区作为 InputStream 使用<br>2）.FileInputStream ：把一个文件作为 InputStream<br>3）. PipedInputStream：实现了pipe，主要在线程中使用，管道输入流是指一个通讯管道的接收端。一个线程通过管道输出流发送数据，另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。<br>4）.SequenceInputStream：把多个 InputStream 合并为一个 InputStream，使用Enumeration作为参数<br>5）.ObjectInputStream：用于操作Object的stream，这个在stream主要用在对象传输的过程中，其中牵涉到了序列化的知识<br>6）.FilterInputStream：是一个过滤的InputStream，有很多具体的子类<br>    6.1）  BufferedInputStream:使用缓冲区的stream<br>    6.2）     DataInputStream:数字格式化的stream（readInt,readFloat,readDouble）</p>
<p>2.OutputStream<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">int</span> b) <span class="keyword">throws</span> IOException; <span class="comment">//写入一个字节</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[]) <span class="keyword">throws</span> IOException；<span class="comment">//写入一个byte数组到stream中</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> IOException；<span class="comment">//把byte数组中从offset开始处写入长度为len的数据</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> flush() <span class="keyword">throws</span> IOException；<span class="comment">//这个方法是用来刷新stream中的数据，让缓冲区中的数据强制的输出</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> close() <span class="keyword">throws</span> IOException；<span class="comment">//关闭流，这个是在操作完stream之后必须要调用的方法</span></div></pre></td></tr></table></figure></p>
<p>常见的具体实现类：<br>1）ByteArrayOutputStream： 把信息存入内存中的一个缓冲区中 . 该类实现一个以字节数组形式写入数据的输出流<br>2）FileOutputStream: 文件输出流是向 File 或 FileDescriptor 输出数据的一个输出流<br>3）PipedOutputStream: 管道输出流是指一个通讯管道的发送端。 一个线程通过管道输出流发送数据<br>4）ObjectOutputStream:输出Object对象的stream<br>5）BufferedOutputStream:带有缓冲区的stream<br>6）DataOutputStream:具有格式化的OutputStream<br>7）PrintStream:直接输出到控制台中：最熟悉的就是System.out是一个PrintStream</p>
<h3 id="字符流-1"><a href="#字符流-1" class="headerlink" title="字符流"></a>字符流</h3><p>字符流的基础抽象类是Reader、Writer，下面看一下主要方法和具体实现类<br>Reader和InputStream的方法基本上一致，区别在于前者使用了char读取字符，而后者使用了byte读取字节<br>1）CharArrayReader：此类实现一个可用作字符输入流的字符缓冲区char[],与 ByteArrayInputStream 对应<br>2）PipedReader：与 PipedInputStream 对应<br>3) BufferReader: 与BufferInputStream对应<br>4）StringReader：从字符串读取<br>5）InputStreamReader：将InputStream转化成Reader，从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。<br>6）FileReader：继承InputStreamReader<br>Writer和OutputStream的方法基本上一致：<br>1）CharArrayWriter： 与 ByteArrayOutputStream 对应<br>2）PipedWriter：与 PipedOutputStream 对应<br>3）StringWriter：输出到StringBuffer<br>4）BufferWriter: 与BufferOutputStream对应<br>5）OutputStreamWriter： 将Writer转化为OutputStream，根据指定的字符编码将多个字符转换为字节，是字符流到字节流的桥梁<br>6）FileWriter：继承OutputStreamWriter</p>
<h3 id="字节流与字符流的选择Tips"><a href="#字节流与字符流的选择Tips" class="headerlink" title="字节流与字符流的选择Tips"></a>字节流与字符流的选择Tips</h3><p>1）按照输入输出   输入： Reader, InputStream 类型的子类；输出： Writer, OutputStream 类型的子类<br>2）按照数据格式  二进制格式（只要不能确定是纯文本的） : InputStream, OutputStream 及其所有带 Stream 结束的子类  ； 纯文本格式（含纯英文与汉字或其他编码方式）； Reader, Writer 及其所有带 Reader, Writer 的子类<br>3）是否需要缓冲     要缓冲： BufferedInputStream, BufferedOutputStream,( 字节流 ) BufferedReader, BufferedWriter( 字符流 )<br>4）按数据来源（去向）分类：<br>    是文件： FileInputStream, FileOutputStream, ( 字节流 )FileReader, FileWriter( 字符 )<br>    是 byte[] ： ByteArrayInputStream, ByteArrayOutputStream( 字节流 )<br>    是 Char[]: CharArrayReader, CharArrayWriter( 字符流 )<br>    是 String: StringReader, StringWriter( 字符流 )<br>    网络数据流： InputStream, OutputStream,( 字节流 ) Reader, Writer( 字符流 )<br>5）其他特殊功能<br>    从 Stream 到 Reader,Writer 的转换类： InputStreamReader, OutputStreamWriter<br>    对象输入输出： ObjectInputStream, ObjectOutputStream<br>    进程间通信： PipeInputStream, PipeOutputStream, PipeReader, PipeWriter<br>    合并输入： SequenceInputStream<br>    更特殊的需要： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</p>
<h3 id="Java-IO性能优化"><a href="#Java-IO性能优化" class="headerlink" title="Java IO性能优化"></a>Java IO性能优化</h3><p>IO的性能瓶颈主要分为：<br>    1）错误的使用缓冲（buffer）<br>        a)为内存IO类（In-memory IO class）添加缓冲(错误用法)：如ByteArrayInput/OutputStream，根本没有使用到IO<br>        b)为已添加buffer的IO类再次添加buffer（错误用法）：多余的buffer只会引入更多的栈调用和垃圾创建<br>        c)Buffer版的IO类和显式使用buffer（使用byte[]或char[]）间的关系（概念上的误解）:实际上显示使用数组使用buffer效率更高<br>            Buffer版IO使用装饰者模式，效率较低; Buffer版IO方法有同步synchroized操作，同步导致效率低下<br>    2）过度的同步保护<br>        Java IO类存在很多同步方法，这样会导致效率低下</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO是指New IO，相对于传统的IO支持非阻塞模式（文件除外），而且NIO是基于Buffer的，性能相比BIO有较大的提升，NIO中有三个主要的概念:Buffer、Channel、Selector.<br>1.Buffer<br>Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。具体的缓存区有：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer，其中ByteBuffer支持堆外直接内存分配。<br>每一个Buffer也有几个关键的信息如：position、limit、capacity、mark等等标记位来代表buffer数据状态情况（具体参考JDK源码）。<br>2.Channel<br>NIO 对数据的读取和写入要通过Channel。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。Channel主要分两大类：SelectableChannel用户网络读写，FileChannel用于文件操作。<br>3.Selector<br>Selector是NIO的基础，它提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。一个Selector可以同时轮询多个Channel，JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p>
<p>NIO相对BIO实现上复杂很多，下面我们简单写一个聊天功能吧：<br>服务端代码：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/9/11.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> class NioServer &#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PORT = <span class="number">6060</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;<span class="keyword">String</span>&gt; userNames = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> initNioServer() &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        	<span class="comment">//  主线程注册等待连接事件</span></div><div class="line">            selector = Selector.<span class="built_in">open</span>();</div><div class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.<span class="built_in">open</span>();</div><div class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</div><div class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"NIO Server initial...Waiting for connecting on port 6060!"</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="built_in">int</span> n = selector.select();</div><div class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    SelectionKey <span class="built_in">key</span> = iterator.next();</div><div class="line">                    iterator.remove();</div><div class="line">                    handleMessage(<span class="built_in">key</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 发送消息，发送到其他所有的通道</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendMessages(Selector selector, SelectionKey sk, <span class="keyword">String</span> content) &#123;</div><div class="line">        <span class="keyword">for</span> (SelectionKey <span class="built_in">key</span> : selector.keys()) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">key</span> == sk) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            Channel channel = <span class="built_in">key</span>.channel();</div><div class="line">            <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> SocketChannel) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    ((SocketChannel) channel).write(charset.encode(content));</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//select监听到事件返回，然后解析具体的SelectionKey，读/写/连接,分别处理</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(SelectionKey <span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>.isAcceptable()) &#123;</div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                SocketChannel socketChannel = ssc.accept();</div><div class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                socketChannel.register(selector, SelectionKey.OP_READ);</div><div class="line">                System.out.<span class="built_in">println</span>(<span class="string">"client:"</span> + socketChannel.getRemoteAddress() + <span class="string">" is connecting"</span>);</div><div class="line">                socketChannel.write(ByteBuffer.wrap(<span class="string">"welcome guys,please input your name!"</span>.getBytes()));</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isReadable()) &#123;</div><div class="line">            SocketChannel socketChannel = (SocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                socketChannel.read(buffer);</div><div class="line">                buffer.flip();</div><div class="line">                <span class="keyword">String</span> content = charset.decode(buffer).toString();</div><div class="line">                <span class="keyword">if</span> (content != <span class="keyword">null</span> &amp;&amp; content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">String</span>[] strings = content.<span class="built_in">split</span>(<span class="string">"_"</span>);</div><div class="line">                    <span class="keyword">if</span> (strings.length == <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (userNames.contains(strings[<span class="number">0</span>])) &#123;</div><div class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">"users already exists!"</span>.getBytes()));</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            userNames.<span class="built_in">add</span>(content);</div><div class="line">                            System.out.<span class="built_in">println</span>(content + <span class="string">", registered!"</span>);</div><div class="line">                            socketChannel.write(ByteBuffer.wrap((<span class="string">"welcome,"</span> + content).getBytes()));</div><div class="line">                            sendMessages(selector, <span class="built_in">key</span>, strings[<span class="number">0</span>] + <span class="string">",enter the char room!"</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sendMessages(selector, <span class="built_in">key</span>, content);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="built_in">key</span>.cancel();</div><div class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        socketChannel.close();</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</div><div class="line">                        e1.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioServer().initNioServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端代码比较简单：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class NioClient &#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> PORT = <span class="number">6060</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> userName=<span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> init() &#123;</div><div class="line">        <span class="built_in">try</span> &#123;</div><div class="line">            selector = Selector.<span class="built_in">open</span>();</div><div class="line">            <span class="comment">//连接远程主机的IP和端口</span></div><div class="line">            SocketChannel sc = SocketChannel.<span class="built_in">open</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, PORT));</div><div class="line">            sc.configureBlocking(false);</div><div class="line">            sc.<span class="keyword">register</span>(selector, SelectionKey.OP_READ);</div><div class="line">            <span class="comment">//开辟一个新线程来读取从服务器端的数据</span></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientThread()).start();</div><div class="line">            <span class="comment">//在主线程中 从键盘读取数据输入到服务器端</span></div><div class="line">            Scanner scan = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">            <span class="built_in">while</span> (scan.hasNextLine()) &#123;</div><div class="line">                <span class="keyword">String</span> <span class="built_in">line</span> = scan.nextLine();</div><div class="line">                <span class="built_in">if</span>(userName.length()==<span class="number">0</span>)&#123;</div><div class="line">                    userName=<span class="built_in">line</span>;</div><div class="line">                    sc.<span class="built_in">write</span>(charset.encode(userName));</div><div class="line">                &#125;<span class="built_in">else</span> &#123;</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"Me: "</span>+<span class="built_in">line</span>);</div><div class="line">                    sc.<span class="built_in">write</span>(charset.encode(userName+<span class="string">"_"</span>+<span class="built_in">line</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新起一个线程接受服务器的数据</span></div><div class="line">    <span class="keyword">private</span> class ClientThread implements Runnable &#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</div><div class="line">            <span class="built_in">try</span> &#123;</div><div class="line">                <span class="built_in">while</span> (true) &#123;</div><div class="line">                    <span class="keyword">int</span> k = selector.select();</div><div class="line">                    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                    Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</div><div class="line">                    <span class="built_in">while</span> (iterator.hasNext()) &#123;</div><div class="line">                        SelectionKey sk = iterator.next();</div><div class="line">                        iterator.<span class="built_in">remove</span>();</div><div class="line">                        <span class="built_in">if</span> (sk.isReadable()) &#123;</div><div class="line">                            <span class="comment">//使用 NIO 读取 Channel中的数据</span></div><div class="line">                            SocketChannel sc = (SocketChannel) sk.channel();</div><div class="line">                            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">                            <span class="keyword">String</span> content = <span class="string">""</span>;</div><div class="line">                            <span class="built_in">while</span> (sc.<span class="built_in">read</span>(buff) &gt; <span class="number">0</span>) &#123;</div><div class="line">                                buff.flip();</div><div class="line">                                content += charset.decode(buff);</div><div class="line">                            &#125;</div><div class="line">                            <span class="built_in">if</span> (content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">String</span>[] strs = content.split(<span class="string">"_"</span>);</div><div class="line">                                <span class="built_in">if</span>(strs.length&gt;<span class="number">1</span>) &#123;</div><div class="line">                                    System.out.<span class="built_in">println</span>(strs[<span class="number">0</span>] + <span class="string">": "</span> + strs[<span class="number">1</span>]);</div><div class="line">                                &#125;<span class="built_in">else</span> &#123;</div><div class="line">                                    <span class="built_in">if</span>(content.equals(<span class="string">"users already exists!"</span>)) &#123;</div><div class="line">                                        System.out.<span class="built_in">println</span>(content);</div><div class="line">                                        userName = <span class="string">""</span>;</div><div class="line">                                    &#125;<span class="built_in">else</span> &#123;</div><div class="line">                                        System.out.<span class="built_in">println</span>(content);</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioClient().init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可以看出，NIO服务端利用了IO多路复用，相比BIO使用了更少的线程，资源利用率更高！<br>总结一下 BIO的优势：1）事件驱动模型，2）单线程处理多任务，避免了多线程等待，3）非阻塞I/O，I/O读写不再阻塞，而是返回0 4）IO多路复用大大提高了Java网络应用的可伸缩性和实用性<br>更多的NIO教程可以参考JDK源码。</p>
<h2 id="IO模式对比"><a href="#IO模式对比" class="headerlink" title="IO模式对比"></a>IO模式对比</h2><p>下面我们对比一下NIO与BIO的模式，然后再分析一下Java IO中的同步与异步、阻塞与非阻塞概念。</p>
<h3 id="BIO-VS-NIO"><a href="#BIO-VS-NIO" class="headerlink" title="BIO VS NIO"></a>BIO VS NIO</h3><p>BIO模式中，服务端由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型，如下图所示：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/bio.png" alt="img"><br></center><br>BIO最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，当线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就down机，所以BIO主要的问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程来处理这条链路，无法满足高性能、高并发的场景。当然可以使用一个线程池来管理这写具体的数据处理，以此来达到线程服用，节省服务器资源，但是这种方法不能解决问题的根本，在大量线程处于等待情况下仍然不能很好利用资源。<br>NIO模式的处理流程如下图所示：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/nio.jpg" alt="img"><br></center><br>可以看出NIO服务端由一个单独的线程来轮询等待事件到来，在没有事件时不会存在大量的线程阻塞，只有有事件时才会在新的线程中处理任务，因此不会造成大量线程阻塞，支持更高的并发，性能相比BIO有较大的提升。</p>
<h3 id="同步与阻塞"><a href="#同步与阻塞" class="headerlink" title="同步与阻塞"></a>同步与阻塞</h3><p>首先解释下一下同步、异步概念以及阻塞、非阻塞概念。<br>首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO也分为二步，等待数据就绪以及数据拷贝（核心态内存到用户态内存）。所以可以看出，同步异步主要是应用程序和内核的交互方式，若应用读写直到IO完成那么就是同步的，若由操作系统完成IO读写放入缓冲区然后会调通知应用直接取数据那么就是异步的；同样阻塞和非阻塞区别在于在应用访问数据的时候，根据IO操作的就绪状态来采取的不同方式，是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。<br>下面我们结合下图看一下常见的几种模式：<br>阻塞IO:阻塞在recvfrom调用</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/io_sb.png" alt="img"><br></center><br>非阻塞IO:反复轮询recvfrom</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/io_sn.png" alt="img"><br></center><br>IO多路复用:实质阻塞在select调用（select/poll,epoll轮询），数据准备好开始读取（核心态到用户态）</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/io_sm.png" alt="img"><br></center><br>异步IO：发起aio-read请求，等待数据准备好并拷贝到用户态缓存区（依赖OS），然后读取</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/io_an.png" alt="img"><br></center><br>在这里简单了解下多路复用的概念以及select／poll，epoll的区别：<br>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符（fd）就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间<br>select的缺点：<br>    1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>    2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（fd_set类似数组的结构需要遍历）<br>    3）select支持的文件描述符数量太小了，默认是1024<br>poll和select几本一致，区别在于其描述符FD定义不同,它使用的是pollfd；<br>epoll是linux新出用于取代poll、select，处理上述三个问题时：<br>    1）次注册新的事件到epoll句柄中时（epoll_ctl函数）会把所有的fd拷贝进内核，不会在epoll_wait的时候重复拷贝<br>    2）epoll_ctl为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表,epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd(也有人说用了红黑树所以比数组快)<br>    3）epoll没有最大FD这个限制</p>
<p>此外Java中BIO，NIO，AIO的模式区别：<br>BIO：同步阻塞方式，同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善<br>NIO：同步非阻塞方式，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，由多路复用器轮询到连接有IO请求时才启动一个线程进行处理，所以是非阻塞的。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，但是从内核读取数据到用户缓冲区需要应用程序自己完成，因此是同步的。<br>AIO：异步非阻塞，JDK1.7后出现，一个有效请求一个线程，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。常见的类有AsynchronousSocketChannel，AsynchronousServerSocketChannel，AsynchronousFileChannel，AsynchronousDatagramChannel<br>总结一下，BIO关注“我要读”，NIO关注”我可以读了”，在AIO模型关注的是“读完了”，此外NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。BIO，NIO，AIO也有不同的适用场景：<br>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 </p>
<h2 id="Reactor与Proactor"><a href="#Reactor与Proactor" class="headerlink" title="Reactor与Proactor"></a>Reactor与Proactor</h2><p>Reactor与Proactor是两种常用的IO模式，其中Reactor是同步IO模式，被广泛应用于网络编程中，如Redis、Netty；而Proactor是一种异步IO模式，由于操作系统的原因，相关的开源产品也少；在这先里我们学习下其模型结构，重点对比下两者的异同点；<br>首先我们先看一下reactor的结构：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/reactor.jpeg" alt="img"><br></center><br>Reactor包含如下角色：<br>    1.Handle 句柄；用来标识socket连接或是打开文件；<br>    2.Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）<br>    3.Event Handler：事件处理接口<br>    4.Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；<br>其流程如下：<br>    1.应用启动，将关注的事件handle注册到Reactor中；<br>    2.调用Reactor，进入无限事件循环，等待注册的事件到来；<br>    3.事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</p>
<p>而Reactor也包含了常见三种类型：<br>1.精典Reactor模式</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/reactor_1.png" alt="img"><br></center><br>可以看出Acceptor处理客户端连接请，Reactor将I/O事件发派给对应的Handler，由Handlers 执行非阻塞读/写及数据处理操作，这种模式下一个线程同时监控多个请求状态。<br>2.多工作线程Reactor模式</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/reactor_2.png" alt="img"><br></center><br>经典Reactor模式中，尽管一个线程可同时监控多个请求（Channel），但是所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读/写操作也会阻塞对新连接请求的处理。因此可以引入多线程，可以使用线程池来并行处理多个读/写操作。<br>3.多Reactor模式</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/reactor_3.png" alt="img"><br></center><br>多工作线程Reactor模式下，主线程也需要监听多种事件，当并发量过大时也会导致性能瓶颈，也存在单点故障问题，所以引出了多Reactor，即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读/写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟，并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel提交给不同的子Reactor处理，每一个子Reactor包含一个Selector实例，用来监听监听事件，并且监听在子Reactor所在的线程中，保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换；同样每一个子Reactor中创建了一个静态的线程池，循环处理数据读取和操作，相比单一的Reactor大大提升了效率。</p>
<p>Proactor的结构如下所示：</p>
<p><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/proactor.jpeg" alt="img"><br></center><br>主要包含了如下角色：<br>    1.Handle 句柄；用来标识socket连接或是打开文件；<br>    2.Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；<br>    3.Asynchronous Operation：异步操作<br>    4.Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用<br>    5.Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；<br>    6.Completion Handler：完成事件接口；一般是由回调函数组成的接口；<br>    7.Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；<br>其工作流程如下：<br>    1.应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；<br>    2.应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；<br>    3.异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；<br>    4.主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java IO中包含了BIO、NIO、AIO等多种模式，每一个模式有不同的特点和应用场景，这些都是IO的基础知识。此外有时间一定要学习一些开源的框架如Netty，它基于NIO，使用了Reactor<br>模式，同时也要多了解一下AIO模式如Proactor（异步IO）等高性能的IO模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lifeloner.github.io/2017/06/26/io/" data-id="cjap2woqo0010k0xfm28ie60x" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/10/distributed/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          大型网站架构概念
        
      </div>
    </a>
  
  
    <a href="/2017/06/10/AQS/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Java并发之AQS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Basic/">Basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Concurrent/">Concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frameworks/">Frameworks</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Common/">Common</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataStructure/">DataStructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed/">Distributed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Midware/">Midware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/">Thread</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Common/" style="font-size: 10px;">Common</a> <a href="/tags/DataStructure/" style="font-size: 17.5px;">DataStructure</a> <a href="/tags/Distributed/" style="font-size: 15px;">Distributed</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Midware/" style="font-size: 10px;">Midware</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/SpringMVC/" style="font-size: 12.5px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 17.5px;">Thread</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/10/midwares/">大型系统中的中间件</a>
          </li>
        
          <li>
            <a href="/2017/09/10/consistency/">分布式一致性协议</a>
          </li>
        
          <li>
            <a href="/2017/08/10/distributed/">大型网站架构概念</a>
          </li>
        
          <li>
            <a href="/2017/06/26/io/">Java IO浅析</a>
          </li>
        
          <li>
            <a href="/2017/06/10/AQS/">Java并发之AQS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lifeloner<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>