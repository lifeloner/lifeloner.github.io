<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lifeloner</title>
  
  <subtitle>当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lifeloner.github.io/"/>
  <updated>2017-12-02T10:06:26.795Z</updated>
  <id>https://lifeloner.github.io/</id>
  
  <author>
    <name>lifeloner</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大型系统中的中间件</title>
    <link href="https://lifeloner.github.io/2017/10/11/midware/"/>
    <id>https://lifeloner.github.io/2017/10/11/midware/</id>
    <published>2017-10-11T02:10:10.000Z</published>
    <updated>2017-12-02T10:06:26.795Z</updated>
    
    <content type="html"><![CDATA[<p>大型系统的发展离不开中间件的支持，从大型网站系统的发展历程中，我们也看到了中间件发挥的重要作用。下面我们了解一下最常见的服务框架、数据访问中间件和消息中间件以及相关的软负载中心，学习它们的设计过程以及在大型系统中解决的问题。</p><a id="more"></a><h2 id="服务框架">服务框架</h2><p>在早期的互联网系统中，大多数网站系统如处于下图这个阶段，这样的系统结构在早期能够很好解决问题。随着网站规模扩大，业务复杂，应用开始变得臃肿。多个应用中会有大量重复冗余的代码，不利于系统的维护和稳定性。这种情况下，可以采用应用拆分的方法，将大应用拆分成小应用，降低冗余，但是仍然还在重复代码，不能从根本上解决问题。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/traditionalArch.png?imageMogr2/thumbnail/!40p)</center>另外可以采用服务化的方案，如下图所示，我们在底层的数据库、缓存系统和应用层之间增加一层服务层，服务可以有多层也可以相互访问，这样系统结构更清晰了，一些重复的代码都做成了服务。这样有两个好处：一方面服务由专门团队管理，提升了代码质量，另一方面，底层的资源由服务层来管理，结构清晰，开发效率高，也更加稳定。当然服务化带来的远程服务调用也需要进行管理，也就是所谓的服务治理，这也是很重要很关键的部分，关联着整个系统的稳定性。<center>![img](http://oqcre1dsl.bkt.clouddn.com/soaArch.png?imageMogr2/thumbnail/!40p)</center><h3 id="服务框架的设计与实现">服务框架的设计与实现</h3><p>当把应用的结构改成包含有服务框架的多层结构时，服务化使得一些本地的调用变成了远程调用（RPC）。在这种改变下，服务框架的易用性和性能十分重要，下面我们看一下服务调用的客户端和服务端实现。</p><h4 id="远程调用方式">远程调用方式</h4><p>调用端的实现中重要的一步是跟据调用的服务名称来获取提供服务的机器地址列表，然后从可用的服务地址中选择一个可调用的机器，然后发送参数和调用接口。在获取可选择服务机器时，常存在三种控制方式：（1）LVS或硬件负载均衡设备；（2）名称服务方式（3）规则服务器，该方式与名称服务很类似，只不过规则服务器常用于有状态的场景下，其中（2）（3）都是直连的方式。</p><h4 id="服务的路由">服务的路由</h4><p>在具体调用远程服务时需要通过服务名称进行寻址和路由，具体的控制需要由interfaceName+version（用于服务升级）+group（用于服务隔离、优先级设置等）来确定，这三部分通常在Java中通过Spring IOC注入为一个Bean。其次，我们需要解决服务框架和应用的依赖关系，通常有二种方式：（1）将服务框架做成应用的一个依赖包，随应用一起打包，但不够灵活，修改后需要重新打包，（2）将服务框架作为容器的一部分。最后，对于服务框架和应用的Jar包冲突问题，一般通过自定义类加载器来进行隔离。</p><h4 id="网络通信">网络通信</h4><p>在完成了寻址和路由情况下，需要进行数据发送和通信，这里涉及到序列化与反序列化，这里一方面需要定义协议的通信方式（如HTTP协议）以及序列化协议（XML，Json），此外也应该考虑一些常用的其他特点，如是否支持数据压缩等等。服务端根据服务名称、版本号、方法名称得到具体的服务接口，然后根据参数进行调用，最后把结果返回给调用端。<br>在具体的网络通信中，有BIO，NIO，AIO方式，其中NIO是一种常用的方式，它也是一种同步调用的方式，采用NIO的方式远程调用的方式如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/serviceNio.png?imageMogr2/thumbnail/!40p)</center>IO线程用于Socket连接发送数据，发送的数据也会首先放入数据队列。通信对象用于阻塞和唤醒请求的线程，并把结果传递给请求线程或通知超时。当采用异步调用方式时，常有3三种方式：(1)Callback回调如下图所示，调用方将数据放入数据队列后开始继续执行业务，IO线程收到远程调用结果后通知回调对象，然后执行回调方法，回调方法的执行最好在新的线程中，以免执行时间太长。<center>![img](http://oqcre1dsl.bkt.clouddn.com/callback.png?imageMogr2/thumbnail/!45p)</center>(2)Future：Java中的Future本身支持回调(3)消息队列：依赖消息中间件来异步<h4 id="服务管理">服务管理</h4><p>(1)服务隔离<br>当某些服务执行非常慢时，为避免占用太多资源影响其他服务，可以将某些接口的服务调用进行隔离，使之路由到指定的集群。同样也可以对某些请求用户进行特殊处理，根据需求进行细粒度的服务规则设计。<br>(2)多机房<br>当存在多个机房（同城、异地）部署时，为了更快速执行服务调用，可以在服务注册查找中心进行地址过滤，根据不同的调用者提供相同不同的调用者集群；此外也需要考虑不同机房处理能力是否相同，机房是否负载均衡等问题。<br>(3)流控<br>为了保证服务系统的稳定性，防止恶意攻击，需要对服务进行流量控制。通常有二种设置方式：简单的0-1开关以及设置阈值（对接口设置不同阈值，也可以对根据不同调用方设置不同阈值）</p><h4 id="服务框架实战">服务框架实战</h4><p>服务拆分：需要拆分服务往往是通用的基础功能<br>服务粒度：根据业务需求<br>分布式环境下请求合并：对于常用的请求，可以将它路由到同样的机器上，然后进行缓存或单机上任务合并（其他现场有同样的任务，可以等待完成，避免重复计算）<br>服务质量：最好、最差的服务；服务质量趋势<br>服务容量：服务水位展示与排序、历史趋势图<br>服务依赖：依赖服务展示、被依赖展示、依赖变化<br>服务分布：同机房、不同机房、服务负载均衡分布<br>服务统计：调用次数与排名、出错次数、响应时间统计、趋势<br>服务查询：容量、质量、次数等等<br>服务监视：关键数据采集、告警<br>服务报表：数据统计生成报表<br>服务上下线：指定服务、指定机器<br>服务路由：路由规则、管理、回滚<br>服务限流降级：根据调用来源、具体服务、流控、多版本<br>服务线程池：线程工作状态、不同业务线程池<br>服务授权：授权信息及规则、多版本支持与回滚</p><h2 id="数据访问中间件">数据访问中间件</h2><p>随着数据量和访问量的上升，数据库也会成为瓶颈，所以需要减少数据库的压力，常用的解决方案主要有三种：（1）对应用进行优化；（2）加入缓存系统和搜索引擎；（3）分布式数据库。然而分布式数据库相对于单机数据库也更加复杂，引入了很多新的问题。</p><h3 id="分布式数据库的挑战与应对方案">分布式数据库的挑战与应对方案</h3><p>1.垂直/水平拆分的困难<br>垂直拆分把不同业务数据分到不同的数据库，而水平拆分根据一定的规则把同一业务的数据拆分到多个数据库，但单机数据库的一些特性就不支持了。<br>(1)ACID事务被打乱，要么修改实现，要么依靠分布式事务<br>(2)Join操作困难，跨库Join需要特殊实现<br>(3)外键约束场景收到影响<br>(4)数据库Id自增生成<br>(5)水平拆分后同一个表的查询收到影响</p><p>2.分布式Sequence处理<br>当水平拆分后，数据库的Sequecne及自增Id如何保证，这引发了2个问题：Id的唯一性和连续性。对于唯一性可以采用UUID的生成方式，或者根据业务特点使用种子（IP、MAC、时间戳等），但不能保证连续性。为了保证唯一性和连续性，可以将Id统一在一个地方进行管理，即使用Id生成器，所有节点通过Id生成器来获取Id，这种方式当然也存在一定的不足：（1）性能问题，（2）稳定性，单点问题，（3）存储问题，备份容灾</p><p>3.分布式数据查询<br>跨库Join：（1）将Join操作分成多次数据库操作，（2）数据冗余，数据表中增加常用的数据，（3）借助外部系统（搜索引擎等）<br>外键约束：应用层的判断、容错<br>跨库常见查询<br>（1）简单查询：通过条件定位到某个库某个表<br>（2）复杂查询：先通过条件定位到某些库某些表，然后合并查询结果<br>（3）排序操作：若从单个库查出来已经有序，直接做一个归并排序；否则在应用层面上需要合并结果后做一个全排序<br>（4）函数处理：如max、sum、count等，则对每个来源数据分别进行函数处理，然后最后合并<br>（5）平均值：对所有来源数据先分别进行sum和count处理后，在计算avg<br>（6）非排序分页：一般有2种；等步长：每页每个数据源数据量相同；等比例：每页中按不同数据源比例不同<br>（7）排序后分页：相比非常麻烦，必须从每个数据源得到足够的数据</p><h3 id="数据访问层的设计与实现">数据访问层的设计与实现</h3><p>数据访问层就是方便应用数据读/写访问的抽象层，在这一层解决访问数据层的通用问题。通常，解决数据访问的方式常有3种方案；（1）专有API方式，但通用性很差，扩展性差；（2）基于JDBC，数据访问层作为JDBC的实现，暴露出JDBC的接口给应用；（3）基于ORM方式，在ORM上再包装一层，实现数据层的功能，对外暴露扔是原来框架的接口。下图展示了这三种方式的结构。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/dataservice.png?imageMogr2/thumbnail/!45p)</center>可以看出，基于JDBC成本最高，但兼容性和扩展性最好；基于ORM具备一定的通用性，实现成本相对较低。<p>下面我们继续分析一下数据层的整体流程，大致的步骤如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/datastream.png?imageMogr2/thumbnail/!45p)</center><h4 id="sql解析">SQL解析</h4><p>SQL解析主要考虑的问题有2点：（1）SQL的支持程度，是否需要支持全部SQL；（2）支持多少SQL方言。另外SQL解析可以利用缓存来提升解析速度，也需要注意缓存的容量限制。SQL解析后得到一些关键信息，如表名、字段、条件等。</p><h4 id="规则处理">规则处理</h4><p>（1）固定hash算法做规则<br>该方法通常对某个字段取模，hash规则的设置和实现都比较简单，但是扩容比较复杂，数据迁移很麻烦。<br>（2）一致性hash算法<br>该算法增删节点时，影响节点少，数据迁移较少，但很难保证各个节点的负载均衡，可以通过虚拟节点来改进，使得节点负载均衡。<br>（3）自定义规则<br>该方法自定义函数来解决数据访问规则，用于解决热点数据访问和不完全符合规则进行补充。</p><h4 id="sql改写">SQL改写</h4><p>数据库分库分表后，需要对SQL进行改写，比如一个表变成多个数据库的多个表，表名、索引名称是否一样；分页操作处理；一些函数操作如max、sum、avg也需要特殊处理。</p><h4 id="数据源的选择">数据源的选择</h4><p>对于SQL的执行，一方面由于数据库分库分表带来了变化，另一方面也由于数据库的主从备份、读写库、事务等导致SQL的执行必须选择合理的数据源。<br>数据源的配置一般是三层的结构，当数据库分库分组后，我们使用groupDataSource来进行配置和管理；在分库分组后，再按照数据源的功能进行切分，使用AtomDataSource来管理一个具体的数据库，数据访问三层结构如下图所示。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/threedatasource.png?imageMogr2/thumbnail/!45p)</center><h4 id="实现方式">实现方式</h4><p>对于数据访问层对应用的呈现方式，从数据层物理部署来说分为Jar包和Proxy方式，如果采用Proxy方式，客户端应用与数据访问层的协议有两种选择：数据库协议与私有协议，如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/dbprotocol.png?imageMogr2/thumbnail/!45p)</center>数据库协议特点：应用将Proxy当成一个数据库，使用JDBC实现连接Proxy，应用到Proxy，Proxy到DB都采用数据库协议，少了一次协议到对象然后对象到协议的转换，但实现成本高且不能复用。私有协议特点：实现简单，应用需要一个数据库访问层客户端，并且应用到Proxy的连接可以复用，从应用到数据库底层的整个结构如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/dbstructure.png?imageMogr2/thumbnail/!40p)</center><h4 id="数据读写分离和复制">数据读写分离和复制</h4><p>1.主从库对称<br>根据应用特点将数据延迟不敏感的读切换到备库，然后复制时注意延迟<br>2.主从库非对称<br>（1）多从对一主库<br>使用消息系统，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/dbmsg.png?imageMogr2/thumbnail/!40p)</center>通过消息系统将数据变更通知发出，数据同步服务器获取通知后根据分库规则进行数据复制（2）主备分库方式不同在大多数情况下，数据库复制是对等的，但由于业务需求，主数据库和备用数据库并非完全对等复制，即源数据库和目标数据库是不同的实现，如图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/dbcopy.png?imageMogr2/thumbnail/!60p)</center>主库中，根据买家id分库，备库中根据卖家id分库，这样在查询卖家订单时只用在备库中进行查询了，避免了跨库操作，但复制的过程也增加了数据的控制和分发，不是简单的复制了！（3）数据变更平台在大型系统中，有一些其他场景也会关注数据的变更，如缓存系统（缓存失效）和搜索引擎（索引建立），可以构建一个通用的平台来管理和控制数据变更，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/dbplatform.png?imageMogr2/thumbnail/!50p)</center>在系统中引入Extractors与Applier，其中Extractors把源数据变更信息加入数据分发平台，而Applier把变更通知应用到目标上，数据分发平台由多个管道组成。<h4 id="数据平滑迁移">数据平滑迁移</h4><p>对于无状态的应用，扩容和缩容比较容易，而对于数据库，扩容缩容会引起数据的迁移。若允许停机操作，处理相对容易，若不能停止，就比较麻烦了，因为迁移的过程中可能有新数据的变化。可以采取以下方案：<br>（1）开始进行数据迁移，并记录数据库的数据变更增量日志<br>（2）数据复制到新库，也有新的更新记录下来<br>（3）全量迁移结束后把增量日志数据也迁移进来，此时还会有新的增量日志，这是一个逐步收敛过程<br>（4）进行数据对比，记录源库和目标库不一样的数据<br>（5）停止需要迁移数据的写操作，增进增量数据处理，使得新库数据是最新的<br>（6）更新路由规则，所有新数据到了新库，完成迁移操作</p><h3 id="总结">总结</h3><p>随着数据量、访问量的增加，我们会进行分库和分表，这也带来了一些共性的问题。数据访问层正是为此为应用提供统一的接口。整个数据层的结构如下图所示，应用层有多种选择，代理层除了可以使用DB的native API方式外，也可以像应用一样使用各种方式来工作。从应用到DB就是一个链式处理过程，这一过程中大多数的组件都是对外提供JDBC的实现，方便各个组件进行替换。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/dbArch.png?imageMogr2/thumbnail/!40p)</center><h2 id="消息中间件">消息中间件</h2><h3 id="初始消息中间件">初始消息中间件</h3><p>消息中间件给应用带来了异步、解耦的特性，下面我们从一个具体的例子来看消息中间件的如何做到应用解耦。<br>假如有一个应用登陆系统，主要功能是，用户登陆成功后发送一条短信到用户手机，然后把用户登陆信息录入安全系统进行处理，此时的系统的结构示意图如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mqdirect.png?imageMogr2/thumbnail/!40p)</center>但是如果还需要增加别的功能，就会反复修改登录系统来进行其他调用，这种直接调用非常不便维护和扩展。我们仔细分析可以看出，登录系统并不依赖于短信服务和安全系统服务，恰恰相反后者依赖与前者，如果引入消息中间件则可以将上面的结构解耦，通过消息传递来替代服务调用。登录系统不用关注有多少系统关注登陆成功事件，也不用关心如何通知，只需要往消息中间件发消息，其他系统订阅消息，系统之间互不干扰，系统结构示意图如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mq.png?imageMogr2/thumbnail/!40p)</center><h3 id="消息中间件的关键点">消息中间件的关键点</h3><p>在介绍消息中间件之前，我们先了解一下JMS（Java Message Service），它是Java EE的一个消息规范，ActiveMQ也是这个规范的具体实现。在消息中间件的设计中，有一些非常重要的因素需要保证，其中有消息的顺序保证、可靠性、扩展性、消息发送与业务操作的一致性、多集群订阅者等，下面我们分别分析这些方面。</p><h4 id="消息发送一致性">消息发送一致性</h4><p>消息一致性是指消息发送与产生消息的业务操作一致，若业务操作成功，则消息要发送出去；业务失败则消息不应该发出。在JMS中，基于XA系统的接口，利用了分布式事务来保证消息一致性，但JMS也存在一定的弊端：（1）分布式事务开销大，复杂性高；（2）业务操作的资源必须支持XA协议，才能与发生消息一起做分布式事务。<br>既然JMS的XA协议比较不适应，那么我们可以设计一种解决方案，该方案对正常流程影响小，在出现问题后能够解决问题，即使用最终一致性的解决方案，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mqc.png?imageMogr2/thumbnail/!40p)</center>步骤如下：（1）业务应用首先把消息发送给消息中间件，标记消息状态为待处理（2）中间件收到消息把消息进行存储，并不投递消息（3）消息中间件存储后返回消息存储结果（4）业务收到中间件结果进行处理，若失败则放弃执行业务，若成功则执行业务（5）业务操作完成，将业务结果发送给消息中间件（6）消息中间件收到业务执行结果进行后续处理，若业务失败则删除消息；若成功则更新消息为可发送，然后进行消息的投递在这些过程中，难免会存在很多异常，那么我们分析下每一步异常可能导致的后果：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mqexception.png?imageMogr2/thumbnail/!50p)</center>由此可以看出，主要的异常有三类：（1）业务未执行，消息未存储（2）业务未执行，消息存储，状态待处理（3）业务执行，消息存储，状态待处理第（1）种是正常情况，而后面两种需要中间件去主动询问业务执行情况，然后业务检查执行结果进行反馈（成功，失败，等待，等待表示业务还在执行中），该过程称为反向过程，是一个补偿方案，用于解决不一致的情况，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mqback.png?imageMogr2/thumbnail/!40p)</center>当然，该反向补偿方案也会存在异常，但前三步都是查询操作，不影响状态，最后一步更新失败可以重试，也没有特别大错误。所以，正向和反向的结合，保证了最终的一致性状态。该方案相比传统的方式不同之处如下：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mqcompare.png?imageMogr2/thumbnail/!45p)</center>可以看出，该方案相比传统的方案之多出了2步，所以额外开销并不是很大。<h4 id="消息中间件与应用的依赖问题">消息中间件与应用的依赖问题</h4><p>在保证业务操作和发送消息的一致性方案中，我们更多关注了如何解决一致性问题，但是也导致了一个问题，消息中间件成为了业务应用的必要依赖。一旦消息中间件不可用，即使业务应用正常也将无法继续进行，可以采用的一个方案：将消息中间件中影响业务操作的部分的可靠性与业务自身可靠性相同，业务成功消息必须入库，即使中间件出现了问题，可以接受延迟，但是必须保证消息入库。可行的一种设计思想如下：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/appmq.png?imageMogr2/thumbnail/!35p)</center>将中间件的消息表与业务数据表放在一个数据库中，从而将业务操作与写入消息作为一个本地事务完成，然后通知消息中间件有消息可以发送，但这一步在图中是虚线，表示它并不是一个必要操作，中间件可以定时去轮询消息表，找到发送的消息。但该方式也有3个不足：（1）需要业务数据库承载消息（2）消息中间件需要访问业务数据库（3）业务操作的对象是数据库，必须支持事务的存储，这个存储也必须支持中间件基于上述方式，我们进行改进，消息中间件不再与业务数据库打交道，完全由业务应用控制消息生成、重试，消息中间件更多只是接受消息并进行投递，如下图所示：![img](http://oqcre1dsl.bkt.clouddn.com/appmqd.png?imageMogr2/thumbnail/!35p)这两种方式虽然能解决大部分问题，但都依赖于支持事务的数据库，具有局限性，可以将本地磁盘作为消息的存储，消息中间件不可用时可以将消息存储在本地磁盘，等中间件恢复后再将消息发送到中间件，这样消息的管理、重试等也是在中间件进行，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/appmqf.png?imageMogr2/thumbnail/!35p)</center>但是若中间件不可用，写入本地磁盘也出错，则消息丢失了，需要补偿机制。本地磁盘作用有2个：（1）消息的容灾，（2）保证业务操作和存储消息的时间，也便于应用与消息中间件之间做一些批量处理，提升效率。<h4 id="消息模型对消息接收影响">消息模型对消息接收影响</h4><p>在JMS中，消息模型有Queue（点对点）和Topic（发布/订阅）两种，下面我们分别看一下两种模型的特点。<br>1.Queue模型<br>在Queue中，消息根据到达顺序形成一个队列，所有连接到Queue上的应用共同消费了所有的信息，一个消息只能被一个应用去消费，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mqqueue.png?imageMogr2/thumbnail/!40p)</center>2.Topic模型Topic和Queue区别在于，每一个消息接收方可以接受全部消息，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mqtopic.png?imageMogr2/thumbnail/!40p)</center>现实业务中，常见的业务需求有：（1）消息发送方和接收方都是集群；（2）一个消息需要被不同集群消费；（3）一个消息在一个集群中只能被消费一次在JMS中一个进程可以有多个Connection，支持发送方和接收方都是集群，但是Topic和QUeue都难于保证一个消息只能被同一集群的某个节点消费，所以需要一种混合的方式。具体来说把Topic和Queue的特点结合起来，同一集群使用一个clusterId来消费消息，具体方式如下所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mqmix.png?imageMogr2/thumbnail/!50p)</center><h4 id="消息订阅模式">消息订阅模式</h4><p>消息订阅模式分为持久/非持久方式。<br>非持久模式：消费者应用退出后，消息不会为消费者保存，消费者应用启动后又可以重新消费消息了。<br>持久订阅：消费者应用退出后，消息会保存下来，除非消费者应用取消订阅，消费者重启后会将消息不遗漏的发送消费者。<br>可以看出，持久订阅是一种可靠的消息订阅模式。</p><h4 id="保证消息可靠性">保证消息可靠性</h4><p>在持久订阅模式下，保证消息的可靠性对于消息中间件至关重要。我们知道，消息从发送端到接受端主要有3个过程：（1）消息发送者-消息中间件；（2）消息中间件对消息进行存储；（3）消息中间件将消息投递给消息接受者，所以必须保证这三步都可靠，才能保证整个消息的可靠，下面分别从这三方面进行介绍。<br>1.消息发送端的可靠性<br>消息从发送者到中间件，只有当中间件及时、明确地返回成功才意味消息到达了中间件，返回错误、超时等情况都是发送动作失败。这里要注意中间件返回到异常被内部消化而没有发现异常。<br>2.消息存储的可靠性<br>消息存储采用的存储系统有很多，如关系型数据库、分布式文件系统、Nosql等，这些产品各有特色适用不同的场景下。<br>（1）文件系统<br>分布式文件系统的稳定性和性能有待提升，对于消息的检索也是不支持的，但消息直接存储在本地不需要额外的存储，针对机械硬盘的特点尽量进行顺序写和顺序读。此外，当消息被消费时，文件容易存在“空洞”现象（类似GC中的内存碎片），需要额外的整理操作。对消息的检索处理也需要考虑索引对内存消耗。<br>（2）关系型数据库<br>再利用关系型数据库进行消息存储时，数据库的设计会十分复杂，不会遵循常见的数据库范式设计，常采用数据冗余的方式实现。数据冗余避免了表关联查询，也需要考虑数据的备份和容灾。<br>（3）双机内存的消息存储<br>基于文件系统和关系型数据库的方式，系统性能受到限制，所以可以采用混合的方式进行存储和管理，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mqmemory.png?imageMogr2/thumbnail/!45p)</center>采用双内存的方式来保证数据可靠性，正常情况下消息持久存储不工作，当一台机器故障时，则停止另一台机器的写操作，然后将数据写入磁盘永久存储。只要不遇到两台机器同时故障，而且一台故障另一台写入持久存储错误时，消息是可靠的。这种方式适合消息存储在中间件后被及时消费的情况，能很好提升性能。（4）消息系统的扩容-消息中间件自身扩容消息中间件没有持久状态，扩容相对容易。主要让发送者和接受者能够感知有新消息中间件加入到集群中，这是通过软负载中心实现的。不同的消息中间件可能共用存储，也可能使用不同的存储，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mqstore.png?imageMogr2/thumbnail/!45p)</center>-消息存储的扩容消息的存储一方面不用保证消息有序；另一方面提供了服务端对消息的投递，不支持主动获取消息。在数据访问层提到了数据库的分库分表、路由规则等，但消息中间件不需要支持外部主动去查询消息，因为发送者发送消息到中间件时，中间件肯定知道消息存储位置，投递时也知道消息在哪。3.消息投递的可靠性这一步需要保证消息中间件收到接受者处理信息完毕的信号才能删除消息，不能根据网络层判断消息是否已经送达，一定要从应用层入手。此外接受者在处理消息异常时 ，不要吃掉异常而返回成功，这样会丢失消息。此外，投递消息时为了提升效率可以采取多线程的方式，将投递消息和处理返回结果线程分开，投递线程只投递消息，投递完一条消息继续投递其他消息，处理结果返回后再由处理线程处理。另一个优化地方，对同一一个应用的多个模块订阅同一个消息，中间件可以避免多次投递消息，仅投递一次消息到应用，由应用在应用内复制消息提示消息投递性能。<h4 id="消息重复">消息重复</h4><p>消息重复的原因有二类：发送端重复发送消息和中间件重复投递消息<br>1.发送端消息重复发送<br>该步骤原因有二种：（1）发送端发送消息到中间件，中间件此时故障未返回消息，导致重复发送；（2）中间件返回结果超时（中间件负载高、网络延迟等），发送端重复发送消息，该问题可以通过在发送端产生消息Id来解决。<br>2.中间件重复投递<br>该步骤主要原因有2个：（1）消息中间件投递消息后未收到应用反馈结果（应用故障、中间件故障、网络问题）（2）中间件投递后超时了，中间件重试，该问题比较复杂，在中间件处理重复消息比较困难，常用做法是在消息接受端处理重复消息，也就是保证消息幂等性（多次执行得到同样结果），但这也给接受端应用带来了复杂设计。<br>消息接受者对消息接受一般会出现at least once 和 at most once两种，exactly once较难保证，需要额外处理，十分复杂。</p><h4 id="消息投递其他属性">消息投递其他属性</h4><p>1.消息优先级<br>一般消息是先到先投递，为了对消息进行优先级处理，可以根据设置消息的优先级属性，也可以把消息设计不同的类型，同一类型的消息在根据优先级进行不同处理。<br>2.消息处理顺序和分级订阅<br>一般情况下，多个消息订阅者之间互不干扰，但有时需要维持消息订阅者处理消息的顺序，这种情况下一方面可以设置优先处理消息的订阅者集群Id，即消息订阅者处理消息顺序，另一方面也可以分级处理，优先接受者处理消息成功后再把消息放入其他中间件，然后其他订阅者再处理，但这样重复发送了消息，多了一次消息入库操作。<br>3.自定义属性<br>一般出了消息自身的创建时间、类型、投递次数等属性，一些自定义的属性如消息过滤等对消息的特殊处理带来很多便利<br>4.消息局部顺序<br>局部顺序性是指部分消息之间有处理顺序，但全局的消息之间没有顺序。如商品的购买-付款-发货，某一具体商品三个消息之间有顺序，但任何两个商品的消息之间无任何顺序，所以需要在消息上设置一个属性，来表明该消息与那些消息有顺序。</p><h4 id="保证顺序的消息中间件">保证顺序的消息中间件</h4><p>在某些场景下，我们需要一种高效的支持顺序的多集群订阅消息中间件实现，如数据变更通知平台。在这种消息顺序场景下，接受端的设计也从Push模式改成Pull模式，这是为了方便接受者更好控制消息的接受和处理，中间件的设计如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mqorder.png?imageMogr2/thumbnail/!45p)</center>具体实现中，消息存储顺序的写入本地文件，但不存在文件空洞，因为消息是按顺序去消费的。接受端维护一个指针指向当前处理的消息，不同消费者维护各自的指针，并通过回溯指针重复消费消息，中间件更多关注消息的可靠性，消费者灵活控制消息的消费。<p>但当单机队列过多时，消息写入接近随机写入了，性能有明显的下降，改进思路是将消息进行顺序写入然后在每个队列上建立索引，每个队列索引是独立的，索引保存了存储数据的物理队列的位置，这样带来的好处有：（1）队列轻量化，每个队列数据量少；（2）磁盘访问串行化、避免磁盘竞争，不会导致IO等待增加<br>虽然消除了随机写但也带来了问题：（1）写是顺序写，但读确实随机读；（2）读消息时，先读逻辑队列在读物理队列增加了开销；（3）需要保证逻辑与物理队列一致，编程复杂<br>为了解决消息的可靠性，一般需要考虑消息的复制问题。一般有2种复制方案，同步和异步。<br>（1）将消息中间件变为Master/Slave节点，Slave订阅Master的消息，进行消息的备份，该复制是一个异步的操作，Slave可能存在消息丢失风险<br>（2）Master/Slave同步复制，Master收到消息也往Slave发送，收到Slave成功响应后返回成功给发送端，该方式更可靠<br>保证消息可靠后，也需要保证消息的扩容，在顺序情况下，扩容更加复杂。基本思路是发送端知道消息需要写入新的消息队列，消费者知道去新的队列获取消息。主要的关键点有：<br>（1）队列扩容有有一个标志，即使有新的消息过来也不再接受<br>（2）通知消息发送端新队列的位置<br>（3）消息接受端在消费消息时，队列上有新旧两个位置，旧队列接受完毕后，去新队列接受消息，完成新旧位置切换</p><h4 id="push和pull方式对比">Push和Pull方式对比</h4><p>消息中间件Push和Pull实现方式的对比如下：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mqpushpull.png?imageMogr2/thumbnail/!40p)</center><h2 id="软负载中心与集中配置管理">软负载中心与集中配置管理</h2><p>在服务框架中，我们利用服务注册查找中心来定位服务器的地址；同样在消息中间件中，消息发送端和接受端也需要感知中间件服务器；这些都需要软负载中心来实现。可以看出软负载中心的最基本功能：<br>（1）聚合地址：软负载中心聚合地址列表，供使用方使用<br>（2）生命周期感知：软负载中心需要能够对服务器的上下线自动感知，并更新服务地址数据</p><h3 id="软负载中心结构">软负载中心结构</h3><p>软负载中心主要包含服务端和客户端两部分。<br>服务端负责感知提供服务机器是否在线，聚合提供服务机器的信息并传给使用的应用；<br>客户端主要有2个功能：（1）作为服务提供者，把服务提供者的信息主动传给服务器，并且随着信息变化去更新数据通知服务器；（2）作为服务使用者，从服务器获取需要的数据并更新数据，并进行本地缓存，提高效率和性能。下图展示了软负载中心与应用的关系：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/loadbalance.png?imageMogr2/thumbnail/!40p)</center>可以看出，软负载中心内部主要有三部分重要数据：（1）聚合数据聚合后的地址信息列表，在软负载中心内部使用dataId来标识一个服务信息，同样的dataId支持分组（group）信息，则可以形成一个二维的结构，（dataId，group）可以定位到唯一的数据内容，在内部是一个key-value结构。（2）订阅关系对于需要数据的应用，需要把（dataId，group）信息告诉软负载中心，所以软负载中心维护了（dataId，group）到应用分组（consumerGroupId）列表的映射关系，一旦数据发生变化则通过映射关系找到通知的应用。（3）连接数据连接数据是指应用和软负载中心建立连接的管理，每一个应用都有一个groupId，连接数据使用这个groupId作为key来管理该连接，通过连接来传递数据。<h3 id="内容聚合功能">内容聚合功能</h3><p>内容聚合主要工作有2个：保证数据正确；高效聚合数据<br>（1）保证数据的正确性<br>内容聚合主要保证并发场景下的数据聚合正确性，可以使用ConcurrentHashMap来保证数据的正确性。另一方面也需要考虑机器短时间内上下线问题等异常场景，数据的修改变化主要有新增、更新、删除操作，这里尤其需要注意网络断开后删除数据与新增数据的先后关系，比如发布了数据后马上下线，这时如果先删除数据再增加数据肯定会导致错误，所以数据的顺序性需要仔细考虑。<br>（2）性能保证<br>在保证数据安全的前提下，更新操作的性能也是需要考虑。虽然ConcurrentHashMap有较好的性能，但是在大量修改数据情况下有大量的线程并发冲突，并不难保证较高的性能。所以可以考虑一个改进方案，我们可以把对同样的数据修改在同一个线程中处理，即对同样的（dataId，groupId）放在一个队列中，该队列是一个线程安全的容器，然后用同一个线程来从队列取数据进行更新操作，那么整体上一个线程处理同样的数据，减少了线程冲突提升了性能。</p><h3 id="服务上下线感知">服务上下线感知</h3><p>软负载中心判断服务器是否可用的方式主要有两种。<br>（1）客户端与服务端的连接感知<br>软负载中心与应用之间通过长连接保持通信，通过心跳来判断服务是否在线，但该方法有一定缺陷。当软负载中心负载很高时会产生误判，将服务下线，或者网络通信故障也会导致软负载中心误判。此时可以通过服务调用方服务提供者来进一步确认。<br>（2）通过地址和端口进行连接检查<br>该方式是一种补偿的方式，通过一个监控应用去连接服务器的地址和端口，进行进一步的确认，该方法同样也存在网络通信故障缺陷，还是需要应用调用发和应用提供方通信做进一步检查。</p><h3 id="软负载中心的数据分发设计">软负载中心的数据分发设计</h3><p>（1）数据分发与消息订阅的区别<br>数据分发目的是保证数据订阅者能够收到可用的服务地址列表，消息订阅是使得每一条消息都能被获取，二者区别主要有两条。<br>-消息中间件的消息订阅需要保证每一条消息都送到订阅者，软负载中心只需要保证最新的数据送到订阅者，并不需要保证每次的变化都让订阅者感知。<br>-订阅者集群的分组。消息中间件中所有集群共享消息，每一条消息都只需要被一台机器消费；软负载中心需要分发消息到所有的订阅者<br>（2）提升数据分发性能<br>-数据压缩：降低流量、节省带宽<br>-全量与增量：数据变化时，需要发送最新数据到订阅者。全量发送实现简单，效率低；增量实现复杂，效率高</p><h3 id="针对服务化特性的支持">针对服务化特性的支持</h3><p>（1）软负载分组<br>通过（dataId，group）唯一确定数据，使用group目的是把相同的dataId内容分开，相当于多了一个namepspace，可以应用于不同环境的隔离（测试，线上）以及分优先级的隔离<br>（2）上下线开关<br>机器的上下线，需要由软负载中心来控制，主要的目的有2个：<br>-优雅停止应用：直接停止服务会导致正在执行的任务失败，应当从服务列表去除机器，然后执行完当前的任务在停止应用<br>-应用排错：当服务出错时，可以把出错的机器下线，以免新的请求进来<br>（3）维护管理路由规则<br>路由规则需要由软负载中心来统一管理。</p><h3 id="软负载中心集群">软负载中心集群</h3><p>当应用规则不大时，利用单机加备份机器可以充当软负载中心，但随着应用集群规模扩大，单机的推送数据能力有限，需要一个集群来处理。从单机到集群也引入了新的变化，集群需要处理2类问题：数据管理问题和连接管理问题，解决方案也有数据统一管理方案和数据对等管理。<br>（1）数据统一管理<br>该方案把数据聚合放在一起，这样负责管理连接的机器可以是无状态的了，方案如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/datacenter.png?imageMogr2/thumbnail/!30p)</center>系统分为三层：聚合数据这一层负责管理数据；软负载中心负责管理连接，并且这层机器都是对等的。这里可以做一个改进，把软负载中心的职责分开，即把数据聚合和数据推送分开，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/datadepart.png?imageMogr2/thumbnail/!30p)</center>这样发布者和订阅者的连接是分开的，更精细能够提升性能，在负责推送的机器上也可以做缓存。但这两种方式都必须保证“聚合数据”这一点必须可用。（2）数据对等方案该方案将数据分散在各个软负载中心节点上，并相互之间进行数据复制和同步，如下图所示。但该方式同步开销太大，实现中可以间隔一定时间进行批量同步。<center>![img](http://oqcre1dsl.bkt.clouddn.com/datap2p.png?imageMogr2/thumbnail/!30p)</center>同样，也可以将软负载中心节点职责分开，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/datap2pd.png?imageMogr2/thumbnail/!30p)</center>数据聚合节点之间没有关系，数据分发节点之间也没有关系，但数据聚合节点会将数据分发给数据分发节点，这种方式可以提升效率。但如果数据量很大时，单个节点无法存储所有数据，则需要按照（dataId，group）进行分组管理，这样的话应用可能根据情况连接多个数据分发节点来获取需要的数据，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/datap2pf.png?imageMogr2/thumbnail/!35p)</center><h3 id="集中配置管理中心">集中配置管理中心</h3><p>软负载中心负责管理服务地址列表、路由规则、消息订阅关系等，这些数据可以按照是否持久以及是否需要聚合两个维度进行分类。其中持久是指数据本身与数据发布者的生命周期无关，如消息订阅、路由规则、数据库访问分库分表等，非持久则数据本身与发布数据者生命周期有关，如服务地址列表；聚合是指数据是否需要合并，如地址列表，订阅关系等需要合并。具体来说可以分为：持久/聚合、持久/非聚合、非持久/聚合、非持久/非聚合4类。<br>软负载中心用于管理非持久的数据，集中配置中心用于管理持久数据，它们都可以支持数据的聚合。集中配置管理比较关心数据的可靠性、稳定性，然后进一步考虑数据分发的性能。<br>集中配置管理的大致结构如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/centerconf.png?imageMogr2/thumbnail/!30p)</center>通过主备方式来保存持久数据，集中配置管理这一层由多个对等的节点构成，它们负责提供数据给应用也负责数据库的更新。在单个节点中，有Web应用和Nginx构成，Web应用主要负责相关的程序逻辑，单机文件（Local File）为了容灾和提升性能，客户端通过Nginx直接从本地文件获取数据。集中配置中心的主要提供的功能有2个：（1）提供客户端给应用：应用通过客户端来读取配置信息（2）为控制台提供SDK：SDK支持数据的读写，进行配置的修改下面我们具体看一下集中配置中心的容灾策略。<h4 id="客户端实现和容灾策略">客户端实现和容灾策略</h4><p>客户端通过HTTP协议与集中配置管理中心进行通信，考虑到服务端的压力，轮询间隔不能太短，但太长会影响数据的实时性。所以可以改进普通轮询，使用一种长轮询的方式，该方式特点如下：建立连接后，如有数据，长轮询与普通轮询直接返回，若没有数据，普通轮询直接返回，而长轮询会等待数据直到超时，然后重新建立连接。长轮询相对普通轮询实时行好，但是需要不断建立连接，这时相对Socket长连接的弱点，是在降低服务器负载下的一个折中方案。<br>对于容灾，客户端提供了4个特性：（1）数据缓存：缓存一方面提高了效率，另一方面在服务器不可用情况下也保证系统可用，但数据实时行不高；（2）数据快照：数据快照保存了最近的几次更新数据，比缓存的数据旧一些，但保存了最近的几个版本，可以在服务器和缓存均不可用时提供数据，也可以用于数据恢复。（3）本地配置：应用需要使用服务器给的配置工作，本地配置保存了这些配置，在服务器不可用时，本地配置优先级最高。（4）文件格式：在最坏情况下，系统退化为一个单机应用，需要直接修改配置数据，那么配置文件的格式十分重要了。</p><h4 id="服务端实现和容灾策略">服务端实现和容灾策略</h4><p>在集中配置管理中心中，Web应用中实现了主要的业务逻辑，Nginx用于请求的处理和结果的返回，供返回的数据都在本地文件系统中。通过Nginx直接返回本地文件中的数据比通过Web应用从数据库获取数据快很多，能够明显提升系统吞吐量；此外本地文件也可以用于数据库的容灾。<br>服务器端也需要考虑数据的同步问题，主要有2个方面：（1）当有数据更新时，通过SDK请求服务端更新数据库，并且同时更新本地文件，也要通知其他集群更新数据；（2）定时检查服务端数据是否与数据库数据一致，确保本地文件与数据库数据一致，也需要保证数据更新通知不能送达其他服务器时，服务器需要定时检查本地文件与数据库数据是否是一致的。</p><h4 id="数据库策略">数据库策略</h4><p>数据库一方面需要保证主备方式来达到容灾目，另一方面需要支持配置的版本管理，方便配置对比及配置回滚。</p><h2 id="大型网站其他要素">大型网站其他要素</h2><p>大型网站的发展中，虽然中间件起到了十分关键的作用，软负载中心和集中配置管理中心也起到了桥梁的作用，但还有一些其他的组件也至关重要，下面我们列举一些常见的组件。</p><h3 id="cdn">CDN</h3><p>CDN（Content Delivery Network）内容分发系统，CDN将用户需要的内容分发到离用户近的地方，这样可以使用用户能够就近获取所需要的内容，提升效率。CDN系统分为CDN源站和CDN节点，源点提供数据源头，节点一般部署在离用户比较近的地方，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/cdn.png?imageMogr2/thumbnail/!40p)</center>CDN本质是一种网络缓存技术，把一些先对稳定的资源放在离用户比较近的地方，节省带宽，提升网络速度，一般把静态文件（图片、视频、JS、页面框架）放在CDN中。下面我们看一下有无CDN的访问过程区别。无CDN时，浏览器访问网站过程如下：（1）用户向浏览器提交域名；（2）浏览器对域名进行解析，得到IP地址（3）浏览器向IP地址发送请求（4）浏览器获取返回数据，进行渲染加入CDN后，访问网站的过程发生了变化，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/cdnrequest.png?imageMogr2/thumbnail/!40p)</center>（1）用户提交访问域名（2）浏览器进行域名解析，CDN对域名解析进行调整，得到域名对应的CNAME记录（3）对CNAME再次进行解析，得到IP。这一过程使用全局负载均衡DNS解析，根据地址位置信息以及所在的ISP来返回结果，让不同地区不同接入商的用户得到最适合的CDN（4）得到IP发起请求（5）CDN根据请求内容是否在本地缓存进行不同处理：若在直接返回，否则CDN请求源站获取内容后返回可以看出CDN几个关键技术：（1）全局调度：这一步需要根据用户区域，接入运营商，以及CDN负载情况进行调度（2）缓存技术：CDN缓存需要保证有足够多数据，当没有命中的时候去源站获取数据可以进行合并批量操作来加快速度；此外缓存预加载也是一个提高命中率的办法（3）内容分发：对CDN的数据进行管理，数据的分发效率和一致性问题（4）带宽优化：CDN流量很大，节省带宽和数据压缩等<h3 id="存储支持">存储支持</h3><p>在大型网站中，存储系统是一个很重要的支撑系统，大型网站刚开始一般从关系型数据库开始，关系型数据库建立在key-value基础是那个，但仅仅使用关系型数据库并不能满足存储需求。</p><h4 id="分布式文件系统">分布式文件系统</h4><p>对于图片、文本的存储，使用关系型数据库就不再适合了，一般采用分布式文件系统。常见的分布式文件系统有Google的GFS以及Java版本的HDFS等，解决了单机文件系统存储及安全性问题，把多台机器组成一个分布式文件系统，提供文件系统服务。</p><h4 id="nosql">NoSQL</h4><p>处于分布式文件系统和关系型数据库之间的数据库系统都可以被称为NoSQL；NoSQL和SQL都是基于key-value发展而来，下面我们看一下常见的数据库系统。<br>（1）Key-Value<br>这是最基础的技术支撑，但不支持高效的范围查询<br>（2）Ordered-Key-Value<br>这是对Key-Value的一个改进，Key是有序的，可以解决范围查询效率问题。<br>（3）Big Table<br>Google的结构化数据的分布式存储系统，对Value进行了Schema支持，Value由多个Column Family组成，Column Family内部是Column。Hbase是对BigTable的一个开源实现。<br>（4）Document<br>Document数据库可以在Value中自定义复杂Scheme，不再是简单的Map嵌套，同时有支持索引和全文搜索。<br>（5）Graph<br>支持图结构的数据模型。</p><h4 id="缓存系统">缓存系统</h4><p>缓存系统是一种非持久的存储，为了加速对数据的读取。开源的缓存系统有Redis和Memcache，可以降低对底层数据库的读压力。但缓存系统需要注意缓存和数据库一致性的问题。<br>大型网站系统中缓存的另一种重要场景是对Web应用的页面渲染内容缓存，相对静态的内容可以进行缓存，不用每次进行渲染，具体实现技术有ESI等。</p><h3 id="搜索系统">搜索系统</h3><p>当网站规模较小时，一些查询可以依靠数据库的Like查询来实现，但这种查询效率较低，也不够智能，随着数据量的增大，需要使用搜索技术来解决查询问题。</p><h4 id="倒排索引">倒排索引</h4><p>倒排索引是搜索引擎中一项重要技术，倒排是相对于正向索引来说。正向索引的key为文章id，value为文章的单词，而倒排索引的key为单词，value为文章id，所以当需要搜索关键词时，倒排索引十分方便。但也要需要设计如何分词，即key的选取问题，需要根据设计需求合理设计。</p><h4 id="查询预处理">查询预处理</h4><p>预处理需要对用户输入的搜索内容进行分词，然后进行一些预处理包括同义词替换纠错等。</p><h4 id="相关度计算">相关度计算</h4><p>再经过查询分析处理后，搜索引擎会返回处理的结果，但同时也需要对搜索的结果进行排序，这里需要计算结果的相关度，相关度有向量空间模型、概率模型等。</p><h3 id="数据计算支撑">数据计算支撑</h3><p>再解决了数据的存储后，需要解决的问题是数据计算，从实时行角度来看，计算分为离线计算和实时计算。</p><h4 id="离线计算">离线计算</h4><p>离线计算是业务产生的数据离开生产环境后进行的计算。把数据从生产环境移动到离线存储中，然后进行数据处理的过程，实效性较差，延迟高。MapReduce是著名的离线计算模型，包含了map和reduce两个阶段，Hadoop是MapReduce的一个开源实现，利用了HDFS进行存储，而Spark则基于内存的集群计算，效率更高。</p><h4 id="在线计算">在线计算</h4><p>在线计算是一种实时的计算模型，比较常见的方式是流式计算，如Strom。</p><h3 id="发布系统">发布系统</h3><p>当完成应用的开发和测试后，需要对应用进行上线来提供服务。当需要管理的应用服务器很多时，如何保证发布过程不影响用户体验，如何支持灰度发布时就十分复杂了。发布应用时关键的几个要点如下。</p><h4 id="分发应用">分发应用</h4><p>我们首先需要高效地把程序包分发到线上机器中，这一过程如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/appdispatch.png?imageMogr2/thumbnail/!40p)</center>在多机房情况下，我们考虑在每个机房都部署发布服务器，由发布服务器负责本机房的程序包分发，发布控制台可以将程序包分发给任意一台发布服务器，由发布服务器之间相互分发，也可以将程序包分发给所有机房的发布服务器。另一方面，当应用服务器过多时候，可以采用P2P技术进行程序包的分发，加快分发速度。<h4 id="启动校验">启动校验</h4><p>当完成程序包的分发后，需要停止当前的应用程序并启动新的应用程序。新应用程序包启动后，需要进行校验，一般通过校验脚本来判断返回结果是否正确。<br>在停止应用时，若采取暴力的方式，会影响当时正在执行的请求服务，所以需要首先控制不让新的请求进来，在完成所有请求后再关闭应用。这里一般通过软负载均衡中心来完成，首先从软负载中心移除设备然后优雅关闭应用，当新的程序启动校验后，再把机器加入软负载中心，进而提供服务。在控制应用下线、重启、上线时，需要保证整个集群的可用机器数量，否则可能导致可用机器无法承受负载，所以操作的应用服务器比例一定是要支持可调的。</p><h4 id="灰度发布">灰度发布</h4><p>应用虽然进行了严格的测试，但为了保证万无一失，还是需要进行灰度发布，即对应用进行分批发布，逐步扩大新应用在整个集群的比例直到最后全部完成，并在灰度发布中记录关键数据、状态。</p><h3 id="应用监控">应用监控</h3><p>应用上线后，需要对应用的运行情况以及出现问题进行监视和控制。<br>（1）数据监视维度：系统数据（CPU、内存、IO等）和应用自身数据（调用次数、成功率、响应时间、异常数量）<br>（2）数据记录方式：进行监视的数据，需要考虑被采集数据的记录方式。系统自身数据记录到本地磁盘，应用数据记录在应用自身的目录中，也可以把应用日志通过网络发送到采用服务器情况，以此来减轻本地写日志压力，在写日志时可以批量写入，间隔一段时间统计。<br>（3）数据采集方式：监控中心获取集群中各个服务器的数据有二种方式。服务器自己推送数据到监控中心，需要考虑监控中心的负载能力；监控中心从服务器拉取数据。<br>（4）展现与告警：采用图表提供Web展示，根据告警条件和接受人进行告警，通过短信、手机APP来告警。除此之外，需要对应用进行监控，出现问题时可以通过重启应用解决，更精细化的做法可以进行降级。降级是指遇到大量请求且不能扩容时进行功能限制。</p><h3 id="依赖管理系统">依赖管理系统</h3><p>在大型的分布式系统中，系统中有各种各样的应用集群，这些集群和底层系统之间有相互的依赖关系，随着网站功能的增多，应用之间的关系也越来越复杂，理清这些依赖关系并进行管理十分重要。首先，我们需要知道应用在完成某个功能时依赖那些系统，也需要知道哪些是强依赖哪些是弱依赖。</p><p>依赖的检测有静态和动态两种方式。静态检测分析应用的代码调用情况获取依赖关系，但不能检测出依赖的强弱性；动态监测在运行阶段监测功能调用关系，并可以进行强弱依赖的检测。Google发表的论文Dapper中，通过一种更细粒度的方式检测应用依赖情况，应用调用时都会传递一个traceId，以此来构造应用调用链。</p><p>对于依赖的控制，主要通过白名单和黑名单机制完成，应用的识别通过IP和应用名完成，另外也可以通过密码的方式进行应用的鉴权。</p><h3 id="多机房问题">多机房问题</h3><p>多机房主要用于容灾，以及改进不同区域用户访问速度，有同城机房和异地机房。<br>同城的机房主要用于容灾，突破但机房集群规模限制。对于数据库系统，则会把主备放在不同的机房，当主数据库故障时，需要进行主备切换；此外在软负载中心也需要尽量避免跨机房调用。<br>异地机房比较难于处理，两地间通信延迟较高。首先把数据同步到异地机房，把一些数据延迟不敏感系统部署到异地，一般是一些只读的系统，这样便于异步的用户快速访问应用。最后将写应用也放在异地，这一步是最复杂的。</p><h3 id="系统容量规划">系统容量规划</h3><p>有了监控的依赖管理系统，能够及时发现问题并进行补救，但还需要知道系统的容量和水位。我们把系统的能够提供的并发能力和当前的压力分别称为容量和水位。知道各个系统的容量和水位是一件很重要的事情，希望通过扩容来支持更多的请求，而不是降级方案。</p><p>容量的测量是一个基础的工作，最终希望能够预测系统的容量增长曲线，以便规划服务器数量等来降低成本，当然预测准确十分困难，需要结合过去的增长规律和人为判断。当然也需要弄清楚以下几件事情：（1）系统的高峰期水位；（2）各个系统的容量；（3）设置警戒线，水位高于警戒线就增加容量。其中，系统水位通过监控系统得到数据，系统的容量需要通过测试来获取。首先需要保证依赖的服务系统不是瓶颈，测试时也需要贴近用户的真实请求，注意观察系统的响应时间。<br>对于提供服务的应用，通过负载均衡设备使得单台服务器承受更多的请求，注意处理时间的变化，一旦时间很长说明负载很大，我们通过单机容量来计算整个集群的容量，但这些是对于无状态服的测量，但对于数据库等有状态的服务，放大请求量是一个可行的方案，将一次读取重复多次，这适用于读操作；对于写操作不能单纯采用此方法，因为会引发脏数据，可以复制一份数据库，让测试走测试数据库，在请求中增加参数区分正常请求和测试请求，来达到使用不同的数据库的目的。<br>以上是对于集群的单个机器测试，而对于整个集群的全站压测是十分困难的。</p><h3 id="内部私有云">内部私有云</h3><p>内部私有云为大型系统的运维带来了很多便利，私有云要求我们的资源能够动态扩展，并在不需要动态收缩，判断扩容还是缩容与系统容量和水位有很大关系，这也涉及到人工智能的一些技术来实现智能化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大型系统的发展离不开中间件的支持，从大型网站系统的发展历程中，我们也看到了中间件发挥的重要作用。下面我们了解一下最常见的服务框架、数据访问中间件和消息中间件以及相关的软负载中心，学习它们的设计过程以及在大型系统中解决的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Architecture" scheme="https://lifeloner.github.io/categories/Architecture/"/>
    
    
      <category term="Distributed" scheme="https://lifeloner.github.io/tags/Distributed/"/>
    
      <category term="Midware" scheme="https://lifeloner.github.io/tags/Midware/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性协议</title>
    <link href="https://lifeloner.github.io/2017/09/10/consistency/"/>
    <id>https://lifeloner.github.io/2017/09/10/consistency/</id>
    <published>2017-09-10T01:10:00.000Z</published>
    <updated>2017-11-20T15:14:17.093Z</updated>
    
    <content type="html"><![CDATA[<p>随着计算机系统的规模变大，将所有的业务部署在一台机器上已经不能满足当今计算机系统了。微型机的出现及互联网的不断发展也促使了大量灵活多变的系统架构出现，尤其是分布式处理方式越来越受到工业界的青睐，计算机系统正在从集中式走向分布式架构。</p><a id="more"></a><h2 id="集中式到分布式">集中式到分布式</h2><p>由于大型机成本较高，也存在单点问题，无法满足互联网应用爆炸式的增长需求。<br>集中式的特点:（1）部署简单；（2）单点故障<br>分布式特点:（1）分布性 （2）对等性（节点没有主/从之分）（3）并发性（多个节点并发操作共享资源）（4）缺乏全局时钟（无法确定事件先后顺序） （5）故障总会发生<br>分布式环境的常见问题:（1）通信异常（延迟）（2）网络分区（脑裂：只有部分节点能正常通信，这些小集群完成整个系统才能完成的任务） （3）三态（成功、失败、超时）（4）节点故障</p><h2 id="分布式事务">分布式事务</h2><h3 id="acid">ACID</h3><p>事务是对系统中数据进行访问与更新操作组成的一个程序执行逻辑单元，事务具有4个特征：原子性，一致性，隔离性，持久性（ACID）。<br>原子性：事务必须是原子操作单元，各项操作要么全部执行成功，要么全部不执行；任何一项操作失败都会导致整个事务回滚，全部操作成功才意味着事务的成功完成。<br>一致性：事务的执行不能破坏系统的完整性和一致性，事务在执行前后系统都必须处于一致性状态，即事务执行使得系统从一个一致性状态转变到另一个一致性状态。若事务执行发生故障后，只有一部分操作修改写入数据库，那数据库就处于不一致性的状态。<br>隔离性：并发的事务是相互隔离的，一个事务不能被其他事务干扰，并发执行的事务又各自完整的数据空间，事务之间相互不干扰。SQL隔离性（未授权读、授权读、可重复读、串行化）<br>持久性：事务一旦提交，它的修改就应该是永久性的，即使系统崩溃后，重新修复也能恢复到事务提交成功后的状态</p><p>在单机上实现事务比较简单，但在分布式系统中，分布式事务由多个分布式操作序列组成，而实现分布式事务的ACID更为复杂（通信、多节点、宕机）。当追求分布式系统严格一致性时，系统的可用性会收到影响，即可用性和一致性永远无法存在一个两全齐美的方案，折中考虑出现了CAP和BASE分布式理论。</p><h3 id="cap">CAP</h3><p>CAP理论：分布式系统不可能同时满足一致性，可用性和分区容错性，这三个最多只能满足其中二项<br>一致性：数据在多个副本之间保持一致性（强一致性）（放弃C，放弃强一致性，保留最终一致性，时间窗口，最终达到一致性状态）<br>可用性：分布式系统提供的服务必须一致处于可用的状态，对每一个用户的请求总是在有限的时间内返回结果（有限时间、结果）（放弃A，在故障期间无法提供服务）<br>分区容错性：分布式系统在遇到任何网络分区故障时仍能对外提供一致性和可用性的服务，除非整个网络环境发生了故障 （放弃P意味着单机部署）</p><p>在分布式系统中，分区容错性是必须解决的问题，所以往往需要在可用性和一致性之间寻求平衡。</p><h3 id="base">BASE</h3><p>BASE理论：基本可用、软状态、最终一致性。BASE是对CAP一致性和可用性权衡的结果，其核心思想是分布式系统无法做到强一致性，每个应用可以根据自身业务特点来使系统达到最终一致性<br>基本可用：分布式系统在出现故障时，允许损失部分可用性（并不等价于不可用，如响应时间损失、服务降级）<br>弱状态：系统中允许存在中间状态，该状态不会影响系统的整体可用性，即允许存在一定的延迟<br>最终一致性：经过一段时间的同步后，系统最终能够达到一致性的状态，不需要实时保证一致性，是一种弱一致性<br>最终一致性的变种：因果一致性、读己之所写、回话一致性、单调读一致性、单调写一致性</p><h2 id="一致性协议">一致性协议</h2><p>在分布式系统进行架构设置时，往往在可用性与一致性之间反复权衡，于是就产生了一系列的分布式一致性协议，经典的一致性协议如下。</p><h3 id="2pc">2PC</h3><p>在分布式系统时，每一个节点都知道自己的事务是否成功，但是不知道其他节点的事务执行情况，因此为了保证事务的ACID，需要引入一个协调者来统一调度所有节点。协调者调度参与者的行为，并最终决定参与者是否把事务真正提交。基于这个思想出现了2PC、3PC协议。</p><p>2PC：二阶段提交，常用于数据库领域，绝大数的关系型数据库都采用了二阶段提交协议。2PC是一种一致性协议，被广泛应用于分布式系统中。<br>执行流程：<br>1.提交事务请求<br>（1）事务询问：协调者向参与者发送事务内容，咨询是否可以执行事务，等待参与者响应<br>（2）执行事务：参与者执行事务操作，并将undo与redo记录事务日志<br>（3）参与者反馈事务响应：若参与者成功执行事务则反馈yes给协调者，若执行失败则反馈no<br>2.执行事务提交<br>若协调者从参与者的反馈都是yes，则执行事务提交<br>（1）执行事务提交：向所有参与者发出commit请求<br>（2）事务提交：参与者接受commit请求，提交事务并释放资源<br>（3）反馈事务执行结果：参与者执行事务后，返回ack给协调者<br>（4）完成事务：协调者收到所有参与者的ack后，完成事务<br>3.中断事务<br>若任何一个参与者反馈了no，或者超时无响应，那么就会中断事务<br>（1）发送回滚请求：协调者发出rollback请求<br>（2）事务回滚：参与者收到rollback后，利用日志中的undo信息来回滚，并释放资源<br>（3）反馈结果：参与者回滚后向协调者发出ack消息<br>（4）中断事务：协调者收到所有参与者的ack后完成事务中断</p><p>二阶段提交将分布式事务执行分成投票和执行两个阶段，即先尝试后提交处理方式，因此它是一个强一致性的协议。</p><p>优缺点：<br>优点：实现简单<br>缺点：<br>（1）同步阻塞：参与事务的逻辑都处于阻塞状态，无法进行其他任何操作，影响分布式系统性能<br>（2）单点问题：协调者一旦出现问题，事务将会失败<br>（3）数据不一致：若协调者发送commit后挂掉，只有部分参与者收到了消息，则导致了数据不一致现象<br>（4）过于保守：任何一个节点的失败都导致了整个事务的失败</p><h3 id="3pc">3PC</h3><p>三阶段提交是对二阶段提交的改进，将二阶段的“提交事务请求”拆分成2个阶段，由CanCommit、PreCommit、DoCommit三个阶段组成的事务处理协议。<br>执行阶段：<br>1.CanCommit<br>（1）事务询问：协调者向所有参与者发送CanCommit请求，询问是否可以执行事务提交操作，等待响应<br>（2）参与者反馈询问：参与者收到请求后，若正常情况反馈yes，进入预备状态，否则又问题返回no<br>2.PreCommit<br>协调者根据参与者的反馈情况来决定是否可以进行事务的PreCommit操作<br>（1）执行事务提交<br>若协调者收到的都是yes，就会执行事务预提交<br>发送预提交请求：协调者PreCommit请求进入Prepared阶段<br>事务预提交：参与者收到PreCommit后执行事务操作，记录undo、redo到事务日志<br>反馈：参与者反馈ack给协调者<br>（2）中断事务:若任何一个参与者反馈了no或超市，协调者将会中断事务<br>发送中断请求：发送abort请求<br>中断事务：无论收到了abort还是等待协调者超时，参与者都将中断事务<br>3.DoCommit<br>（1）执行提交<br>发送提交请求:协调者收到所有的ack响应后，他将从预提交转变到提交状态，并发送DoCommit请求<br>事务提交：参与者收到DoCommit请求后，执行事务提交操作，释放资源<br>反馈：参与者提交事务后，返回ack;协调者收到ack后，完成事务<br>（2）中断事务：协调者收到任何一个no<br>发送中断请求：发送abort<br>事务回滚：参与者收到abort后利用undo来执行回滚操作，并释放资源<br>反馈：事务回滚后，向协调者反馈ack<br>中断事务：协调者收到ack后中断事务</p><p>在进入阶段三后，若协调者挂掉或者协调者与参与者通信故障，都导致DoCommit或abort请求无发送到，在超时后参与者都会提交事务</p><p>优缺点：<br>优点：降低了阻塞范围<br>缺点：第三阶段无法收到DoCommit请求后，参与者继续提交事务，引发数据不一致性</p><h3 id="paxos">Paxos</h3><p>Paxos是一种基于消息传递且具有高度容错性的一致性算法，它主要解决的问题是在发送各种异常的分布式系统中，快速正确地在集群内部达成一致。<br>在Paxos一致性算法中，有三种参与角色，分别为：Proposer、Acceptor、Learner；在具体的实现中，一个进程可能充当不止一种角色。参与者可以以任意的速度执行，可能会出错而停止也可能会重启，消息在传递过程中也可能会出现不可预知的延迟，也可能会重复或丢失。</p><p>Paxos被广泛应用于分布式系统中，如Google Chubby（分布式锁服务）以及Hypertable（分布式数据库）中，下面我们看看Paxos协议的工作过程。</p><h4 id="提案生成与选定">提案生成与选定</h4><p>提案的选定<br>一个提案必须被半数以上的Acceptor批准；<br>若提案[M,V]被批准，那么之后任何Proposer产生的编号比M高的提案，其Value值必须为V</p><p>Proposer提案生成算法<br>1.Proposer选择一个提案编号M，然后向某个Acceptor集合发出请求，并提出要求 （Prepare请求阶段）<br>（1）承诺不再批准编号小于M的提案<br>（2）若Acceptor已经批准过任何提案，那么就像Proposer反馈已经批准编号小于M的最大编号的提案的值<br>2.如果Proposer收到了半数以上的Acceptor响应结果，他可以产生编号为[M,V]的提案，其中V是所有响应中编号最大的提案Value值；当然若没有半数以上Acceptor批准提案，V值可以任意选取<br>3.确认提案后，Proposer将该提案再次发送个Acceptor集合（该集合并不一定是上次响应Prepare请求的集合，但任意两个半数以上集合肯定有公共的Acceptor），期望获得他们的批准</p><p>Acceptor批准提案<br>根据上述Prosposer提案生成流程，Acceptor会收到两种请求：Prepare与Accept<br>Prepare请求：Acceptor可以响应任何一个Prepare请求<br>Acceptor请求：在不违背现有承诺下，可以响应Acceptor请求<br>所以，Acceptor只要未响应过任何编号大于M的Prepare请求，他就可以接受这个编号M的提案；若已经对编号大于M的请求进行了响应，它可以忽略该编号为M的提案。因此每个Acceptor只需要记住它已经批准的最大编号以及已经做出Prepare请求响应的提案最大编号。</p><p>选取主Proposer<br>当然该算法还有一点问题，考虑一个特殊情况：若Proposer p1提出了编号为M1的提案，并完成了Propare阶段，此时Proposer p2提出了编号更大的M2提案，那么当p1进入阶段二时的Accept请求会被Acceptors忽略，如果p1再次生成新的更高编号M3，则p2第二阶段也失败，如此程序将陷入死循环。<br>为了解决该问题，Paxos通过选取主Proposer来解决死循环，只有主Proposer才能提出议案，所以只要主Proposer和过半Acceptor正常工作，主Proposer提出更高编号的议案最终会被批准。</p><h4 id="算法陈述">算法陈述</h4><p>阶段一<br>1.Proposer选择一个提案M，然后向Acceptor某个超过半数的集合发出Prepare请求<br>2.如果Acceptor收到编号为M的Prepare请求，且该编号大于它已经响应过的所有Prepare请求，那么它可以把已经批准过的最大编号提案反馈给Proposer，并承诺不再批转任何小于M的提案<br>阶段二<br>1.如果Proposer收到半数以上Acceptor对于发出编号为M的Prepare请求响应，它会生成一个[M,V]提案的Acceptor请求给Acceptor，V是收到的响应中编号最大的提案的值，若响应中没有提案，则V是任意值均可<br>2.若Acceptor收到提案为[M,V]的Accept请求，只要它会同意任何编号大于M的Prepare请求，他就可以批准该提案</p><h4 id="learner获取提案">Learner获取提案</h4><p>在提案选定后，Learner角色需要获取提案，获取的方式主要有三种。<br>1.一旦Acceptor批准了一个提案，就将该提案发给Learner（通信次数太多）<br>2.选定一个主Learner，将提案发给主Learner，由主Learner通知其他Learner（通信次数减少，主Learner单点问题）<br>3.选取一个主Learner集合（方案二的改进）</p><h2 id="zookeeper">ZooKeeper</h2><h3 id="zookeeper简介">ZooKeeper简介</h3><p>ZooKeeper是一个开源的分布式协调服务，它将分布式中复杂容易出错的一致性协议封装起来，以简单易用的接口为用户提供服务。分布式应用程序可以基于它实现许多功能，如数据发布与订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选取、分布式锁、分布式队列等。</p><p>特点：<br>（1）顺序一致性：统一客户端的事务请求，按照其顺序应用在ZooKeeper中<br>（2）原子性：所有事务请求处理结果在整个集群上是一致的，要么都成功要么都失败<br>（3）单一视图：客户端无论连接哪个ZooKeeper服务器，看到的数据模型都是一样的<br>（4）实时性：保证在一定时间段内，客户端能够读取到最新的数据状态<br>（5）可靠性：事务引起的状态变化会保存下来，直到下一个事务对其更改<br>设计目标：<br>（1）简单数据模型：共享的、树型结构名字空间来相互协调（树型结构是ZooKeeper内存的一个数据模型，由Znode数据节点构成，类似文件系统，Znode是层级关系）<br>（2）构建集群：集群由一组机器构成，每台都在内存中维护服务器状态，服务器间保持通信，只要超过一半机器工作正常，整个集群就能对外提供服务。<br>（3）顺序访问：对于客户端的每个请求，ZooKeeper都会生成一个全剧唯一的递增编号，这个编号反应了事务的先后顺序<br>（4）高性能：ZooKeeper将数据保存在内存中</p><h3 id="zookeeper中的基本概念">ZooKeeper中的基本概念</h3><p>1.集群角色<br>Leader、Follower、Observer三种角色。Observer不参与Leader选举和“过半写成功”策略，但它可以提升集群读性能<br>2.会话Session<br>客户端通过TCP长连接来连接ZooKeeper，在第一次建立连接后，session的生命周期也开始了。客户端通过心跳检测机制来保持回话有效，也能够接受服务器的Watch事件通知。当服务器压力太大或网络故障导致连接断开时，只要在sessionTimeout时间内重新连接上任意一台服务器，那么之前创建的会话依然有效。<br>3.数据节点Znode<br>ZooKeeper将数据保存在内存中，数据模型是一颗树（Znode Tree），由/分割的路径就是一个Znode，Znode保存数据内容及属性信息。Znode分为持久节点和临时节点，临时节点与客户端会话绑定，一旦会话失效，则临时节点会被删除。<br>4.版本<br>ZooKeeper为每个Znode维护一个Stat数据结构，记录了三个版本信息，version（Znode版本），cversion（Znode子节点版本），aversion（ACL版本）。<br>5.Watcher<br>Watcher事件监听器，允许客户端在节点上注册Watcher，并在特定事件触发时，将事件通知给感兴趣的客户端。该机制是ZooKeeper实现分布式协调服务的重要特性。<br>6.ACL<br>ACL策略用来进行权限控制，ZooKeeper定义了5种权限<br>（1）create：创建子节点<br>（2）read：读取节点数据和子节点列表<br>（3）write：更新节点数据<br>（4）delete：删除子节点<br>（5）admin：设置节点ACL</p><h3 id="zab协议介绍">ZAB协议介绍</h3><p>ZooKeeper并没有使用Paxos协议，而是使用了ZooKeeper Atomic Broadcast（原子消息广播算法）作为一致性的核心算法。ZAB不像Paxos是一种通用的分布式一致性算法，它是专门为ZooKeeper设计的崩溃可恢复的原子消息广播算法。基于该算法，ZooKeeper使用单一的的主进程来接受处理客户端的事务请求，使用ZAB协议将数据状态变更以事务Proposal形式广播到所有副本进程。所以这种主备模型保证了集群中只有一个主进程来处理请求，也保证了请求事务的顺序。</p><p>下面我们详细分析ZAB协议的具体内容，ZAB包括两种基本模式：崩溃恢复与消息广播。在服务框架刚启动或Leader挂掉后，ZAB协议进入恢复模式选举新的Leader，当选举完成并且有过半Follwers进行状态同步后，ZAB协议退出恢复模式进入消息广播模式。当一台新的服务器加入集群后，它将进入恢复模式，找到Leader进行数据同步然后参与广播模式。Leader服务器在接收到事务请求后进行事务广播协议，若其他服务器接收到事务请求将转发给Leader。当Leader崩溃或不再与半数以上服务器正常通信时，ZAB协议将从消息广播模式进入到崩溃恢复模式，所以Leader必须要有半数以上的服务器支持。</p><h4 id="消息广播">消息广播</h4><p>ZAB的消息原子广播协议类似一个二阶段提交过程，针对客户端的事务请求，Leader生成对应的事务Proposal然后发送给其余机器，在收集选票后执行事务提交。与二阶段提交不同之处在于，ZAB移除了中断模式，Followers可以反馈事务Proposal可以抛弃，只要有过半Followers反馈后就可以提交事务，这种简化的二阶段提升了效率也带来了数据不一致问题。ZAB使用崩溃恢复模式来解决。此外，消息广播使用了FIFO的TCP协议进行通信，保证了事务的顺序性。</p><p>Leader生成的Proposal事务消息都会有一个ID（ZXID），该事务ID用于保持事务之间的顺序，具体来说，Leader为每一个Follower分配一个单独的队列，将事务放入队列按照FIFO规则进行发送，得到半数以上Follwers反馈ACK后进行提交，同时也给Followers发送Commit消息。</p><h4 id="崩溃恢复">崩溃恢复</h4><p>当Leader崩溃后，ZAB需要选举出新的Leader，需要保证（1）已经在Leader上提交的事务最终被所有服务器提交（2）丢弃那些只在Leader上提出的事务<br>结合上述两种极端情况，ZAB需要保证提交已经被Leader提交的事务，丢弃已经被跳过的事务。所以ZAB保证新选取的Leader拥有集群中最大的事务ID（ZXID），该机器一定具有已经提交的提案。</p><p>在选举出新Leader后，ZAB还需要保证集群中过半服务器已经提交了所有事务Proposal，即数据同步。具体来说，Leader向每一个Follower的队列中发送未完成的事务Proposal，并在每一个事务后紧接着发送Commit消息表示该事务已提交，等Follower服务器将所有事务都同步过来后，Leader将它加入真正可用的Followers列表。</p><p>在特殊情况下，ZAB需要处理需要丢弃的事务。ZAB的事务编号ZXID是一个64位数字，其中低32位是自增的数字代表了Leader处理的事务顺序，高32位代表了Leader的周期epoch。没当选举出新的Leader时，都会从最大事务ZXID中取出epoch值并加1代表新的epoch值，然后将低位置0。基于该策略，当一个上一个Leader周期尚未提交事务Proposal机器加入时，它作为Follower与Leader同步时，Leader根据自己最大事务进行对比，然后让该Follower执行回退操作，回退到已经被半数以上机器提交的最新事务，因而保证丢弃了未提交的事务。</p><h3 id="深入理解zab">深入理解ZAB</h3><p>在大概了解ZAB协议的内容后，我们详细分析ZAB的算法流程。<br>ZAB协议主要包含了消息广播和崩溃恢复两个过程，进一步可以细分为三个阶段：发现，同步，广播。组成ZAB协议的每一个分布式进程会循环执行这三个阶段，这一循环过程称为主进程周期</p><h4 id="发现">发现</h4><p>发现就是Leader选举过程，其工作流程如下：<br>1.Follower将自己最后接受的事务epoch发给准Leader<br>2.接受来自过半Follower的epoch消息后，准Leader产生新的epoch值并发给这些Follower（新的epoch值为来自Follower中最大的值，然后加1）<br>3.Follower接受来自准Leader的新epoch值后，若大于当前的epoch则更新epoch并发送ack给准Leader，并将自己已执行的事务Proposal集合发给准Leader<br>4.准Leader接受ack后，会从中选择一个Follower的其事务集合初始化自身事务集合I（该Follower选取条件：ZXID最大，即epoch最大，若有epoch相同，则事务ID最大）</p><h4 id="同步">同步</h4><p>在同步阶段中，Leader和Follower进行事务消息同步，具体流程如下：<br>1.Leader将epoch和事务集合I发送给过半集合Follower<br>2.Follower接受消息后，对比epoch若不相同（还在上一轮），直接进入下一轮，不参与本轮的同步；若相同则执行I中事务并反馈给Leader<br>3.当Leader收到过半Follower反馈后，发送Commit消息，然后Follower提交事务</p><h4 id="广播">广播</h4><p>在数据同步后，Leader可以接受客户端的事务请求，并进行消息广播，具体流程如下：<br>1.Leader接受客户端事务请求，生成事务CXID，按顺序发送给Follower<br>2.Follower根据接受事务顺序，添加到事务集合，并反馈给Leader<br>3.收到过半Follower针对事务的ack消息后，Leader发送Commit消息，要求它们提交事务<br>4.Follower收到Commit消息后提交事务，此时上一个事务肯定已经提交了</p><p>下图展示了ZAB协议的工作过程的三个阶段：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/ZAB.png)</center><h4 id="运行分析">运行分析</h4><p>ZAB协议中，每一个进程处于以下三种状态之一：<br>-Looking：Leader选举<br>-Following：Follower与Leader同步<br>-Leading：Leader领导状态<br>进程刚启动时，都处于Looking状态，选举出Leader后，Follower切换到Following状态，Leader处于Leading状态。</p><h2 id="zab与paxos联系与区别">ZAB与Paxos联系与区别</h2><p>联系：<br>1.两者都存在Leader与Follower角色<br>2.Leader都会等待超过半数Follower反馈后在提交事务<br>3.两者协议都存在主进程周期说法，ZAB的epoch，Paxos的Ballot<br>区别：<br>Paxos在产生Leader后，进行两个阶段，分别为读阶段，写阶段。读阶段，主进程会和Follower通信，收集上一个主进程的提出议案，并把它提交；写阶段主进程提出自己的议案<br>ZAB增加一个同步阶段，同步前ZAB也有一个类似的读阶段称为发现阶段，然后同步阶段确保过半Follower提交了上一周期的所有事务Proposal，同步完成后同样执行写阶段，处理客户端请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着计算机系统的规模变大，将所有的业务部署在一台机器上已经不能满足当今计算机系统了。微型机的出现及互联网的不断发展也促使了大量灵活多变的系统架构出现，尤其是分布式处理方式越来越受到工业界的青睐，计算机系统正在从集中式走向分布式架构。&lt;/p&gt;
    
    </summary>
    
      <category term="Distributed System" scheme="https://lifeloner.github.io/categories/Distributed-System/"/>
    
    
      <category term="Distributed" scheme="https://lifeloner.github.io/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>大型网站架构概念</title>
    <link href="https://lifeloner.github.io/2017/08/10/distributed/"/>
    <id>https://lifeloner.github.io/2017/08/10/distributed/</id>
    <published>2017-08-10T08:20:30.000Z</published>
    <updated>2017-11-19T13:26:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>大型网站是一种常见的分布式系统，在理解大型网站架构前，首先需要对分布式相关基础有一定了解。关于大型网站的概念，一个很直观的想法是访问量很大，然而有些网站访问量很高但并不</p><a id="more"></a>能称为大型系统，如www.tao123.com，所以访问量并不是大型网站的充分条件。另一方面，海量量也是需要关注的另一个维度，一个大型系统也应该需要海量的数据才行，数据就是财富。因此，访问量和数据是量是大型网站的必要条机，二者缺一不可，此外系统业务本身和复杂度也是需要考虑的！<p>大型网站要支撑海量的数据和较高的并发量，那他一般是一个分布式的系统，往往需要集群来工作，下面我们先看看分布式系统的基础知识。</p><h2 id="初识分布式系统">初识分布式系统</h2><p>分布式系统定义很多，而这些定义的本质都几本相同，其中最主要的为：一组分布在网络上的计算机通过消息传递来相互通信协调工作，而对用户来看仿佛是单一的机器再提供服务。分布式系统的出现的主要原因也主要有以下几点：单机性能瓶颈（cpu，存储等），稳定性和可用性（单点故障）。</p><p>我们都知道，计算机基本组件由控制器，运算器，存储器，输入设备，输出设备五部分构成。相关的技术模式涉及多线程、多进程（代价大，涉及序列化与反序列化）模式，IO（BIO、NIO、AIO）模式。 相比传统的单机系统，分布式系统的控制器、运算器、存储器有着明显的变化。下面我们以控制器为主看看主要的的变化和区别：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/hardware.png?imageMogr2/thumbnail/!50p) ![img](http://oqcre1dsl.bkt.clouddn.com/lvs.png?imageMogr2/thumbnail/!50p)![img](http://oqcre1dsl.bkt.clouddn.com/%E5%90%8D%E7%A7%B0%E6%9C%8D%E5%8A%A1.png?imageMogr2/thumbnail/!50p)![img](http://oqcre1dsl.bkt.clouddn.com/%E8%A7%84%E5%88%99.png?imageMogr2/thumbnail/!50p)![img](http://oqcre1dsl.bkt.clouddn.com/master-slave.png?imageMogr2/thumbnail/!60p)</center>在分布式系统中为了使用负载均衡，常有以上5种方式，分别为：（1）硬件负载均衡（2）软件负载均衡（如LVS），该方式会存在流量增加和延迟二个不足。（3）名称服务：名称服务收集服务器地址，并提供服务器地址给请求方（4）规则服务器：只提供规则给请求方，而不提供服务器地址（5）master-salve：master节点来管理<p>分布式系统在带来优势同时，也存在相比单机系统更复杂的问题，主要的挑战和难点有：<br>（1）缺乏全局时钟：较难处理顺序执行问题<br>（2）故障独立性：分布式系统往往存在部门系统故障，如何处理局部故障而不影响全局业务需要考虑<br>（3）单点故障：若分布式系统中某个功能由单个节点完成，需要处理好备份和降低单点影响范围问题<br>（4）事物：分布式事务相对单机事物复杂的多，如何保证一致性十分困难，分布式协议理论CAP，BASE，2PC，3PC，raft，Paxos，ZAB等。</p><h2 id="大型系统的架构演进">大型系统的架构演进</h2><p>大型网站往往由小网站慢慢发展起来，这一过程中需要解决的问题也是构建大型网站和中间件的基础，我们先了解一下大型网站的发展过程。<br>（1）Java技术和单机系统：Java，Web，MVC，JSP，Spring，JDBC等技术<br>我们以交易系统业务为例，系统整体的结构图可以抽象为如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/singleJava.png?imageMogr2/thumbnail/!70p)</center>（2）数据库与应用服务分离随着服务器负载过大，我们可以将应用服务器与数据库服务器分离<center>![img](http://oqcre1dsl.bkt.clouddn.com/dbServer.png?imageMogr2/thumbnail/!70p)</center>（3）应用服务器集群化服务器负载仍然过大，这个时候可以利用服务集群解决单机性能不足问题。<center>![img](http://oqcre1dsl.bkt.clouddn.com/mulServer.png?imageMogr2/thumbnail/!70p)</center>然后该方式存在session失效问题，因为客户端往往通过http协议进行请求，http是无状态的协议，所以在第一次请求时会分配一个sessionId，下一次请求时浏览器带上这个sessionId，session存放在服务端，若在分布式情况下，并不能保证同一客户端每次请求落在同一台服务器上，所以会存在session失效问题，而分布式系统中解决session失效问题也有如下几种方式：1）Session Sticky该方案如下图所示，通过负载均衡设备让相同的session请求发送在同一服务器上。<center>![img](http://oqcre1dsl.bkt.clouddn.com/sticky.png?imageMogr2/thumbnail/!70p)</center>2）Session Replication该方案如下所示，服务器之间相互复制数据，保证session的共享，该方案也存在浪费带宽和存储的缺陷<center>![img](http://oqcre1dsl.bkt.clouddn.com/replication.png?imageMogr2/thumbnail/!70p)</center>3）Session集中存储该方案比较简单，如下图所示<center>![img](http://oqcre1dsl.bkt.clouddn.com/centerSession.png?imageMogr2/thumbnail/!60p)</center>4）cookie based该方案将session放入cookie中，从cookie中生成session，该方式也存在缺陷：cookie长度的限制，性能延迟影响，安全性等。<center>![img](http://oqcre1dsl.bkt.clouddn.com/cookie.png?imageMogr2/thumbnail/!60p)</center>以上方式中，（1）（3）是常用的方式。（4）数据库读写分离（读压力）<center>![img](http://oqcre1dsl.bkt.clouddn.com/readwrites.png?imageMogr2/thumbnail/!60p)</center>随着数据量和访问量的变大，尤其是多读少写的情况，所以可以增加一个数据库，只用来读数据。该方式如下图所示，也存在数据复制和数据源选择问题。首先数据在复制时存在延迟问题，即数据一致性问题，Mysql的Master-Slave模式，支持异步复制，也支持semi-sync复制方式。此外，对于数据源的选择，写操作和事物读肯定发生在主库中，一般读操作可以在从库，应用可根据需求合理选取数据源。（5）搜索引擎（读库）搜索引擎其实是一个读库，通过复制数据来建立索引，加快数据查询效率，索引的建立分为全量/增量，实时/非实时方式。<center>![img](http://oqcre1dsl.bkt.clouddn.com/search.png?imageMogr2/thumbnail/!55p)</center>（6）缓存缓存可以加速数据的访问，有数据缓存和页面缓存。数据缓存主要用于缓解数据库读压力，页面缓存主要缓存页面中经常访问的数据（热数据）！<center>![img](http://oqcre1dsl.bkt.clouddn.com/cachedb.png?imageMogr2/thumbnail/!60p)</center>（7）分布式数据库系统分布式文件系统、分布式key-value系统、分布式数据库系统<center>![img](http://oqcre1dsl.bkt.clouddn.com/dbdistribute.png?imageMogr2/thumbnail/!60p)</center>（8）数据库拆分当数据库数据过多，压力依然很大时，可以进行数据库拆分，主要有垂直拆分和水平拆分。垂直拆分是把不同的业务数据拆分到不同的数据库中，这样导致了一方面需要配置多个数据源，另一方面需要采用分布式事务保持数据一致性。<center>![img](http://oqcre1dsl.bkt.clouddn.com/cz.png?imageMogr2/thumbnail/!60p)</center>水平拆分是指单表的数据过大，数据读写速度太慢，需要将一个表拆成多个子表，这样就存在了sql路由问题，数据库id自增问题，数据表联合查询问题等。<center>![img](http://oqcre1dsl.bkt.clouddn.com/sp.png?imageMogr2/thumbnail/!60p)</center>（9）新挑战  1）业务拆分：根据功能将应用拆分多部分  <center>  ![img](http://oqcre1dsl.bkt.clouddn.com/gncf.png?imageMogr2/thumbnail/!60p)  </center>  2）服务化结构：分层，服务调用  <center>  ![img](http://oqcre1dsl.bkt.clouddn.com/fwh.png?imageMogr2/thumbnail/!60p)  </center>  3）中间件：异步和解耦  <center>  ![img](http://oqcre1dsl.bkt.clouddn.com/midware.png?imageMogr2/thumbnail/!60p)  </center>  中间件为软件应用提供了操作系统所提供服务之外的服务，中间件不是操作系统也不是应用，它起到了桥梁的作用，是处于“中间”位置的组件，让开发人员更好的专注自己的应用开发！常见的中间件主要有以下几种：    -远程过程调用和对象访问中间件：分布式应用下应用相互访问问题，也是应用服务化的基础    -消息中间件：应用之间消息传递、异步、解耦    -数据访问中间件：应用访问数据库的共性问题  Java中间件的基础知识：JVM、GC、JMM；并发（线程池、常用类库）；动态代理及反射，网络通信（BIO，NIO，AIO）<h2 id="总结">总结</h2><p>在列举了大型网站系统的发展过程后，我们总结一下相关的知识，用下图来展示了大型网站的相关技术。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/bigsystem.png?imageMogr2/thumbnail/!70p)</center>在将中间件放入系统中后，大型网站的系统结构如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/bigsysmidware.png?imageMogr2/thumbnail/!70p)</center>后面我们将分别学习服务框架、消息中间件及数据库中间件等基础知识！]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大型网站是一种常见的分布式系统，在理解大型网站架构前，首先需要对分布式相关基础有一定了解。关于大型网站的概念，一个很直观的想法是访问量很大，然而有些网站访问量很高但并不&lt;/p&gt;
    
    </summary>
    
      <category term="Architecture" scheme="https://lifeloner.github.io/categories/Architecture/"/>
    
    
      <category term="Distributed" scheme="https://lifeloner.github.io/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>Java IO浅析</title>
    <link href="https://lifeloner.github.io/2017/06/26/io/"/>
    <id>https://lifeloner.github.io/2017/06/26/io/</id>
    <published>2017-06-26T12:44:40.000Z</published>
    <updated>2017-11-19T08:37:06.377Z</updated>
    
    <content type="html"><![CDATA[<p>Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处理字符流和字节流的转换。</p><a id="more"></a><p>而Java IO按照阻塞/非阻塞，同步／异步又可以分为BIO，NIO，AIO，下面我们简单介绍下这几类IO。</p><h2 id="bio">BIO</h2><p>下图展示了Java BIO的体系结构，主要相关部分分为流式结构、非流式结构(file相关)、其他(socket等)：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/io.png)</center>字节流和字符流的常见类如下图所示，主要采用了装饰者及适配器设计模式：<center>![img](http://oqcre1dsl.bkt.clouddn.com/io_stream.png)</center>### 字符流字符流的基础抽象类是InputStream和OutputStream，下面简单看看它们的主要方法和具体实现类1.InputStream<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//方法是读取一个byte字节,但是返回的是int</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//一次性读取内容到缓冲字节数组</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//从stream中跳过long类型参数个位置</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//关闭stream方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> available() <span class="keyword">throws</span> IOExceptionpublic <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span>;<span class="comment">//返回stream中的可读字节数</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> mark(<span class="keyword">int</span> readlimit) <span class="comment">//用于标记stream的作用,readlimit表示调用mark最多可以读多少字节</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//这个方法和mark方法一起使用的，让stream回到mark的位置判断</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span></span>;<span class="comment">//stream是否可以调用mark方法和reset方法</span></div></pre></td></tr></table></figure><p>这里需要注意下：mark(int readlimit)的参数并不是说读取readlimit个字节标记位才失效，也和BufferedInputStream类的缓冲区大小有关。若BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效，即是取readlimit和BufferedInputStream类的缓冲区大小（BufferedInputStream bis=new BufferedInputStream(in,2)）两者中的最大值。<br>下面介绍一些常用的具体实现类吧：<br>1）.ByteArrayInputStream ：把内存中的一个缓冲区作为 InputStream 使用<br>2）.FileInputStream ：把一个文件作为 InputStream<br>3）. PipedInputStream：实现了pipe，主要在线程中使用，管道输入流是指一个通讯管道的接收端。一个线程通过管道输出流发送数据，另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。<br>4）.SequenceInputStream：把多个 InputStream 合并为一个 InputStream，使用Enumeration作为参数<br>5）.ObjectInputStream：用于操作Object的stream，这个在stream主要用在对象传输的过程中，其中牵涉到了序列化的知识<br>6）.FilterInputStream：是一个过滤的InputStream，有很多具体的子类<br>6.1）  BufferedInputStream:使用缓冲区的stream<br>6.2） DataInputStream:数字格式化的stream（readInt,readFloat,readDouble）</p><p>2.OutputStream</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">int</span> b) <span class="keyword">throws</span> IOException; <span class="comment">//写入一个字节</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[]) <span class="keyword">throws</span> IOException；<span class="comment">//写入一个byte数组到stream中</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> IOException；<span class="comment">//把byte数组中从offset开始处写入长度为len的数据</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> flush() <span class="keyword">throws</span> IOException；<span class="comment">//这个方法是用来刷新stream中的数据，让缓冲区中的数据强制的输出</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> close() <span class="keyword">throws</span> IOException；<span class="comment">//关闭流，这个是在操作完stream之后必须要调用的方法</span></div></pre></td></tr></table></figure><p>常见的具体实现类：<br>1）ByteArrayOutputStream： 把信息存入内存中的一个缓冲区中 . 该类实现一个以字节数组形式写入数据的输出流<br>2）FileOutputStream: 文件输出流是向 File 或 FileDescriptor 输出数据的一个输出流<br>3）PipedOutputStream: 管道输出流是指一个通讯管道的发送端。 一个线程通过管道输出流发送数据<br>4）ObjectOutputStream:输出Object对象的stream<br>5）BufferedOutputStream:带有缓冲区的stream<br>6）DataOutputStream:具有格式化的OutputStream<br>7）PrintStream:直接输出到控制台中：最熟悉的就是System.out是一个PrintStream</p><h3 id="字符流">字符流</h3><p>字符流的基础抽象类是Reader、Writer，下面看一下主要方法和具体实现类<br>Reader和InputStream的方法基本上一致，区别在于前者使用了char读取字符，而后者使用了byte读取字节<br>1）CharArrayReader：此类实现一个可用作字符输入流的字符缓冲区char[],与 ByteArrayInputStream 对应<br>2）PipedReader：与 PipedInputStream 对应</p><ol start="3"><li>BufferReader: 与BufferInputStream对应<br>4）StringReader：从字符串读取<br>5）InputStreamReader：将InputStream转化成Reader，从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。<br>6）FileReader：继承InputStreamReader<br>Writer和OutputStream的方法基本上一致：<br>1）CharArrayWriter： 与 ByteArrayOutputStream 对应<br>2）PipedWriter：与 PipedOutputStream 对应<br>3）StringWriter：输出到StringBuffer<br>4）BufferWriter: 与BufferOutputStream对应<br>5）OutputStreamWriter： 将Writer转化为OutputStream，根据指定的字符编码将多个字符转换为字节，是字符流到字节流的桥梁<br>6）FileWriter：继承OutputStreamWriter</li></ol><h3 id="字节流与字符流的选择tips">字节流与字符流的选择Tips</h3><p>1）按照输入输出   输入： Reader, InputStream 类型的子类；输出： Writer, OutputStream 类型的子类<br>2）按照数据格式  二进制格式（只要不能确定是纯文本的） : InputStream, OutputStream 及其所有带 Stream 结束的子类  ； 纯文本格式（含纯英文与汉字或其他编码方式）； Reader, Writer 及其所有带 Reader, Writer 的子类<br>3）是否需要缓冲 要缓冲： BufferedInputStream, BufferedOutputStream,( 字节流 ) BufferedReader, BufferedWriter( 字符流 )<br>4）按数据来源（去向）分类：<br>是文件： FileInputStream, FileOutputStream, ( 字节流 )FileReader, FileWriter( 字符 )<br>是 byte[] ： ByteArrayInputStream, ByteArrayOutputStream( 字节流 )<br>是 Char[]: CharArrayReader, CharArrayWriter( 字符流 )<br>是 String: StringReader, StringWriter( 字符流 )<br>网络数据流： InputStream, OutputStream,( 字节流 ) Reader, Writer( 字符流 )<br>5）其他特殊功能<br>从 Stream 到 Reader,Writer 的转换类： InputStreamReader, OutputStreamWriter<br>对象输入输出： ObjectInputStream, ObjectOutputStream<br>进程间通信： PipeInputStream, PipeOutputStream, PipeReader, PipeWriter<br>合并输入： SequenceInputStream<br>更特殊的需要： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</p><h3 id="java-io性能优化">Java IO性能优化</h3><p>IO的性能瓶颈主要分为：<br>1）错误的使用缓冲（buffer）<br>a)为内存IO类（In-memory IO class）添加缓冲(错误用法)：如ByteArrayInput/OutputStream，根本没有使用到IO<br>b)为已添加buffer的IO类再次添加buffer（错误用法）：多余的buffer只会引入更多的栈调用和垃圾创建<br>c)Buffer版的IO类和显式使用buffer（使用byte[]或char[]）间的关系（概念上的误解）:实际上显示使用数组使用buffer效率更高<br>Buffer版IO使用装饰者模式，效率较低; Buffer版IO方法有同步synchroized操作，同步导致效率低下<br>2）过度的同步保护<br>Java IO类存在很多同步方法，这样会导致效率低下</p><h2 id="nio">NIO</h2><p>Java NIO是指New IO，相对于传统的IO支持非阻塞模式（文件除外），而且NIO是基于Buffer的，性能相比BIO有较大的提升，NIO中有三个主要的概念:Buffer、Channel、Selector.<br>1.Buffer<br>Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。具体的缓存区有：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer，其中ByteBuffer支持堆外直接内存分配。<br>每一个Buffer也有几个关键的信息如：position、limit、capacity、mark等等标记位来代表buffer数据状态情况（具体参考JDK源码）。<br>2.Channel<br>NIO 对数据的读取和写入要通过Channel。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。Channel主要分两大类：SelectableChannel用户网络读写，FileChannel用于文件操作。<br>3.Selector<br>Selector是NIO的基础，它提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。一个Selector可以同时轮询多个Channel，JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p><p>NIO相对BIO实现上复杂很多，下面我们简单写一个聊天功能吧：<br>服务端代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/9/11.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> class NioServer &#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PORT = <span class="number">6060</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;<span class="keyword">String</span>&gt; userNames = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> initNioServer() &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//  主线程注册等待连接事件</span></div><div class="line">            selector = Selector.<span class="built_in">open</span>();</div><div class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.<span class="built_in">open</span>();</div><div class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</div><div class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"NIO Server initial...Waiting for connecting on port 6060!"</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="built_in">int</span> n = selector.select();</div><div class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    SelectionKey <span class="built_in">key</span> = iterator.next();</div><div class="line">                    iterator.remove();</div><div class="line">                    handleMessage(<span class="built_in">key</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 发送消息，发送到其他所有的通道</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendMessages(Selector selector, SelectionKey sk, <span class="keyword">String</span> content) &#123;</div><div class="line">        <span class="keyword">for</span> (SelectionKey <span class="built_in">key</span> : selector.keys()) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">key</span> == sk) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            Channel channel = <span class="built_in">key</span>.channel();</div><div class="line">            <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> SocketChannel) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    ((SocketChannel) channel).write(charset.encode(content));</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//select监听到事件返回，然后解析具体的SelectionKey，读/写/连接,分别处理</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(SelectionKey <span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>.isAcceptable()) &#123;</div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                SocketChannel socketChannel = ssc.accept();</div><div class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                socketChannel.register(selector, SelectionKey.OP_READ);</div><div class="line">                System.out.<span class="built_in">println</span>(<span class="string">"client:"</span> + socketChannel.getRemoteAddress() + <span class="string">" is connecting"</span>);</div><div class="line">                socketChannel.write(ByteBuffer.wrap(<span class="string">"welcome guys,please input your name!"</span>.getBytes()));</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isReadable()) &#123;</div><div class="line">            SocketChannel socketChannel = (SocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                socketChannel.read(buffer);</div><div class="line">                buffer.flip();</div><div class="line">                <span class="keyword">String</span> content = charset.decode(buffer).toString();</div><div class="line">                <span class="keyword">if</span> (content != <span class="keyword">null</span> &amp;&amp; content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">String</span>[] strings = content.<span class="built_in">split</span>(<span class="string">"_"</span>);</div><div class="line">                    <span class="keyword">if</span> (strings.length == <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (userNames.contains(strings[<span class="number">0</span>])) &#123;</div><div class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">"users already exists!"</span>.getBytes()));</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            userNames.<span class="built_in">add</span>(content);</div><div class="line">                            System.out.<span class="built_in">println</span>(content + <span class="string">", registered!"</span>);</div><div class="line">                            socketChannel.write(ByteBuffer.wrap((<span class="string">"welcome,"</span> + content).getBytes()));</div><div class="line">                            sendMessages(selector, <span class="built_in">key</span>, strings[<span class="number">0</span>] + <span class="string">",enter the char room!"</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sendMessages(selector, <span class="built_in">key</span>, content);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="built_in">key</span>.cancel();</div><div class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        socketChannel.close();</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</div><div class="line">                        e1.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioServer().initNioServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>客户端代码比较简单：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class NioClient &#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> PORT = <span class="number">6060</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> userName=<span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> init() &#123;</div><div class="line">        <span class="built_in">try</span> &#123;</div><div class="line">            selector = Selector.<span class="built_in">open</span>();</div><div class="line">            <span class="comment">//连接远程主机的IP和端口</span></div><div class="line">            SocketChannel sc = SocketChannel.<span class="built_in">open</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, PORT));</div><div class="line">            sc.configureBlocking(false);</div><div class="line">            sc.<span class="keyword">register</span>(selector, SelectionKey.OP_READ);</div><div class="line">            <span class="comment">//开辟一个新线程来读取从服务器端的数据</span></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientThread()).start();</div><div class="line">            <span class="comment">//在主线程中 从键盘读取数据输入到服务器端</span></div><div class="line">            Scanner scan = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">            <span class="built_in">while</span> (scan.hasNextLine()) &#123;</div><div class="line">                <span class="keyword">String</span> <span class="built_in">line</span> = scan.nextLine();</div><div class="line">                <span class="built_in">if</span>(userName.length()==<span class="number">0</span>)&#123;</div><div class="line">                    userName=<span class="built_in">line</span>;</div><div class="line">                    sc.<span class="built_in">write</span>(charset.encode(userName));</div><div class="line">                &#125;<span class="built_in">else</span> &#123;</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"Me: "</span>+<span class="built_in">line</span>);</div><div class="line">                    sc.<span class="built_in">write</span>(charset.encode(userName+<span class="string">"_"</span>+<span class="built_in">line</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新起一个线程接受服务器的数据</span></div><div class="line">    <span class="keyword">private</span> class ClientThread implements Runnable &#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</div><div class="line">            <span class="built_in">try</span> &#123;</div><div class="line">                <span class="built_in">while</span> (true) &#123;</div><div class="line">                    <span class="keyword">int</span> k = selector.select();</div><div class="line">                    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                    Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</div><div class="line">                    <span class="built_in">while</span> (iterator.hasNext()) &#123;</div><div class="line">                        SelectionKey sk = iterator.next();</div><div class="line">                        iterator.<span class="built_in">remove</span>();</div><div class="line">                        <span class="built_in">if</span> (sk.isReadable()) &#123;</div><div class="line">                            <span class="comment">//使用 NIO 读取 Channel中的数据</span></div><div class="line">                            SocketChannel sc = (SocketChannel) sk.channel();</div><div class="line">                            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">                            <span class="keyword">String</span> content = <span class="string">""</span>;</div><div class="line">                            <span class="built_in">while</span> (sc.<span class="built_in">read</span>(buff) &gt; <span class="number">0</span>) &#123;</div><div class="line">                                buff.flip();</div><div class="line">                                content += charset.decode(buff);</div><div class="line">                            &#125;</div><div class="line">                            <span class="built_in">if</span> (content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">String</span>[] strs = content.split(<span class="string">"_"</span>);</div><div class="line">                                <span class="built_in">if</span>(strs.length&gt;<span class="number">1</span>) &#123;</div><div class="line">                                    System.out.<span class="built_in">println</span>(strs[<span class="number">0</span>] + <span class="string">": "</span> + strs[<span class="number">1</span>]);</div><div class="line">                                &#125;<span class="built_in">else</span> &#123;</div><div class="line">                                    <span class="built_in">if</span>(content.equals(<span class="string">"users already exists!"</span>)) &#123;</div><div class="line">                                        System.out.<span class="built_in">println</span>(content);</div><div class="line">                                        userName = <span class="string">""</span>;</div><div class="line">                                    &#125;<span class="built_in">else</span> &#123;</div><div class="line">                                        System.out.<span class="built_in">println</span>(content);</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioClient().init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由此可以看出，NIO服务端利用了IO多路复用，相比BIO使用了更少的线程，资源利用率更高！<br>总结一下 BIO的优势：1）事件驱动模型，2）单线程处理多任务，避免了多线程等待，3）非阻塞I/O，I/O读写不再阻塞，而是返回0 4）IO多路复用大大提高了Java网络应用的可伸缩性和实用性<br>更多的NIO教程可以参考JDK源码。</p><h2 id="io模式对比">IO模式对比</h2><p>下面我们对比一下NIO与BIO的模式，然后再分析一下Java IO中的同步与异步、阻塞与非阻塞概念。</p><h3 id="bio-vs-nio">BIO VS NIO</h3><p>BIO模式中，服务端由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/bio.png)</center>BIO最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，当线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就down机，所以BIO主要的问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程来处理这条链路，无法满足高性能、高并发的场景。当然可以使用一个线程池来管理这写具体的数据处理，以此来达到线程服用，节省服务器资源，但是这种方法不能解决问题的根本，在大量线程处于等待情况下仍然不能很好利用资源。NIO模式的处理流程如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/nio.jpg)</center>可以看出NIO服务端由一个单独的线程来轮询等待事件到来，在没有事件时不会存在大量的线程阻塞，只有有事件时才会在新的线程中处理任务，因此不会造成大量线程阻塞，支持更高的并发，性能相比BIO有较大的提升。<h3 id="同步与阻塞">同步与阻塞</h3><p>首先解释下一下同步、异步概念以及阻塞、非阻塞概念。<br>首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO也分为二步，等待数据就绪以及数据拷贝（核心态内存到用户态内存）。所以可以看出，同步异步主要是应用程序和内核的交互方式，若应用读写直到IO完成那么就是同步的，若由操作系统完成IO读写放入缓冲区然后会调通知应用直接取数据那么就是异步的；同样阻塞和非阻塞区别在于在应用访问数据的时候，根据IO操作的就绪状态来采取的不同方式，是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。<br>下面我们结合下图看一下常见的几种模式：<br>阻塞IO:阻塞在recvfrom调用</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/io_sb.png)</center>非阻塞IO:反复轮询recvfrom<center>![img](http://oqcre1dsl.bkt.clouddn.com/io_sn.png)</center>IO多路复用:实质阻塞在select调用（select/poll,epoll轮询），数据准备好开始读取（核心态到用户态）<center>![img](http://oqcre1dsl.bkt.clouddn.com/io_sm.png)</center>异步IO：发起aio-read请求，等待数据准备好并拷贝到用户态缓存区（依赖OS），然后读取<center>![img](http://oqcre1dsl.bkt.clouddn.com/io_an.png)</center>在这里简单了解下多路复用的概念以及select／poll，epoll的区别：I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符（fd）就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间select的缺点：    1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大    2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（fd_set类似数组的结构需要遍历）    3）select支持的文件描述符数量太小了，默认是1024poll和select几本一致，区别在于其描述符FD定义不同,它使用的是pollfd；epoll是linux新出用于取代poll、select，处理上述三个问题时：    1）次注册新的事件到epoll句柄中时（epoll_ctl函数）会把所有的fd拷贝进内核，不会在epoll_wait的时候重复拷贝    2）epoll_ctl为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表,epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd(也有人说用了红黑树所以比数组快)    3）epoll没有最大FD这个限制<p>此外Java中BIO，NIO，AIO的模式区别：<br>BIO：同步阻塞方式，同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善<br>NIO：同步非阻塞方式，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，由多路复用器轮询到连接有IO请求时才启动一个线程进行处理，所以是非阻塞的。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，但是从内核读取数据到用户缓冲区需要应用程序自己完成，因此是同步的。<br>AIO：异步非阻塞，JDK1.7后出现，一个有效请求一个线程，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。常见的类有AsynchronousSocketChannel，AsynchronousServerSocketChannel，AsynchronousFileChannel，AsynchronousDatagramChannel<br>总结一下，BIO关注“我要读”，NIO关注&quot;我可以读了&quot;，在AIO模型关注的是“读完了”，此外NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。BIO，NIO，AIO也有不同的适用场景：<br>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<br>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<br>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h2 id="reactor与proactor">Reactor与Proactor</h2><p>Reactor与Proactor是两种常用的IO模式，其中Reactor是同步IO模式，被广泛应用于网络编程中，如Redis、Netty；而Proactor是一种异步IO模式，由于操作系统的原因，相关的开源产品也少；在这先里我们学习下其模型结构，重点对比下两者的异同点；<br>首先我们先看一下reactor的结构：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/reactor.jpeg)</center>Reactor包含如下角色：    1.Handle 句柄；用来标识socket连接或是打开文件；    2.Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）    3.Event Handler：事件处理接口    4.Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；其流程如下：    1.应用启动，将关注的事件handle注册到Reactor中；    2.调用Reactor，进入无限事件循环，等待注册的事件到来；    3.事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；<p>而Reactor也包含了常见三种类型：<br>1.精典Reactor模式</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/reactor_1.png)</center>可以看出Acceptor处理客户端连接请，Reactor将I/O事件发派给对应的Handler，由Handlers 执行非阻塞读/写及数据处理操作，这种模式下一个线程同时监控多个请求状态。2.多工作线程Reactor模式<center>![img](http://oqcre1dsl.bkt.clouddn.com/reactor_2.png)</center>经典Reactor模式中，尽管一个线程可同时监控多个请求（Channel），但是所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读/写操作也会阻塞对新连接请求的处理。因此可以引入多线程，可以使用线程池来并行处理多个读/写操作。3.多Reactor模式<center>![img](http://oqcre1dsl.bkt.clouddn.com/reactor_3.png)</center>多工作线程Reactor模式下，主线程也需要监听多种事件，当并发量过大时也会导致性能瓶颈，也存在单点故障问题，所以引出了多Reactor，即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读/写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟，并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel提交给不同的子Reactor处理，每一个子Reactor包含一个Selector实例，用来监听监听事件，并且监听在子Reactor所在的线程中，保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换；同样每一个子Reactor中创建了一个静态的线程池，循环处理数据读取和操作，相比单一的Reactor大大提升了效率。<p>Proactor的结构如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/proactor.jpeg)</center>主要包含了如下角色：    1.Handle 句柄；用来标识socket连接或是打开文件；    2.Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；    3.Asynchronous Operation：异步操作    4.Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用    5.Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；    6.Completion Handler：完成事件接口；一般是由回调函数组成的接口；    7.Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；其工作流程如下：    1.应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；    2.应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；    3.异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；    4.主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；## 总结Java IO中包含了BIO、NIO、AIO等多种模式，每一个模式有不同的特点和应用场景，这些都是IO的基础知识。此外有时间一定要学习一些开源的框架如Netty，它基于NIO，使用了Reactor模式，同时也要多了解一下AIO模式如Proactor（异步IO）等高性能的IO模式。]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处理字符流和字节流的转换。&lt;/p&gt;
    
    </summary>
    
      <category term="Basic" scheme="https://lifeloner.github.io/categories/Basic/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
      <category term="IO" scheme="https://lifeloner.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS</title>
    <link href="https://lifeloner.github.io/2017/06/10/AQS/"/>
    <id>https://lifeloner.github.io/2017/06/10/AQS/</id>
    <published>2017-06-10T12:44:40.000Z</published>
    <updated>2017-11-19T08:08:42.895Z</updated>
    
    <content type="html"><![CDATA[<p>并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。</p><a id="more"></a><center>![img](http://oqcre1dsl.bkt.clouddn.com/aqs.png?imageMogr2/thumbnail/!70p)</center>上图从下到上描述了Java并发的整个体系：首先是JVM的violate可见性读写以及操作系统CAS原子操作的支持，在这一基础上出现了基础并发框架AQS以及一些简单的原子变量类，最后对AQS进行扩展完善，出现了大量的并发容器、同步器、锁结构。<h2 id="aqs公共方法">AQS公共方法</h2><p>AQS提供了许多公用的方法来管理同步，并且也提供了一些抽象方法，子类通过继承AQS来实现它的抽象方法来管理同步状态，AQS提供的主要方法有：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">getState</span><span class="params">()</span></span>：返回同步状态的当前值；</div><div class="line"><span class="function"><span class="title">setState</span><span class="params">(int newState)</span></span>：设置当前同步状态；</div><div class="line"><span class="function"><span class="title">compareAndSetState</span><span class="params">(int expect, int update)</span></span>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</div><div class="line"><span class="function"><span class="title">tryAcquire</span><span class="params">(int arg)</span></span>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</div><div class="line"><span class="function"><span class="title">tryRelease</span><span class="params">(int arg)</span></span>：独占式释放同步状态；</div><div class="line"><span class="function"><span class="title">tryAcquireShared</span><span class="params">(int arg)</span></span>：共享式获取同步状态，返回值大于等于<span class="number">0</span>则表示获取成功，否则获取失败；</div><div class="line"><span class="function"><span class="title">tryReleaseShared</span><span class="params">(int arg)</span></span>：共享式释放同步状态；</div><div class="line"><span class="function"><span class="title">isHeldExclusively</span><span class="params">()</span></span>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</div><div class="line"><span class="function"><span class="title">acquire</span><span class="params">(int arg)</span></span>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</div><div class="line"><span class="function"><span class="title">acquireInterruptibly</span><span class="params">(int arg)</span></span>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</div><div class="line"><span class="function"><span class="title">tryAcquireNanos</span><span class="params">(int arg,long nanos)</span></span>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</div><div class="line"><span class="function"><span class="title">acquireShared</span><span class="params">(int arg)</span></span>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</div><div class="line"><span class="function"><span class="title">acquireSharedInterruptibly</span><span class="params">(int arg)</span></span>：共享式获取同步状态，响应中断；</div><div class="line"><span class="function"><span class="title">tryAcquireSharedNanos</span><span class="params">(int arg, long nanosTimeout)</span></span>：共享式获取同步状态，增加超时限制；</div><div class="line"><span class="function"><span class="title">release</span><span class="params">(int arg)</span></span>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</div><div class="line"><span class="function"><span class="title">releaseShared</span><span class="params">(int arg)</span></span>：共享式释放同步状态；</div></pre></td></tr></table></figure><h2 id="同步队列clh">同步队列CLH</h2><p>此外AQS内部维护着一个CLH同步队列，该队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。CLH结构如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/CLH.png)</center>在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 共享 *</span>/</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 独占 *</span>/</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">    <span class="comment">//后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> SIGNAL    = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CONDITION = <span class="number">-2</span>;</div><div class="line">    <span class="comment">//表示下一次共享式同步状态获取将会无条件地传播下去</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PROPAGATE = <span class="number">-3</span>;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 等待状态 *</span>/</span></span></div><div class="line">    volatile <span class="built_in">int</span> waitStatus;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 前驱节点 *</span>/</span></span></div><div class="line">    volatile Node prev;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 后继节点 *</span>/</span></span></div><div class="line">    volatile Node next;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 获取同步状态的线程 *</span>/</span></span></div><div class="line">    volatile Thread thread;</div><div class="line">    Node nextWaiter;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h2 id="同步状态的获取与释放">同步状态的获取与释放</h2><h3 id="独占式">独占式</h3><p>acquire方法为AQS提供的模板方法，该方法为独占式获取同步状态，该方法对中断不敏感，即由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法由子类去实现<br>addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部<br>acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过，其代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            // 自旋，直到满足下面条件</div><div class="line">            for (;;) &#123;</div><div class="line">                final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">                // 其前驱节点是头节点并且获取同步状态成功</div><div class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">                    p</span>.next = null; // help GC</div><div class="line">                    failed = <span class="literal">false</span>;</div><div class="line">                    return interrupted;</div><div class="line">                &#125;</div><div class="line">                // 获取同步失败，等待</div><div class="line">                if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line"><span class="title">                    parkAndCheckInterrupt</span>())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure><p>可以看出只有其前驱节点为头结点才能够尝试获取同步状态，原因在于1）FIFO队列2）头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点,acquire流程如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/acquire.png)</center>AQS提供了acquire独占式获取同步状态，但该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了acquireInterruptibly方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常InterruptedException：<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="comment">// 中断直接跑出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">            doAcquireInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> doAcquireInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 中断后抛出异常</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AQS也提供了超时处理，tryAcquireNanos，该方法为acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">            doAcquireNanos(arg, nanosTimeout);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> doAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="comment">//nanosTimeout &lt;= 0</span></div><div class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//超时时间</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">        <span class="comment">//新增Node节点</span></div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//自旋</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="comment">//获取同步状态成功</span></div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//重新计算需要休眠的时间</span></div><div class="line">                nanosTimeout = deadline - System.nanoTime();</div><div class="line">                <span class="comment">//已经超时，返回false</span></div><div class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//如果没有超时，则等待nanosTimeout纳秒，该线程会直接从LockSupport.parkNanos中返回</span></div><div class="line">                <span class="comment">//如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold</span></div><div class="line">                <span class="comment">//已经非常小了，非常短的时间等待无法做到十分精确直接自旋</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">                <span class="comment">//线程是否已经中断了，中断直接抛出异常</span></div><div class="line">                <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>tryAcquireNanos的流程如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/acquireNano.png)</center>独占式同步状态释放<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="comment">// 尝试释放，子类实现</span></div><div class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">            Node h = head;</div><div class="line">            <span class="comment">// 唤醒后继节点</span></div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">                unparkSuccessor(h);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="共享式同步状态获取与释放">共享式同步状态获取与释放</h3><p>AQS提供acquireShared方法共享式获取同步状态：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="comment">// tryAcquireShared由子类实现</span></div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">//获取失败，自旋获取同步状态</span></div><div class="line">            doAcquireShared(arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        /共享式节点</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    <span class="comment">//尝试获取同步</span></div><div class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="阻塞与唤醒">阻塞与唤醒</h2><p>在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞，其主要方法在acquireQueued</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line"><span class="title">                    parkAndCheckInterrupt</span>())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line"></div><div class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //前驱节点</div><div class="line">        int ws = pred.waitStatus;</div><div class="line">        //状态为signal，表示当前线程处于等待状态，直接放回<span class="literal">true</span></div><div class="line">        if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</div><div class="line">            return <span class="literal">true</span>;</div><div class="line">        //前驱节点状态 &gt; <span class="number">0</span> ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</div><div class="line">        if (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">            do &#123;</div><div class="line">                <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</div><div class="line">            &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">            pred.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">        &#125; </span></div><div class="line"><span class="title">        //前驱节点状态为Condition</span>、propagate</div><div class="line">        else &#123;</div><div class="line">            compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</div><div class="line">        &#125;</div><div class="line">        return <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 shouldParkAfterFailedAcquire，该算法的步骤如下：<br>1）如果当前线程的前驱节点状态为SINNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞<br>2）如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false<br>3）如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false<br>shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// LockSupport调用UNSAFE类park方法来挂起当前线程</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">        <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当线程释放同步状态后需要唤醒其后继节点：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">//当前节点状态</span></div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">        <span class="comment">//当前状态 &lt; 0 则设置为 0</span></div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">//当前节点的后继节点</span></div><div class="line">        Node s = node.next;</div><div class="line">        <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//从tail节点来找可用节点</span></div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//唤醒后继节点</span></div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可能会存在当前线程的后继节点为null，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，从tail尾节点开始，原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程</p><h2 id="reentrantlock">ReentrantLock</h2><p>ReentrantLock，可重入锁。它可以等同于synchronized的使用，但是ReentrantLock提供了比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率.<br>ReentrantLock实现了Lock接口，依赖内部类Sync类来管理同步状态，Sync继承了AQS，同时Sync有2个子类，分别支持公平锁和非公平锁NonfairSync与FairSync。下面我们看看Lock的常用方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    sync.<span class="keyword">lock</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ReentrantLock里面大部分的功能都是委托给Sync来实现的，同时Sync内部定义了lock()抽象方法由其子类去实现，默认实现了nonfairTryAcquire(int acquires)方法，可以看出它是非公平锁的默认实现方式。下面我们看非公平锁的lock()方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//尝试获取锁CAS</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">//获取失败，调用AQS的acquire(int arg)方法,acquire在AQS中定义，子类实现tryAcquire</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认非公平锁</span></div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">//当前线程</span></div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="comment">//state == 0,表示没有该锁处于空闲状态</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//获取锁成功，设置为当前线程所有</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//线程重入</span></div><div class="line">        <span class="comment">//判断锁持有的线程是否为当前线程，是则增加次数，可重入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>释放锁：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// release在AQS中定义，包括了tryRelease，unparkSuccessor2个主要操作</span></div><div class="line">        sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 子类实现tryRelease</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">//减掉releases</span></div><div class="line">        <span class="keyword">int</span> c = getState() - releases;</div><div class="line">        <span class="comment">//如果释放的不是持有锁的线程，抛出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//state == 0 表示已经释放完全了，其他线程可以获取同步状态了</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            free = <span class="keyword">true</span>;</div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        setState(c);</div><div class="line">        <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>公平锁的tryAcquire方法：其实只是多了一个hasQueuedPredecessors判断，即节点是否为头节点</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node t = tail;  <span class="comment">//尾节点</span></div><div class="line">        Node h = head;  <span class="comment">//头节点</span></div><div class="line">        Node s;</div><div class="line">        <span class="comment">//头节点 != 尾节点</span></div><div class="line">        <span class="comment">//同步队列第一个节点不为null</span></div><div class="line">        <span class="comment">//当前线程是同步队列第一个节点</span></div><div class="line">        <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我们继续分析一下Lock的阻塞和唤醒:Condition<br>实现等待/通知模式二种方式：1）Synchronized来控制同步，配合Object的wait()、notify()。2）Lock提供了条件Condition，其线程的等待、唤醒操作更加详细和灵活。下图是Condition与Object的监视器方法的对比</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/condition.jpg)</center>Condition提供了一系列的方法来对阻塞和唤醒线程：await() ：造成当前线程在接到信号或被中断之前一直处于等待状态。await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout – 消耗时间，如果返回值 <= 0="" ,则可以认定它已经超时了。="" awaituninterruptibly()="" ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。="" signal()：唤醒一个等待线程。该线程从等待方法返回前必须获得与condition相关的锁。="" signal()all：唤醒所有等待线程。能够从等待方法返回的线程必须获得与condition相关的锁。="" condition接口有一个实现类conditionobject，其位于aqs内部类：="" 每个condition对象都包含着一个fifo队列，该队列是condition对象通知="" 等待功能的关键。在队列中每一个节点都包含着一个线程引用，该线程就是在该condition对象上等待的线程,其中node和clh同步队列的node相同="" <figure="" class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</div><div class="line">        private static final long serialVersionUID = <span class="number">1173984872572414699</span>L;</div><div class="line">        /** First <span class="keyword">node</span> <span class="title">of</span> condition queue. */</div><div class="line">        private transient <span class="keyword">Node</span> <span class="title">firstWaiter</span>;</div><div class="line">        /** Last <span class="keyword">node</span> <span class="title">of</span> condition queue. */</div><div class="line">        private transient <span class="keyword">Node</span> <span class="title">lastWaiter</span>;</div><div class="line">&#125;</div></pre></td></tr></table><p>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列同时释放锁。当从await()方法返回时，当前线程一定是获取了Condition相关连的锁,awaitl流程：首先将当前线程新建一个节点同时加入到条件队列中，然后释放当前线程持有的同步状态。然后则是不断检测该节点代表的线程释放出现在CLH同步队列中（收到signal信号之后就会在AQS队列中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 当前线程中断</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="comment">//当前线程加入等待队列</span></div><div class="line">        Node node = addConditionWaiter();</div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        <span class="keyword">long</span> savedState = fullyRelease(node);</div><div class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待</span></div><div class="line"><span class="comment">         * 直到检测到此节点在同步队列上</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">            <span class="comment">//线程挂起</span></div><div class="line">            LockSupport.park(<span class="keyword">this</span>);</div><div class="line">            <span class="comment">//如果已经中断了，则退出</span></div><div class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//竞争同步状态</span></div><div class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">            interruptMode = REINTERRUPT;</div><div class="line">        <span class="comment">//清理下条件队列中的不是在等待条件的节点</span></div><div class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">            unlinkCancelledWaiters();</div><div class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">            reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>fullyRelease(Node node)，负责释放该线程持有的锁：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">long</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//节点状态--其实就是持有锁的数量</span></div><div class="line">            <span class="keyword">long</span> savedState = getState();</div><div class="line">            <span class="comment">//调用rlease释放锁</span></div><div class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> savedState;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                node.waitStatus = Node.CANCELLED;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>isOnSyncQueue(Node node)：如果一个节点同步队列上获取锁则返回true</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final boolean isOnSyncQueue(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //状态为Condition，获取前驱节点为null，返回<span class="literal">false</span></div><div class="line">        if (<span class="keyword">node</span>.<span class="title">waitStatus</span> == <span class="keyword">Node</span>.<span class="title">CONDITION</span> || <span class="keyword">node</span>.<span class="title">prev</span> == null)</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //后继节点不为null，肯定在CLH同步队列中，</div><div class="line">        if (<span class="keyword">node</span>.<span class="title">next</span> != null)</div><div class="line">            return <span class="literal">true</span>;</div><div class="line"></div><div class="line">        return findNodeFromTail(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure><p>通知唤醒：<br>调用Condition的signal()方法，将会唤醒在等待队列里的头节点，在唤醒节点前，会将节点移到CLH同步队列中</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public final void signal() &#123;</div><div class="line">        //检测当前线程是否为拥有锁的独</div><div class="line">        if (!isHeldExclusively())</div><div class="line">            throw new IllegalMonitorStateException();</div><div class="line">        //头节点，唤醒条件队列中的第一个节点</div><div class="line">        <span class="keyword">Node</span> <span class="title">first</span> = firstWaiter;</div><div class="line">        if (first != null)</div><div class="line">            doSignal(first);    //唤醒</div><div class="line">&#125;</div><div class="line">//doSignal(<span class="keyword">Node</span> <span class="title">first</span>)主要是做两件事：<span class="number">1</span>.修改头节点，<span class="number">2</span>.调用transferForSignal(<span class="keyword">Node</span> <span class="title">first</span>) 方法将节点移动到CLH同步队列中</div><div class="line">private void doSignal(<span class="keyword">Node</span> <span class="title">first</span>) &#123;</div><div class="line">        do &#123;</div><div class="line">            //修改头结点，完成旧头结点的移出工作</div><div class="line">            if ( (firstWaiter = first.nextWaiter) == null)</div><div class="line">                lastWaiter = null;</div><div class="line">            first.nextWaiter = null;</div><div class="line">        &#125; while (!transferForSignal(first) &amp;&amp;</div><div class="line">                (first = firstWaiter) != null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //将该节点从状态CONDITION改变为初始状态<span class="number">0</span>,</div><div class="line">        if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //将节点加入到CLH队列中去，返回的是CLH队列中<span class="keyword">node</span><span class="title">节点前面的一个节点</span></div><div class="line"><span class="title">        Node</span> p = enq(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">        int</span> ws = p.waitStatus;</div><div class="line">        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</div><div class="line">        if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</div><div class="line">            LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</div><div class="line">        return <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Condition总结：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是则尝试获取锁，否则一直挂起。当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒条件队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</p><h2 id="countdownlatch">CountDownLatch</h2><p>CountDownLatch功能：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待<br>CountDownlatch与CyclicBarrier区别：<br>1）CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待<br>2）CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier<br>CountDownLatch在实现上同样依赖内部类Sync，Sync继承AQS，CountDownLatch仅有一个int类型的构造函数</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374</span>L;</div><div class="line"></div><div class="line">        Sync(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">            setState(<span class="keyword">count</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">int</span> getCount() &#123;</div><div class="line">            <span class="keyword">return</span> getState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//释放同步状态</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过这个内部类Sync我们可以清楚地看到CountDownLatch是采用共享锁来实现的,下面我们看看它的核心方法await方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//AQS定义acquireSharedInterruptibly</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="comment">//tryAcquireShared见上面Sync类内部，若state不为0（countdown未减为0）则调用AQS的doAcquireSharedInterruptibly方法自旋等待同步状态</span></div></pre></td></tr></table></figure><p>countdown方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// releaseShared见上面Sync内部，若state为0直接返回fasle，若countdown减1后为0，则调用AQS的doReleaseShared唤醒，await继续执行</span></div></pre></td></tr></table></figure><h2 id="semaphore">Semaphore</h2><p>Semaphore的实现也是依赖Sync，包含公平锁（FairSync）和非公平锁（NonfairSync），继承内部类Sync，其中Sync继承AQS<br>Semaphore提供了两个构造函数：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建具有给定的许可数和非公平的公平设置的 Semaphore,默认非公平</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建具有给定的许可数和给定的公平设置的 Semaphore</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过acquire来获取信号量：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 共享的可中断</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS定义的 acquireSharedInterruptibly，依赖sync实现的tryAcquireShared</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="comment">//  公平的tryAcquireShared</span></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">//判断该线程是否位于CLH队列的列头</span></div><div class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            <span class="comment">//获取当前的信号量许可</span></div><div class="line">            <span class="keyword">int</span> available = getState();</div><div class="line"></div><div class="line">            <span class="comment">//设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span></div><div class="line">            <span class="keyword">int</span> remaining = available - acquires;</div><div class="line"></div><div class="line">            <span class="comment">//CAS设置信号量</span></div><div class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                <span class="keyword">return</span> remaining;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 非公平的tryAcquireShared方法，少了一个头节点的判断</span></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> available = getState();</div><div class="line">                <span class="keyword">int</span> remaining = available - acquires;</div><div class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                    <span class="keyword">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>信号量释放：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS的releaseShared，子类sync实现tryReleaseShared</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> current = getState();</div><div class="line">            <span class="comment">//信号量的许可数 = 当前信号许可数 + 待释放的信号许可数</span></div><div class="line">            <span class="keyword">int</span> next = current + releases;</div><div class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</div><div class="line">            <span class="comment">//设置可获取的信号许可数为next</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="cyclicbarrier">CyclicBarrier</h2><p>CyclicBarrier：允许一组线程互相等待，直到到达某个公共屏障点。在一组固定大小的线程的程序中，这些线程必须不时地互相等待，barrier 在释放等待线程后可以重用。<br>构造函数：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="comment">// barrier数量</span></div><div class="line">        <span class="keyword">this</span>.parties = parties;</div><div class="line">        <span class="keyword">this</span>.count = parties;</div><div class="line">        <span class="comment">// 最后到达公共屏障点执行的任务</span></div><div class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用lock和condition来管理同步状态</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</div></pre></td></tr></table></figure><p>最重要的wait方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;<span class="comment">//不超时等待</span></div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</div><div class="line">            <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">            TimeoutException &#123;</div><div class="line">        <span class="comment">//获取锁</span></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//分代</span></div><div class="line">            <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">            <span class="comment">//当前generation“已损坏”，抛出BrokenBarrierException异常</span></div><div class="line">            <span class="comment">//抛出该异常一般都是某个线程在等待某个处于“断开”状态的CyclicBarrie</span></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="comment">//当某个线程试图等待处于断开状态的 barrier 时，或者 barrier 进入断开状态而线程处于等待状态时，抛出该异常</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="comment">//如果线程中断，终止CyclicBarrier</span></div><div class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//进来一个线程 count - 1</span></div><div class="line">            <span class="keyword">int</span> index = --count;</div><div class="line">            <span class="comment">//count == 0 表示所有线程均已到位，触发Runnable任务</span></div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                    <span class="comment">//触发任务</span></div><div class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                        command.run();</div><div class="line">                    ranAction = <span class="keyword">true</span>;</div><div class="line">                    <span class="comment">//唤醒所有等待线程，并更新generation</span></div><div class="line">                    nextGeneration();</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 自旋直到所有线程到达，超时，broken，中断</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//如果不是超时等待，则调用Condition.await()方法等待</span></div><div class="line">                    <span class="keyword">if</span> (!timed)</div><div class="line">                        trip.await();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</div><div class="line">                        <span class="comment">//超时等待，调用Condition.awaitNanos()方法等待</span></div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        <span class="keyword">throw</span> ie;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                        <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (g.broken)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">                <span class="comment">//generation已经更新，返回index</span></div><div class="line">                <span class="keyword">if</span> (g != generation)</div><div class="line">                    <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">                <span class="comment">//“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</span></div><div class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//释放锁</span></div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>await处理流程：<br>如果该线程不是到达的最后一个线程，则他会一直处于等待状态，除非发生以下情况：<br>最后一个线程到达，即index == 0<br>超出了指定时间（超时等待）<br>其他的某个线程中断当前线程<br>其他的某个线程中断另一个等待的线程<br>其他的某个线程在等待barrier超时<br>其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态<br>此外，Generation描述着CyclicBarrier的更显换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。其中broken标识该当前CyclicBarrier是否已经处于损坏状态。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程,在breakBarrier()中除了将broken设置为true，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void <span class="keyword">breakBarrier() </span>&#123;</div><div class="line">        generation.<span class="keyword">broken </span>= true<span class="comment">;</span></div><div class="line">        <span class="built_in">count</span> = parties<span class="comment">;</span></div><div class="line">        trip.signalAll()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当所有线程都已经到达barrier处（index == 0），则会通过nextGeneration()进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置count，generation</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">        trip.signalAll();</div><div class="line">        count = parties;</div><div class="line">        generation = <span class="keyword">new</span> Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>AQS作为Java并发基础的框架提供获取状态，acquire，release等公共方法，子类通过实现具体的逻辑来达到不同的同步目的，此外Lock，CyclicBarrier，Semaphore，CountDownLatch作为最基础的同步类为其他同步类提供了基础。</p></=>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrent" scheme="https://lifeloner.github.io/categories/Concurrent/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
      <category term="Thread" scheme="https://lifeloner.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>B Tree</title>
    <link href="https://lifeloner.github.io/2017/05/21/btree/"/>
    <id>https://lifeloner.github.io/2017/05/21/btree/</id>
    <published>2017-05-21T12:48:59.000Z</published>
    <updated>2017-11-19T09:19:47.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！<br>在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低树的深度很重要，那么就需要采用多叉树结构！而B树使得树深度较低，所以查找效率较高！</p><a id="more"></a><h2 id="磁盘">磁盘</h2><p>磁盘作为外存储器，读取效率比内存慢很多，它的结构如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/disk.png)</center>磁盘有多个盘片组成，盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了，每个盘面有一个磁头，它可以从一个磁到移到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。读/写磁盘上某一指定数据需要下面3个步骤：(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。(2)  如上图11.3中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。访问某一具体信息，由3部分时间组成：● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一）因此一般旋转一圈大约0.0083s。● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts<p>##B-树</p><p>B-树是一种多路查找树，能极大降低树的深度，许多数据库系统都一般使用B树或者B树的各种变形结构。B-树的定义如下：<br>一颗m阶的b-树结构<br>1）若根结点不是叶子结点，则至少有2个孩子，最多含有m个孩子（m&gt;=2）（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）<br>2）除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子，最多含有m个孩子（其中ceil(x)是一个取上限的函数）；<br>3）所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)<br>4）每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki<br>b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)<br>c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1</p><p>一颗3阶B树示例如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/btree.png)</center>首先节点定义为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="comment">/*文件数*/</span> 关键字个数</div><div class="line">    <span class="keyword">int</span>  file_num;</div><div class="line">    <span class="comment">/*文件名(key)*/</span>  即 key</div><div class="line">    <span class="keyword">char</span> * file_name[max_file_num];</div><div class="line">    <span class="comment">/*指向子节点的指针*/</span>  孩子指针</div><div class="line">     BTNode * BTptr[max_file_num+<span class="number">1</span>];</div><div class="line">     <span class="comment">/*文件在硬盘中的存储位置*/</span>  实际数据磁盘地址</div><div class="line">     FILE_HARD_ADDR offset[max_file_num];</div><div class="line">&#125;BTNode;</div></pre></td></tr></table></figure><p>B树包含N个关键字时，最大深度为：h=log┌m/2┐((N+1)/2 )+1，每一个非叶子结点含有ceil（m／2）个孩子</p><h3 id="插入过程">插入过程</h3><pre><code>插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</code></pre><p>以一颗5阶B-树来展示插入过程：<br>插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S<br>（1）首先根节点空间充足，直接插入4个节点<br>（2）插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中<br>（3）插入E,K,Q时，不需要任何分裂操作<br>（4）插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中</p>   <center>   ![img](http://oqcre1dsl.bkt.clouddn.com/btree1.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree2.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree3.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree4.png)   </center>   （5）插入F,W,L,T不需要任何分裂操作   （6）插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中   （7）插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作   （8）当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中   <center>   ![img](http://oqcre1dsl.bkt.clouddn.com/btree5.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree6.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree7.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree8.png)   </center><h3 id="删除操作">删除操作</h3><p>找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况<br>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）（还记得第一节中关于B树的第5个特性中的c点么?： c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： （ceil(m / 2)-1）&lt;= n &lt;= m-1。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：2&lt;=n&lt;=4），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点。</p><p>下面看删除H,T,R,E过程：<br>（9）首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br>（10）删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作<br>（11）删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。</p> <center>   ![img](http://oqcre1dsl.bkt.clouddn.com/btree9.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree10.png)   ![img](http://oqcre1dsl.bkt.clouddn.com/btree11.png)  </center><p>（12）删除E， 删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点<br>然后发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于2=&lt;n&lt;=4，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。</p><center>  ![img](http://oqcre1dsl.bkt.clouddn.com/btree12.png)</center><p>在看一个删除操作：5阶B树，删除C<br>（a）先删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。<br>（b）这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质</p><center> ![img](http://oqcre1dsl.bkt.clouddn.com/btreea.png) ![img](http://oqcre1dsl.bkt.clouddn.com/btreeb.png) ![img](http://oqcre1dsl.bkt.clouddn.com/btreec.png)</center><h2 id="b-树">B+树</h2><p>特点:<br>(1）有n棵子树的结点中含有n-1 个关键字<br>(2）所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)<br>(3）所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br><center><br><img src="http://oqcre1dsl.bkt.clouddn.com/btree+.png" alt="img"><br></center></p><p>优点：<br>（1）B±tree的磁盘读写代价更低<br>B±tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br>（2）B±tree的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<br>（3）B+树支持范围查询<br>B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</p><h2 id="总结">总结</h2><p>B树：有序数组+平衡多叉树；<br>B+树：有序数组链表+平衡多叉树；<br>（1）对于单个查询，b树可能更早的返回数据，因为内节点也存储了数据信息，而b+树需要查到叶子结点，但是b+树节点需要更少的空间所以磁盘I／O会少一点，除此之外，b+树支持范围查询和扫描，所以更加方便！<br>（2）b树和b+树在内存中没有任何优势，不如AVL和红黑树，但是在磁盘降低了树的深度，其I／O次数明显减少，所以大大降低了查询时间，被广泛用于数据库索引（Mysql）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！&lt;br&gt;
在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低树的深度很重要，那么就需要采用多叉树结构！而B树使得树深度较低，所以查找效率较高！&lt;/p&gt;
    
    </summary>
    
      <category term="Basic" scheme="https://lifeloner.github.io/categories/Basic/"/>
    
    
      <category term="DataStructure" scheme="https://lifeloner.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>Clone</title>
    <link href="https://lifeloner.github.io/2017/05/21/clone/"/>
    <id>https://lifeloner.github.io/2017/05/21/clone/</id>
    <published>2017-05-21T12:06:49.000Z</published>
    <updated>2017-08-07T13:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>Clone是Object类下的一个方法，用于产生一个创建一个新的对象副本。clone主要分为深复制和浅复制，下面我们分别介绍clone如何工作，以及如何实现深复制和浅复制。</p><a id="more"></a><p>克隆对象<br>clone方法会返回原始对象的一个副本，一个良好的clone准则往往满足以下三个基本原则：<br>（1）a.clone()!=a  克隆对象与原对象在heap上是两个独立的对象<br>（2）a.clone().getClass()==a.getClass()    克隆的对象必须与原对象类型一致<br>（3）a.clone().equals(a)    两个对象要想等<br>这些并非强制要求，为了达到第三个目的，可能要重写equals方法。</p><p>clone工作过程<br>Object类提供了clone实现，它被声明为protect native，它的具体实现由本地代码完成，对象的复制通过super.clone()来完成。所以任何对象的复制最终通过一系列的调用到达Object的clone方法，它首先会检查当前类是否实现了Cloneable接口，如果没有实现则抛出CloneNotSupportted异常，该异常是一个受检异常。若该类实现了接口，则调用Object的clone方法创建一个拷贝给调用者。而这一过程通过创建一个新对象，然后将对象的各个域直接复制过来的，对于原始的类型和不可变类型这种方式没有任何问题，但对于可变的类型和引用类型，它们将指向相同的对象，所以在修改时容易相互影响。所以Object的clone是一种浅复制，必须覆盖clone方法来实现深复制。</p><h2 id="example：">Example：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> standard;</div><div class="line"><span class="comment">/** * Created by fuyang on 2017/5/15. */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] money;    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.money = money;       </div><div class="line">        <span class="keyword">this</span>.age = age;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMoney() &#123;</div><div class="line">        <span class="keyword">return</span> money;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.money[<span class="number">0</span>] = money;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(money.clone(),<span class="keyword">this</span>.age);</div><div class="line">    <span class="comment">//          return super.clone();    </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Student student=<span class="keyword">new</span> Student(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">100</span>&#125;,<span class="number">25</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Student cloneStu=(Student) student.clone();</div><div class="line">            System.out.println(cloneStu.getMoney()[<span class="number">0</span>]);</div><div class="line">            student.setMoney(<span class="number">200</span>);</div><div class="line">            System.out.println(student.getMoney()[<span class="number">0</span>]);</div><div class="line">            System.out.println(cloneStu.getMoney()[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果：</div><div class="line"><span class="number">100</span></div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">100</span></div><div class="line">改为  <span class="keyword">super</span>.clone();</div><div class="line">则：</div><div class="line"><span class="number">100</span></div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure><h2 id="tips：">Tips：</h2><ul><li>克隆方法用于创建对象的拷贝，为了使用clone方法，类必须实现java.lang.Cloneable接口重写protected方法clone，如果没有实现Clonebale接口会抛出CloneNotSupportedException</li><li>在克隆java对象的时候不会调用构造器</li><li>java提供一种叫浅拷贝（shallow copy）的默认方式实现clone，创建好对象的副本后然后通过赋值拷贝内容，意味着如果你的类包含可变对象，那么原始对象和克隆都将指向相同的内部对象，这是很危险的，因为发生在可变的字段上任何改变将反应到原始对象和副本对象上。为了避免这种情况，重写clone()方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;Clone是Object类下的一个方法，用于产生一个创建一个新的对象副本。clone主要分为深复制和浅复制，下面我们分别介绍clone如何工作，以及如何实现深复制和浅复制。&lt;/p&gt;
    
    </summary>
    
      <category term="Basic" scheme="https://lifeloner.github.io/categories/Basic/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://lifeloner.github.io/2017/05/20/avl/"/>
    <id>https://lifeloner.github.io/2017/05/20/avl/</id>
    <published>2017-05-20T12:39:02.000Z</published>
    <updated>2017-11-19T08:18:50.840Z</updated>
    
    <content type="html"><![CDATA[<p>定义：首先是BST，而且任何一个节点的左子树和右子树高度差不超过1</p><a id="more"></a><h2 id="avl定义：">AVL定义：</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AvlTree&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="type">AvlTreeNode</span> root;</div><div class="line">    public <span class="type">AvlTree</span>() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AvlTreeNode&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="type">T</span> key;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> int height;</div><div class="line">        <span class="keyword">private</span> <span class="type">AvlTreeNode</span>&lt;<span class="type">T</span>&gt; left;</div><div class="line">        <span class="keyword">private</span> <span class="type">AvlTreeNode</span>&lt;<span class="type">T</span>&gt; right;</div></pre></td></tr></table></figure><p>AVL树在插入和删除时会改变它的平衡结构，具体的不平衡情况如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/avl1.png)</center><ul><li>LL：节点左子树的左子树的高度高</li><li>LR：节点左子树的右子树的高度高</li><li>RL：节点右子树的左子树的高度高</li><li>RR：节点右子树的右子树的高度高</li></ul><h2 id="avl的旋转">AVL的旋转</h2><pre><code>为了保持平很需要进行旋转操作来保持平衡，4种不平衡情况具体的旋转操作情况如下：</code></pre><p>（1）LL与RR<br><img src="http://oqcre1dsl.bkt.clouddn.com/avl2.png?imageMogr2/thumbnail/!60p" alt="img"><br><img src="http://oqcre1dsl.bkt.clouddn.com/avl3.png?imageMogr2/thumbnail/!60p" alt="img"><br>LL旋转操作比较简单，只需要将不平衡的节点k2向右旋转，使得其左孩子k1成为“根”节点，然后k2成为其右孩子，k1的右子树称为k2的左子树，此时树已经平衡了，最后把k1和k2的高度进行更新<br>RR以此类似，只需要把k2向左旋转<br>LL旋转：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode leftLeftRotation(AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line"><span class="title">    AvlTreeNode</span> <span class="tag">&lt;T&gt;</span>left = <span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">    <span class="keyword">node</span>.<span class="title">left</span> = left.right;</div><div class="line">    left.right = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">    node</span>.height = Math.max(height(<span class="keyword">node</span>.<span class="title">left</span>), height(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    left.height = Math.max(<span class="keyword">node</span>.<span class="title">height</span>, height(left.left)) + <span class="number">1</span>;</div><div class="line">    return left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>RR旋转：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode rightRightRotation(AvlTreeNode<span class="tag">&lt;T&gt;</span> <span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line"><span class="title">    AvlTreeNode</span> <span class="tag">&lt;T&gt;</span>right = <span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">    <span class="keyword">node</span>.<span class="title">right</span> = right.left;</div><div class="line">    right.left = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">    node</span>.height = Math.max(height(<span class="keyword">node</span>.<span class="title">left</span>), height(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    right.height = Math.max(<span class="keyword">node</span>.<span class="title">height</span>, height(right.right)) + <span class="number">1</span>;</div><div class="line">    return right;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>（2）LR与RL</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/avl4.png) </center><center>![img](http://oqcre1dsl.bkt.clouddn.com/avl5.png)</center>LR的旋转稍微复杂一点，首先对不平衡节点k3的左孩子k1进行一次“RR”旋转，这样树变成了LL不平衡状态，再进行一次“LL”旋转即可达到平衡同样RL的旋转情况与之一一对应，先进行一次“LL”旋转然后进行一次“RR”旋转LR与RL旋转：<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode leftRightRotation(AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    node</span>.<span class="attr">left=</span>rightRightRotation(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">    return leftLeftRotation(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div><div class="line"><span class="title"></span></div><div class="line"><span class="title">public</span> AvlTreeNode rightLeftRotation(AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    node</span>.<span class="attr">right=</span>leftLeftRotation(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">    return rightRightRotation(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure><p>插入节点<br>插入过程和BST一样，但它会导致树不平衡，所以需要旋转来维持树的平衡：递归查询插入点，然后判断是否平衡，并根据不平衡类型做相应的旋转</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode insert(T key, AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    if</span>(<span class="keyword">node</span><span class="title">==null</span>)&#123;</div><div class="line">        <span class="keyword">node</span><span class="title">=new</span> AvlTreeNode(key);</div><div class="line">        return <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">    &#125;</span></div><div class="line"><span class="title">    if</span>(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)==<span class="number">0</span>)&#123;</div><div class="line">        throw new RuntimeException(<span class="string">"节点值重复了"</span>);</div><div class="line">    &#125;else if(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">left</span>=insert(key,<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        if(height(<span class="keyword">node</span>.<span class="title">left</span>)-height(<span class="keyword">node</span>.<span class="title">right</span>)&gt;<span class="number">1</span>)&#123;</div><div class="line">            if(<span class="keyword">node</span>.<span class="title">left</span>.key.compareTo(key)&gt;<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">node</span><span class="title">= leftLeftRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;else</span> &#123;</div><div class="line">                <span class="keyword">node</span><span class="title">= leftRightRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">    &#125;else</span> &#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">right</span>=insert(key,<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        if(height(<span class="keyword">node</span>.<span class="title">right</span>)-height(<span class="keyword">node</span>.<span class="title">left</span>)&gt;<span class="number">1</span>)&#123;</div><div class="line">            if(<span class="keyword">node</span>.<span class="title">right</span>.key.compareTo(key)<span class="tag">&lt;0)&#123;</span></div><div class="line"><span class="tag">                node=rightRightRotation(node);</span></div><div class="line"><span class="tag">            &#125;else &#123;</span></div><div class="line"><span class="tag">                node=rightLeftRotation(node);</span></div><div class="line"><span class="tag">            &#125;</span></div><div class="line"><span class="tag">        &#125;</span></div><div class="line"><span class="tag">    &#125;</span></div><div class="line"><span class="tag">    node.height=Math.max(height(node.left),height(node.right))+1;</span></div><div class="line"><span class="tag">    return node;</span></div><div class="line"><span class="tag">&#125;</span></div></pre></td></tr></table></figure><p>删除过程<br>删除过程首先定位到删除的节点，找出最“接近”（左子树高则选择左子树最大节点，然后处理左子树使其平衡，然后递归向上判断平衡；同样对于右子树高的情况，先找出右子树最小的节点来替代当前点，然后处理右子树使其平衡，最后递归向上使其平衡）的节点来替换它，最后处理子树平衡再向上递归处理不平衡<br>代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode remove(T key,AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    if</span>(<span class="keyword">node</span><span class="title">==null</span>||<span class="attr">key=</span>=null)&#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    if(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">left</span>=remove(key,<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        if(height(<span class="keyword">node</span>.<span class="title">right</span>)-height(<span class="keyword">node</span>.<span class="title">left</span>)&gt;<span class="number">1</span>)&#123;</div><div class="line">            if(height(<span class="keyword">node</span>.<span class="title">right</span>.left)&gt;height(<span class="keyword">node</span>.<span class="title">right</span>.right))&#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=rightLeftRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;else</span> &#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=rightRightRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">    &#125;else</span> if(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)<span class="tag">&lt;0)&#123;</span></div><div class="line"><span class="tag">        node.right=remove(key,node.right);</span></div><div class="line"><span class="tag">        if(height(node.left)-height(node.right)&gt;</span><span class="number">1</span>)&#123;</div><div class="line">            if(height(<span class="keyword">node</span>.<span class="title">left</span>.left)&gt;=height(<span class="keyword">node</span>.<span class="title">left</span>.right))&#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=leftLeftRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;else</span> &#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=leftRightRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">    &#125;else</span>&#123;</div><div class="line">        if(<span class="keyword">node</span>.<span class="title">left</span>==null)&#123;</div><div class="line">            AvlTreeNode <span class="attr">tmp=</span><span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">            node</span>=<span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">            tmp.<span class="attr">right=</span>null;</div><div class="line">        &#125;</div><div class="line">        else if(<span class="keyword">node</span>.<span class="title">right</span>==null)&#123;</div><div class="line">            AvlTreeNode <span class="attr">tmp=</span><span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">            node</span>=<span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">            tmp.<span class="attr">left=</span>null;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            if(height(<span class="keyword">node</span>.<span class="title">left</span>)&gt;height(<span class="keyword">node</span>.<span class="title">right</span>))&#123;</div><div class="line">                AvlTreeNode<span class="tag">&lt;T&gt;</span> <span class="attr">tmp=</span><span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">                while(tmp.right!=null)&#123;</div><div class="line">                    <span class="attr">tmp=</span>tmp.right;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">node</span>.<span class="title">key</span>=tmp.key;</div><div class="line">                <span class="keyword">node</span>.<span class="title">left</span>=remove(tmp.key,<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">            &#125;else&#123;</div><div class="line">                AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="attr">tmp=</span><span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">                while(tmp.left!=null)&#123;</div><div class="line">                    <span class="attr">tmp=</span>tmp.left;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">node</span>.<span class="title">key</span>=tmp.key;</div><div class="line">                <span class="keyword">node</span>.<span class="title">right</span>=remove(tmp.key,<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(<span class="keyword">node</span><span class="title">!=null</span>) &#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">height</span> = Math.max(height(<span class="keyword">node</span>.<span class="title">left</span>), height(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    return <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>AVL插入删除过程需要处理平衡，删除过程较复杂。所以效率比BST低，但是查询操作稳定为O(lgn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：首先是BST，而且任何一个节点的左子树和右子树高度差不超过1&lt;/p&gt;
    
    </summary>
    
      <category term="Basic" scheme="https://lifeloner.github.io/categories/Basic/"/>
    
    
      <category term="DataStructure" scheme="https://lifeloner.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="https://lifeloner.github.io/2017/01/21/design/"/>
    <id>https://lifeloner.github.io/2017/01/21/design/</id>
    <published>2017-01-21T12:01:51.000Z</published>
    <updated>2017-11-19T08:49:22.762Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式程序员写出优雅、结构优雅代码的必备基础，以下是研发中常见的一些设计模式！</p><a id="more"></a><h2 id="适配器与外观模式">适配器与外观模式</h2><p>适配器模式定义：将一个类的接口转化成客户期望的另一个接口，使得原本接口不兼容的类可以合作。</p><p>适配器使用过程：<br>（1）客户通过调用适配器的方法对适配器发出请求<br>（2）适配器使用被适配者接口把请求转化成被适配者的一个或多个调用接口<br>（3）客户接受调用的结果，并未察觉这是适配器起转换作用</p><p>适配器可以适配多个类，同时若一个系统存在新接口的同时也存在旧的接口，并且新旧接口都在使用，那么适配器可以同时实现2个接口，则适配器既可以当新的接口也可以当旧的接口使用。适配器结构图如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/adapter.png?imageMogr2/thumbnail/!40p)</center>适配器模式分为对象适配器和类适配器2种模式：对象适配器使用了组合的方式，委托给被调用者来实现，同时对象适配器可以适配类的所有子类；类适配器使用了多继承的方式，适配器继承了适配者和被适配者，所以它不需要实现被适配者，必要时候也可以覆盖被适配者的行为，但在java中不支持多继承！<p>适配器 VS 装饰者 VS 外观模式<br>装饰者 ：与责任相关，不改变原有的接口，加入新的责任和功能，可以包装多次<br>适配器 ：将接口转化为另一种接口，无需改变原有的代码<br>外观 ：让接口更简单，对子系统进行了封装</p><h2 id="外观模式">外观模式</h2><p>外观模式定义：提供了一个统一的接口，用来访问子系统的一群接口。<br>外观定义了一个高层接口，让子系统更容易使用而不会修改它，当然你也可以直接使用子系统。外观模式使得客户实现从子系统中解耦，当以后系统升级改变时，只需要修改外观代码而不用修改客户代码。其中重要的一点是：适配器和外观模式都可以使用多个类，差别在于适配器改变原有的接口来满足需求，而外观模式简化了接口来访问子系统。</p><p>最小知识原则：只和你的密友谈话，注意和你交互的类有哪些，不要将过多的类耦合在一起。<br>要求：对于一个对象，最好应该只调用以下范围的方法<br>（1）该对象本身<br>（2）作为方法的参数传递进来的对象<br>（3）对象的任何组件<br>（4）方法内创建和实例化的对象</p><h2 id="装饰者模式">装饰者模式</h2><p>解决的问题：开放-关闭原则（类应该对扩展开放，对修改关闭）<br>装饰者模式定义：动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案<br>装饰者模式意味着一群装饰者类，这些类用来包装具体组件，装饰者反映出被装饰组件的类型，事实上他们具有相同的类型（实现统一接口或集成同一超类），同时装饰者可以在被装饰者行为前后加上自己的行为来达到特定的目的，装饰者一般对组件的客户是透明的，具体的结构如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/decorate1.png?imageMogr2/thumbnail/!40p)</center>其中Compoment是基本组件，ConcreteComponent是具体需要装饰的对象，Decorator是装饰者抽象类，ConcrereDecoratorA／B是具体的装饰者类，用来包装ConcreteComponent，他们都继承与Component。<p>以星巴克咖啡为例：有多种饮料和调料，如何来描述和计算价格，若采用继承机构将会出现大量的类并且难于维护（计算价格特别麻烦），采用装饰者模式的结构如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/decorate2.png?imageMogr2/thumbnail/!40p)</center>同时jdk中的IO也是典型的装饰者模式，如下图所示：<center>![img](http://oqcre1dsl.bkt.clouddn.com/decorate3.png?imageMogr2/thumbnail/!40p)</center>装饰者模式缺点：虽然比继承更容易扩展，但是会导致设计中出现许多的小对象，如果过度使用会让程序较为复杂，难于理解。<h2 id="工厂模式">工厂模式</h2><p>工厂模式定义：<br>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。即工厂方法让类把实例化推迟到子类。<br>另一种看法：工厂方法将生产知识封装进各个创建者，创建者和产品是一种平行的类层级，以生产pizza为例，层次结构如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/factory1.png?imageMogr2/thumbnail/!40p)</center>抽象工厂模式定义：    提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定类。该模式使得客户不需要知道具体的产品是什么，客户从具体的产品中被解耦。以pizza为例：如下图所示<center>![img](http://oqcre1dsl.bkt.clouddn.com/factory2.png?imageMogr2/thumbnail/!40p)</center>工厂模式 vs 抽象工厂模式工厂模式：利用继承方式，通过子类来实例化具体的产品抽象工厂模式：利用组合方式，创建一个创建产品的抽象类，该类型子类定义了产品被产生的方法，然后实例化该工厂来产生具体的产品<h2 id="观察者模式">观察者模式</h2><p>OO原则<br>（1）封装变化<br>（2）多用组合（几个对象协同工作），少用继承<br>（3）针对接口编程，不针对实现编程<br>（4）为交互对象之间的松耦合设计不断努力</p><p>观察者模式定义<br>定义对象之间的一对多耦合，这样以来，当一个对象的状态变化时，它的所有依赖者都能收到通知并自动更新<br>该模式主要包含2部分：主题Subject、观察者Observer，主题负责提供对象的状态，增加删除观察者，并把对象的变化状态通知给观察者，具体的模式信息如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/observer1.png?imageMogr2/thumbnail/!40p)![img](http://oqcre1dsl.bkt.clouddn.com/observer2.png?imageMogr2/thumbnail/!40p)</center>以气象发布战为力例子，模式设计图如上所示：weatherData实现Subject接口，实现register、remove（list持有对观察者的引用）、notify（调用所有观察者update方法通知他们）三个主要方法，CurrentCondition实现Observer借口实现update方法。jdk中java.util.Observable java.util.Observer分别充当了主题和观察者角色，所以在实现该模式时无需自己实现细节，可以利用jdk来实现自己的观察者模式。<p>jdk观察者模式缺点：<br>（1）Observable是一个抽象类而不是借口，应该多使用接口而非抽象类，不利于扩展<br>（2）setChanged是一个protected方法，只能继承observable，否则不能通知观察者，不够灵活</p><p>可以借鉴jdk思想实现自己的通知方式，灵活使用观察者模式。</p><h2 id="代理模式">代理模式</h2><p>代理模式的结构如下图：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/proxys.png?imageMogr2/thumbnail/!40p)</center>代理类Proxy和被代理类RealSubject都实现了同一接口，proxy负责realSubject的访问和控制。<p>JAVA中的代理RMI</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/javaproxy.png?imageMogr2/thumbnail/!40p)</center>RMI使用步骤：（1）制作远程接口：扩展java.rmi.Remote所有方法都抛出异常RemoteException，确定变量和返回值都是可序列化的（2）制作远程实现：实现远程接口，构造一个不带参数构造函数并声明RemoteException，利用rmi registry注册此服务（3）利用rmic产生stub、skeleton：在远程实现类（非接口）执行rmic，执行rmiregistry，启动服务（注册对象）（4）启动rmi registry（rmiregistry，使得客户可以查到代理的位置）（5）开始远程服务<p>注意点：<br>（1）在启用远程服务前必须先启用rmiregistry<br>（2）变量和返回值都必须是可序列化的，否则运行时会出错<br>（3）客户在lookup代理时，必须有stub类（由rmic产生），否则stub对象无法被反序列化，客户端需要调用远程对象返回的序列化对象！<br>（4）服务端游stub与skeleton类，需要stub是因为stub是真正服务对象的替身，当对象被绑定时，真正绑定的对象是服务端的stub对象!</p><p>JDK中的动态代理 Proxy与InvocationHandler<br>InvocationHandler起辅助作用，将proxy产生的代理类请求交给真正对象去处理，具体的结构图如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/javaproxys.png?imageMogr2/thumbnail/!40p)</center><h2 id="迭代器与组合模式">迭代器与组合模式</h2><p>迭代器模式定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示！<br>迭代器将元素游走遍历的职责交给迭代器，而不是聚合对象，这样简化了聚合接口的实现，让责任各得其所。</p><p>迭代器结构图如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/iterator.png?imageMogr2/thumbnail/!40p)</center>单一职责：一个类应该只有一个引起变化的原因          尽量让每个类保持单一责任<p>组合模式定义：允许你将对象组合成树形结构来表现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合（处理时忽略对象组合和个别对象之间的差异。</p><p>组合模式往往需要一个抽象类，类中的方法对于叶子结点和组合节点不同，有些方法适用于叶子结点，而有些节点适用于组合节点，所以在处理时根据情况覆盖抽象类方法，有时候还需要处理异常情况，否则需要进行类型判断对用户不再透明！</p><h2 id="单例模式">单例模式</h2><p>单例模式定义：<br>只能创建一个对象，保证线程安全，提供全局访问点<br>注意点：线程安全、效率、私有构造函数、静态对象</p><p>方法：急切加载 、double-check(voliate)、枚举、静态内部类(静态私有内部类，final私有staic变量)<br>推荐后两者</p><h2 id="状态模式">状态模式</h2><p>定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类！<br>使用方法：<br>（1）定义一个State接口，每一个接口都有一个对应的方法<br>（2）为系统中每一个状态实现State接口实现状态类，这些状态类负责相应状态下系统的行为<br>（3）将动作委托到状态类</p><p>系统状态可以被多个Context共享，将状态设计为静态变量</p><p>状态模式结构图如下所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/state.png?imageMogr2/thumbnail/!40p)</center><h2 id="模版方法模式">模版方法模式</h2><p>定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得之类可以在不改变算法结构的情况下，重新定义算法中的某些步骤，即由子类实现算法的部分实现！<br>JDK中Arrays.sort方法中comparable将compareTo方法的实现交由子类实现，是一种模版方法！</p><p>一般情况下，我们将抽象类中的算法的骨架设计为final类型的方法防止子类去修改，另外，可以在抽象类中将可选方法设计为hook（钩子）方法，子类可以选择覆盖来达到某种目的。</p><p>系统结构图：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/template1.png?imageMogr2/thumbnail/!40p)</center>好莱坞原则：别调用我们，我们会调用你！<center>![img](http://oqcre1dsl.bkt.clouddn.com/template1.png?imageMogr2/thumbnail/!40p)</center>好莱坞原则：高层组件对底层组件的原则：别调用我，我会调用你<p>模版方法模式 VS 策略模式<br>都是封装算法，模版方法使用了继承，由子类去实现算法某一部分细节；策略模式使用了组合，用委托决定采用哪一个行为</p><h2 id="命令模式">命令模式</h2><p>命令模式定义：将请求封装为命令对象，以便来使用不同的请求，队列或日志来参数化其他对象。命令模式也支持撤销操作。<br>命令对象在特定接受者上绑定一组动作来封装一个请求，命令是通过将动作和接受者绑定在一起做到的，命令对象通常只暴露一个execute方法，该方法被调用时，接受者就会进行相关的操作。从表面看，调用者不知道哪个接受者进行了哪些动作，从而通过命令对象将调用者和接受者进行了解耦。</p><p>命令模式的用途：命令可以讲运算块打包（一组动作和一个接受者），然后传来传去。命令对象甚至可以在不同的线程中被调用，所以它可以用来：（1）日程安排（2）线程池（3）工作队列</p><p>命令模式将发出请求的对象和执行请求的对象解耦，这两者之间是通过命令对象进行沟通的，命令对象封装了接受者和一组动作，命令支持撤销，通过宏命令（多组命令）可以对简单命令进行扩展。命令用于线程队列、日志系统、事物系统等。</p><p>Java代码 : https://github.com/lifeloner/designPattern</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式程序员写出优雅、结构优雅代码的必备基础，以下是研发中常见的一些设计模式！&lt;/p&gt;
    
    </summary>
    
      <category term="Basic" scheme="https://lifeloner.github.io/categories/Basic/"/>
    
    
      <category term="Common" scheme="https://lifeloner.github.io/tags/Common/"/>
    
  </entry>
  
  <entry>
    <title>Lock与Synchronized</title>
    <link href="https://lifeloner.github.io/2017/01/09/lock/"/>
    <id>https://lifeloner.github.io/2017/01/09/lock/</id>
    <published>2017-01-09T15:56:25.000Z</published>
    <updated>2017-08-07T12:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中通过锁实现同步的方式主要有2种：通过synchronized关键字和显示的lock。</p><a id="more"></a><h2 id="synchronized">synchronized</h2><p>其本质是对对象进行加锁，java中每一个对象都有内置锁，synchronized在修饰方法时也是对当前对象（this所指对象）进行加锁，对static方法加锁时是对该类进行加锁（类的class对象），所以对类的实例加锁和对类加锁互不影响。synchronized同步块是一种监视锁，反编译后可以看到monitor和exit monitor同步块，该区域内同一时刻只允许一个线程访问。注意加锁的粒度是线程而不是对象，jvm会记录线程获取锁的次数，当线程获取当前对象的内置锁时再进入同一对象的同步块时该线程获取次数会＋1，在该次数减为0之前其他线程无法获取当前锁，所以synchronized是可重入锁。</p><h2 id="lock">lock</h2><p>显示的lock也是可重入锁，在lock和unlock之间代码块受锁的保护。lock相比synchronized更灵活，提供了lock、try lock、lockInterruptibly等多种灵活的方式。其中lock（）和synchronized一样是不可中断的阻塞方法，而try lock是非阻塞的，加锁成功直接返回true，否则反回false，try lock也可以带一个时间参数，如果在规定的时间获取锁返回true，否则直接退出反回false，在等待期间是可响应中断的，lockInterruptibly是阻塞可中断的。</p><h2 id="synchronized的继承性">synchronized的继承性</h2><p>synchronized修饰的方法是不可继承的，这主要体现在：子类的方法不具有synchronized性质，若子类没有复写方法，同步依靠父类来提供；若子类复写了方法则该方法不具有同步特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.study.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/7/28.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">methodOne</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"super method_one"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">6000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.study.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/7/28.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                 methodOne();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"child method_one"</span>);</div><div class="line">        <span class="keyword">super</span>.methodOne();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          ChildClass childClass=<span class="keyword">new</span> ChildClass();</div><div class="line">          childClass.testMethod();</div><div class="line">          childClass.testMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个线程都会执行methodOne方法，但同时只有一个线程能执行父类的methodOne方法。所以子类一方面可以依靠父类提供同步保证，若复写了父类的方法则需要自己提供同步机制。</p><h2 id="死锁问题">死锁问题</h2><p>线程在获取锁时，执行顺序不当往往会造成死锁，尤其在一个同步块中调用了另一个方法，而该方法中也有锁相关的操作，这种情况下存在潜在的死锁风险且不容易发现，synchronized在死锁时无法解决只能强制退出应用，下面是一个实例：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.study.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/7/19.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> class DeadLockSynchronized &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="keyword">Object</span> a=<span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">        <span class="keyword">Object</span> b=<span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">                <span class="keyword">synchronized</span> (a)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">500</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (b)&#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(Thread.currentThread().getName()+<span class="string">" get a and b lock"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">                <span class="keyword">synchronized</span> (b) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">600</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (a) &#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(Thread.currentThread().getName() + <span class="string">" get a and b lock"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        System.out.<span class="built_in">println</span>(Thread.currentThread().getName()+<span class="string">" finshed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用lock能更灵活的避免死锁问题，可以尝试一次性申请所有锁，若失败则释放所有锁再重新尝试，代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package com.study.thread;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/8/6.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DealLock</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeadLock</span>(<span class="params">Lock one, Lock two, String a, String b, <span class="keyword">int</span> time</span>) </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (one.tryLock()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" get lock "</span> + a);</div><div class="line">                    Thread.sleep(<span class="number">600</span>);</div><div class="line">                    <span class="keyword">if</span> (two.tryLock()) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" get lock "</span> + b);</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            two.unlock();</div><div class="line">                            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" release lock "</span> + b);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    one.unlock();</div><div class="line">                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" release lock "</span> + a);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(time * <span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" fail and retry"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        DealLock dealLock = <span class="keyword">new</span> DealLock();</div><div class="line">        Lock one = <span class="keyword">new</span> ReentrantLock();</div><div class="line">        Lock two = <span class="keyword">new</span> ReentrantLock();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                dealLock.testDeadLock(one, two, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"thread_one"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                dealLock.testDeadLock(two, one, <span class="string">"two"</span>, <span class="string">"one"</span>, <span class="number">3</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"thread_two"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Connected <span class="built_in">to</span> <span class="keyword">the</span> target VM, address: <span class="string">'127.0.0.1:58776'</span>, transport: <span class="string">'socket'</span></div><div class="line">thread_one <span class="built_in">get</span> lock <span class="literal">one</span></div><div class="line">thread_two <span class="built_in">get</span> lock <span class="literal">two</span></div><div class="line">thread_one release lock <span class="literal">one</span></div><div class="line">thread_two release lock <span class="literal">two</span></div><div class="line">thread_one fail <span class="keyword">and</span> retry</div><div class="line">thread_one <span class="built_in">get</span> lock <span class="literal">one</span></div><div class="line">thread_one <span class="built_in">get</span> lock <span class="literal">two</span></div><div class="line">thread_one release lock <span class="literal">two</span></div><div class="line">thread_one release lock <span class="literal">one</span></div><div class="line">thread_two fail <span class="keyword">and</span> retry</div><div class="line">thread_two <span class="built_in">get</span> lock <span class="literal">two</span></div><div class="line">thread_two <span class="built_in">get</span> lock <span class="literal">one</span></div><div class="line">thread_two release lock <span class="literal">one</span></div><div class="line">thread_two release lock <span class="literal">two</span></div><div class="line">Disconnected <span class="built_in">from</span> <span class="keyword">the</span> target VM, address: <span class="string">'127.0.0.1:58776'</span>, transport: <span class="string">'socket'</span></div></pre></td></tr></table></figure><h2 id="tips">Tips</h2><p>所以，在使用锁时一定要检查代码，考虑死锁的可能性，尤其注意锁的获取顺序。另外，synchronized的性能不如lock，若仅仅只是用来保证数据一致性而没有其他特殊要求，还是建议使用synchronized，jdk在每一个版本中都在不断优化内置锁的性能，所以它们差别很小，除非为了灵活性或其他需求而使用lock，使用lock时需要养成好习惯讲unlock写在finally语句块中防止程序异常也能够及时释放锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中通过锁实现同步的方式主要有2种：通过synchronized关键字和显示的lock。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrent" scheme="https://lifeloner.github.io/categories/Concurrent/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
      <category term="Thread" scheme="https://lifeloner.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java GC</title>
    <link href="https://lifeloner.github.io/2017/01/09/gc/"/>
    <id>https://lifeloner.github.io/2017/01/09/gc/</id>
    <published>2017-01-09T12:04:12.000Z</published>
    <updated>2017-11-19T09:04:54.612Z</updated>
    
    <content type="html"><![CDATA[<p>Java垃圾回收器相关基础</p><a id="more"></a><h2 id="java内存区域">Java内存区域</h2><p>Java与c＋＋很大的区别在于内存管理上，c＋＋中主要由程序员对内存进行申请和释放（new、delete／malloc、free），而java中内存交由JVM来管理，虽然这在一定程度上减少了java程序员的负担，但了解JVM内存管理、GC机制能够帮助我们写出高质量、高效率的代码、并能排除内存溢出、内存泄漏等常见问题，下面我们先了解一下java的内存区域。<br>JVM的内存区域划分如下图所示：</p><center>       ![img](http://oqcre1dsl.bkt.clouddn.com/memory.png?imageMogr2/thumbnail/!42p)</center>1.程序计数器       程序计数器是一块较小的内存空间，用于记录线程的虚拟机字节码指令地址，程序的分支、循环、跳转、异常处理、以及线程切换都依赖与该计数器完成，它是线程私有的内存空间。<p>2.java虚拟机栈<br>虚拟机栈也是线程私有的，它描述了java方法执行的内存模型：每一个方法执行时都会创建一个栈帧用于存放局部变量表、操作数、方法出口等信息。每一个方法的调用和结束对应着栈帧入栈和出栈操作。局部变量表存放了基本的类型（boolean、byte、char、int、long、float、double），引用类型（reference，简单理解为对象的内存地址而不是对象本身），returnAddress（返回地址即虚拟机一条字节码指令，局部变量表大小在编译器确定，运行期间不会改变。该区域中可能出现StackOverFlowError（栈深度超过JVM允许深度），OutOfMemoryError（无法申请足够内存）。</p><p>3.本地方法栈<br>与虚拟机栈很类似，区别在于虚拟机栈对应的是java方法，而本地方法栈对应的是native方法服务（如c＋＋），JVM对本地方法栈的语言、数据结构没有要求，有的虚拟机（如HotSpot）甚至把虚拟机栈和本地方法栈合二为一统一管理。</p><p>4.java堆<br>这部分区域对大家最熟悉不过了，它是JVM管理的内存区域中最大的一块，存放着对象的实例，为所有线程共享，几乎所有的对象实例都在堆上分配内存（几乎而不是完全绝对）。堆也是GC回收的主要的区域，同样该区域也会抛出 OutOfMemoryError异常。</p><p>5.方法区<br>方法区也为所有线程共享，存放了虚拟机加载的类信息、常量、静态变量、编译后的代码等数据。运行时常量池是方法区的一部分，用于存放编译期的常量、符号引用、直接引用。方法区也会抛出OutOfMemoryError异常。</p><p>6.直接内存<br>直接内存不是JVM运行时数据区的一部分，也不是JVM定义的内存区域。但该区域也被频繁使用，可能导致OutOfMemoryError异常。NIO出现，引入了基于channel和buffer的I／O方式，它可以使用native函数库直接分配堆外内存，然后通过java堆中的directByteBuffer对象作为该内存的应用进行操作，以此来避免java堆和native堆来回复制数据，提高了性能。</p><p>下面我们以HotSpot虚拟机为例，了解一下创建对象时堆内存分配以及对象的访问过程。<br>（1）对象创建<br>当使用new创建一个对象时，虚拟机首先在方法区的常量池中定位到一个类的符号引用，检查符号引用的类是否被加载、解析、初始化，具体细节可以阅读java类加载机制相关知识点。在类加载后，需要在堆中分配内存，堆中的内存常常不是规整的往往存在内存碎片，所以需要使用“空闲列表”的方式来选择分配的地址。在分配内存时还需要注意线程安全，防止出现给对象A分配内存后没修改地址而对象B使用了相同的地址指针，所以可以采用2种办法：一是使用同步方式（虚拟机采用CAS的原子语义方式而不是锁），二是给每个线程分配一小块缓冲（TLAB），当线程使用完TLAB后再同步分配内存。对象内存分配后，JVM将内存空间初始化为零值（不包括对象头），接下来虚拟机将对象所属类的元数据信息、对象哈希码、gc分代年龄、对象锁信息放入对象内存的对象头中，这样JVM的对象初始化工作完成了，但在程序员看来对象的字段都还没初始化，接下来执行<init>方法，按照构造函数要求对对象进行初始化，这样对象的整个初始化过程完成。<br>（2）对象访问<br>使用栈上的reference来操作堆中对象实例，应用定位和访问的方式有句柄和直接指针两种。</init></p><center>![img](http://oqcre1dsl.bkt.clouddn.com/point.png)![img](http://oqcre1dsl.bkt.clouddn.com/direct.png)</center>句柄方式需要在堆中申请一块额外的内存，reference存储了句柄的的地址，句柄优势在于对象实例被移动时只会改变句柄中实例数据指针，reference不用改变。直接指针方式优势在于定位速度快，省掉一次指针定位时间，hotspot虚拟机采用的直接指针方式，在大量对象访问情况下性能提升比较客观。<h2 id="gc">GC</h2><p>在学习GC前，我们首先需要明白几个问题：哪些内存需要回收？什么时候回收？怎么回收？</p><p>1.对象的存活<br>判断对象是否死亡方式有多种，其中主要的方式有：引用计数法、可达性分析法。<br>引用计数法：给对象添加一个引用计数器，每当有一个引用指向它，计数器加1，当引用失效，计数器减1，减为0则对象可以回收，但无法解决对象之间相互循环引用问题。<br>可达性分析法：通过GC Roots对象为起点，往下搜索，经过的路径称为引用链，当对象通过引用链和GC Roots不可达时则可以回收。java中使用可达性分析算法来判断对象存活情况，java中常见的GC Roots有虚拟机栈引用的对象，方法区中常量、静态变量引用的对象、本地方法栈JNI引用的对象。<br>即使对象与GC Roots不可达，对象也并非必死不可，对象死亡至少经历2个标记过程，首先前面提到的不可达是第一次标记，然后进行一次筛选来确定是否需要执行finalize方法，若对象没有复写finalize方法或者之前已经执行过finalize，那么虚拟机将不再执行finalize方法。在第一次标记后，并需要执行finalize时，finalize是对象逃脱回收的最后机会，对象被放在F－Queue队列中，然后由一个低优先级的Finalizer线程执行对象finalize方法，如果对象在finalize中把自己引用（this）赋值给某个类变量或对象成员变量，那它将被移除被回收的集合，如果仍没有逃脱那基本将被JVM真正回收。一个对象可以在GC时逃脱，但只能逃脱一次，因为finalize只能执行一次。<br>GC并不仅仅发生在堆中，在方法区（hotspot中成为永久代）也会发生GC，只是回收效率较低。永久代中回收的内容主要有常量和类，一个常量没有任何地方使用就被认为是废弃的可以进行回收了，但类的判断要求严格的多，需要满足的条件有：类所有实例被回收；加载类的ClassLoader被收回手；Class对象没有在任何地方引用，无法通过反射访问类方法和字段。只有满足这3个要求，JVM才有可能（并不一定）回收该类。</p><p>2.GC算法<br>主要的gc算法有4种：标记－清除算法，复制算法，标记－整理算法，分代收集算法。<br>（1）标记－清除算法<br>标记－清除算法分为标记、清除2个阶段，首先对需要回收的对象进行标记，完成后统一回收标记的对象。它存在2个缺点：标记清除过程效率低，而且gc后存在大量不连续的内存碎片，导致以后分配大内存对象时内存不足，不得不触发另一次gc。<br>（2）复制算法<br>复制算法思想是把内存容量划分为大小相等的2块，每次使用其中一块，当内存不足时将存活的对象复制到另一块内存，这样就不存在内存碎片问题。但这样内存的使用率较低，没有充分利用内存，有些浪费。IBM经过研究表明，大部分对象（约98%）都是朝生夕死，并不需要按照1:1来划分，所以提出了eden，survivor（2个survivor，eden，suivivor比例为8:1）区域，将eden，survivor中对象移动另一块survivor中，最后清理掉eden，survivor区域，这样仅仅浪费了10%的内存，这也是hotspot默认的方式，当不能保证不超过10%内存大小对象存活时，需要依赖其他内存（老年代）进行分配担保。当存活对象较多时，回收效率较低，所以复制算法一般用于年轻代。<br>（3）标记－整理算法<br>对于老年代，提出了另一种方法：标记－整理算法，相比标记－清除算法，他不是直接对对象进行回收，而是把存活对象移动到一端，然后清理到边界以外的内存区域。<br>（4）分代收集算法<br>分代收集算法根据对象存活时间把对象分为年轻代、老年代，根据每个阶段采取不同的收集算法，一般对于年轻代大量的对象会死去，一般采用复制算法，对于老年代对象存活旅高，也没有分配担保，一般使用标记－清除，标记－整理算法。</p><p>3.HotSpot GC算法实现<br>在gc前，首先需要找出GC Roots节点以及引用链，一般作为GC Roots的节点主要有全局性引用（常量、类静态属性）以及执行上下文（栈帧的本地变量表）。在可达性分析时需要保证一致性，在枚举gc roots以及引用链时，需要停止java线程的执行（stop the world），不然对象引用关系在不断变化。在线程停止，检查寻找gc roots时，jvm并不需要一个一个的检查，hotspot使用了OopMap数据结构来达到这个目的，该数据结构记录了对象偏移量上是什么类型数据。<br>在OopMap帮助下，hotspot快速完成gc roots枚举，但hotspot没有为每个指令都生成OopMap，只是在特定的位置纪录了这些信息，这些位置被称为安全点。程序执行时并非在所有地方都可以停止下来gc，只能在安全点暂停下来，所以一般的安全点选取在方法调用、循环跳转、异常跳转。在gc时需要使所有的线程都运行到最近的安全点（safe point）上，所以有2种方案，一是抢先式中断：在gc时中断全部线程，若线程不在安全点上让他恢复运行到安全点上，另一种是主动式中断：不主动中断线程，通过设置标志，让线程主动轮询标志，发现中断标志后自己中断挂起，轮询位置刚好和安全点重合。<br>对于线程处于sleep、blocked时，线程无法执行到安全点时，需要使用安全域来解决。线程进入安全域（safe region）后，gc时不需要关注处于安全域状态的线程。当线程离开安全域时需要检查是否已经完成gc过程，若没有完成必须等到整改gc完成才能离开安全域。</p><p>4.垃圾收集器<br>垃圾收集器是gc算法的具体实现，jvm中的垃圾收集器很多，不同的版本、不同厂商虚拟机提供的垃圾收集器差异也很大，常见的gc收集器如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/gc.png)</center>（1）Serial   serial收集器是单线程的收集器，同时在gc时必须停止其他工作线程（stop the world），该收集器主要用于运行在client模式下的虚拟机。（2）ParNew   parent是serial的多线程版本，其他策略与serial基本一致，是工作在server模式下的虚拟机首选的新生代收集器，能够与cms配合工作。在单cpu下它还不如serial的性能，但在多核下并发效果还是有不少提升。（3）Parallel Scavenge   parallel scavenge收集器也是基于复制算法的新生代收集器， 相比其他收集器，它主要关注吞吐量（cpu运行用户代码时间与gc时间比例），cms主要关注了停顿时间适用于用户交互的程序，响应速度快，parallel scavenge使用了快速完成运算任务，不需要太多交互。parallel scavenge提供了2个参数用于控制吞吐量：－XX：MaxGCPauseMillis用于保障gc时间不超过设定值，－XX：GCTimeRatio设置gc时间最多占总时间比例，同时它该提供了－XX：＋UseAdaptiveSizePolicy虚拟机会根据系统情况自动调节gc时间和吞吐量，所以改收集器是一种吞吐量优先收集器。（4）Serial Old   serial old也是一个单线程的老年代收集器，使用标记－整理算法，在client模式下配合serial工作，在server模式下与parallel scavenge搭配使用，或作为cos的后备收集器，在其发生concurrent mode failure备用。<center>![img](http://oqcre1dsl.bkt.clouddn.com/serial.png)</center>（5）parallel old   该收集器也适用了标记－整理算法，用于配合 parallel scavenge（无法与cms配合工作），因为serial old但线程收集能力较差无法利用多cpu处理能力。<center>![img](http://oqcre1dsl.bkt.clouddn.com/parallel.png)</center>（6）CMS CMS收集器是以获取最短停顿时间为目标的收集器，能够加快响应速度，它是基于标记－清理算法，收集过程包含4个过程：初始标记、并发标记、重新标记、并发清除。1、3阶段需要stop the world，初始阶段标记gc roots直接关联的对象，速度较快，并发标记对gc roots进行追踪，重新标记修正并发标记中程序继续运行的变动，该阶段比初始标记慢但远比并发标记快。整个过程耗时的并发标记、清除可以与用户并发执行，所以停顿时间较短。 CMS作为优秀的收集器也有3个明显的缺陷，首先CMS对cpu资源敏感，并发时和工作线程一起运行占用cpu资源，导致程序执行速度变慢，吞吐量降低。其次，cms存在浮动垃圾，可能出现concurrent mode failure导致另一次full gc，原因在于cms在并发清除阶段程序还在运行，所以会有新的内存和垃圾出现，cms无法在这次gc中回收它们，由于在该阶段必须有足够的内存留给用户线程执行，所以cms不能等到老年代被使用完才gc，需要流出一部分空间在并发清除阶段给用户线程使用。如果这个阶段剩下内存不够用户线程使用，那么就出现了concurrent mode failure失败，jvm不得不使用serial old进行一次full gc，停顿用户线程进行gc，时间更长了。最后，cms基于标记－清除算法实现，存在内存碎片问题，所以cms提供了参数，在多少次gc后需要进行一次内存整理过程。 <center>![img](http://oqcre1dsl.bkt.clouddn.com/cms.png)</center>（7）G1G1是当前gc中最前沿的研究成果，它不需要与其它垃圾收集器一起工作，相比其它收集器它的优势如下：      并行与并发：利用多cpu多核优势，减少stop the world时间，采用并发方式执行gc      分代回收：采用不同的方式处理新对象和旧对象，不需要配合其它收集器      空间整合：与cms的标记－清除不同，G1整体上基于标记－整理方式，局部上基于复制算法，都不会存在内存碎片问题      可预测停顿：不断能够减少停顿时间，还能建立可预测的时间模型，保证在M时间内gc时间不超过NG1将java堆划分为大小相同的区域（Region），保留了新时代老年代概念，他避免了在整个堆进行全区域gc，G1跟踪各个region的价值大小（gc时间、回收大小）维护一个优先级列表，回收价值最大的region，保证了高效的回收效率。在回收region时，对象的引用可能存在不同的region中，G1使用了Remembered Set来避免全表扫描引用关系，每一个region都有一个remembered set保存对象引用关系，G1收集过程分为4个步骤：初始标记、并发标记、最终标记、筛选回收。初始标记标记gc roots直接关联的对象，并发标记进行可达性分析，找出存活的对象，可与用户线程并发执行，最终标记修正并发阶段的变化，并将变化纪录在remembered set中，该过程需要停顿用户线程，最后筛选阶段根据region排序结果，按照优先级回收，该过程其实也可以做到并发执行，但仅仅回收一部分region速度较快，也没有太大必要。所以G1追求了低停顿，吞吐量没有改进。<center>![img](http://oqcre1dsl.bkt.clouddn.com/g1.png)</center>5 内存分配和回收策略    （1）对象优先分配在eden区域中，eden区域空间不足将发起MinorGC    （2）大对象直接进入老年代，jvm允许通过－XX：PretenureSize Threshold参数设置对象直接在老年代分配    （3）长期存活对象进入老年代，可设置－XX：MaxTenuring Threhold改变阈值    （4）动态对象年龄判断，jvm并不一定要求年龄达到阈值才能进入老年代，若survivor对象中相同年龄所有对象大小达到survivor一半，大于等于该年龄即可进入老年代    （5）空间分配担保，在Minor GC之前，虚拟机会检查老年代可用连续空间是否大于新生代对象总空间，若成立则Minor GC是安全的，否则需要查看是否允许担保失败，若允许则检查历次从新生代晋升到老年代的对象平均大小，若小于则进行Minor GC（虽然有风险），若不允许冒险或大于则进行一次 Full GC。]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java垃圾回收器相关基础&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://lifeloner.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://lifeloner.github.io/2016/11/10/linux/"/>
    <id>https://lifeloner.github.io/2016/11/10/linux/</id>
    <published>2016-11-10T13:28:02.000Z</published>
    <updated>2017-08-07T12:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>显示日期：date +%Y%m%d    date +%H：%M<br>显示日历al<br>cal 年月日：cal  month  year</p><a id="more"></a><p>计算器：bc<br>quit退出<br>帮助指令：man<br>man 命令<br>数据同步磁盘：sync<br>关机：shutdown -t（秒）-r（重启） -h（停止系统服务后关机）<br>重启：reboot</p><p>改变群组： chgrp  -r（递归） 文件／目录<br>改变拥有者：chown -r  拥有者：群组 文件／目录<br>改变属性：chmod  -r 数字 文件／目录 （rwx：421）</p><p>目录所在磁盘信息：df   -a（所有）-k（kb） -m（mb）-h（gb，mb，kb自行显示） 文件／目录<br>当前目录所有文件容量：du -a(所有)  -s（总量）-k（kb）目录<br>连接档：in<br>hard link（硬连接、实际连接，指向同一档案、不占空间、删除原始档不受影响）<br>symbolic link（符号连接、快捷方式、占空间、删除原始档后不可用）<br>用法 ：in   -s（符号连接、默认硬连接） -f（若存在同名删除再建立） 源文件  目标文件</p><p>磁盘分割：fdisk  -l(所有装置)  装置名称<br>进入后会有一些命令，主要有：<br>l 显示所有硬盘信息；<br>n新增一个磁盘分区；<br>p显示磁盘分区<br>d删除一个磁盘分区<br>q不存储离开<br>w写入磁盘分区表离开<br>格式化磁盘：mke2fs  -b（设置bolck大小）-c（检查错误）磁盘名称<br>磁盘检验：fsck -A（所有装置扫描）-a（自动修复） -f（强制进行细部检查）<br>磁盘挂载：mount -a(所有磁盘全部挂载)  -t（指定格式类型） 装置名称   挂载点<br>卸载装置：umount 装置代号／挂载点</p><p>虚拟内存：<br>将目录格式化为swap档案格式：mkswap 目录<br>启动：swapon    目录<br>关闭：swapoff    目录</p><p>删除空的目录：rmdir -p（递归删除）目录<br>复制文档目录：cp  -l（hard link建立）-p（连属性一起复制过去）-r（递归）-s（symbolic link） -u（更新目标文件）  源文件   目标文件<br>删除档案目录：rm -f（强制） -r（递归） 文件／目录<br>移动档案／目录：mv   -f（强制） -u（更新） 源  目的</p><p>查看：cat   -n（行号） -A（显示特殊字符） 文件<br>一页一页翻动  ：more  文件<br>空格键：向下翻一页    enter：下一行    ／字符串：搜索字符串  :f ：显示文件名和行数   q：退出<br>less  文件<br>空格键：向下翻一页   pagedown：向下一页   pageup：向上一页   ／字符串：向下搜索字符串    ？／：向上搜索字符串    q：退出<br>取出前面几行：head   -n（n行）  文件<br>后面几行：tail  -n   文件<br>非ascll文件（二进制）：od  -t （类型）  文件<br>touch  -a（修改atime）-c（修改ctime）-m（修改mtime）文件</p><p>预设权限：umask 数字<br>设置隐藏属性：chattr ±= 文件<br>常见的：i：无法修改、增加 、删除     a：只能增加不能修改删除<br>查看隐藏属性：lsattr  -a(隐藏属性)  -R（递归子目录）  文件<br>文件类型：file  文件<br>文件查找：<br>查找执行档(命令)：which  -a（所有同名） 文件名<br>查找特定档案（二进制、源文件、man说明文件）：whereis     -b（二进制文件）-s（source来源） -m（manual路径下） 文件<br>locate  文件名（可以查找部分匹配文件名的文件） 文件名<br>find     路径  参数<br>（-name filename）<br>（-user username）<br>（-group name）</p><p>压缩打包：<br>gzip -d（解压缩） 文件<br>zcat：查看gzip压缩文件内容<br>bzip2  -z(压缩)  -d(解压缩)  文件<br>bzcat  ：查看bzip2压缩的文件<br>tar  -c(建立)  -x(解开) -t(查看)  -v（压缩过程显示文件）-f(使用档名)  -z(使用gzip)  -j(使用bzip2 )  -P（使用绝对路径）-p（保持原来文件属性）<br>eg：tar -zcvf   /tmp/a.tar.gz  /home /etc  把home 和 etc目录打包并gzip压缩到／tmp下的a中<br>tar -zxvf  ／tmp／a.tar.gz  ／home  将 文件中的home先gzip解压然后解开打包 最后放在当前目录下<br>dd  if=   of=    (bs= 默认512  count=)</p><p>截取命令：<br>cut：<br>-d  分割字符（单个字符）与 -f一起使用<br>-f  取出第几段  与-d配合使用<br>-c  取出固定的字符区间<br>eg：echo ￥path | cut -d ‘：’ -f 5      取出path种以：分割的第5块<br>export | cut -c 12-   取出export配置第12个开始后的所有字符<br>grep:<br>-c:计算匹配次数<br>-n：显示行号<br>-v:反过来没有匹配的那一行<br>-i：忽略大小写</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;显示日期：date +%Y%m%d    date +%H：%M&lt;br&gt;
显示日历al&lt;br&gt;
cal 年月日：cal  month  year&lt;/p&gt;
    
    </summary>
    
      <category term="Basic" scheme="https://lifeloner.github.io/categories/Basic/"/>
    
    
      <category term="Linux" scheme="https://lifeloner.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JVM字节码执行引擎和编译、优化</title>
    <link href="https://lifeloner.github.io/2016/09/04/classbytes/"/>
    <id>https://lifeloner.github.io/2016/09/04/classbytes/</id>
    <published>2016-09-04T12:04:12.000Z</published>
    <updated>2017-11-19T09:02:33.613Z</updated>
    
    <content type="html"><![CDATA[<p>Java作为跨平台的语言离不开jvm的支持，java语言首先经过javac编译器编译为class字节码文件然后被jvm解释、编译为本地机器码，然后被os执行，由于jvm中间这一层的存在所以java语言才能跨平台，同时除了java，ruby、scala等语言经过编译后的字节码只要符合jvm字节码规范也能够被jvm执行，所以字节码是一种规范，了解jvm执行引擎对学习java也很有帮助。</p><a id="more"></a><h2 id="字节码执行引擎">字节码执行引擎</h2><p>1.运行时栈帧结构<br>栈帧是支持jvm方法调用、执行的数据结构，是jvm运行时虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接、方法返回地址，每一个方法调用到结束对应了一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>局部变量表存放了方法参数和局部变量，以slot（变量槽）为最小单位，操作数栈是一个后入先出的栈（LIFO），32位，方法返回值用于方法执行完将返回值返回上层方法调用，对于异常抛出未处理时是没有返回值（异常表处理），修改PC计数器。</p><p>2.方法调用<br>方法调用确定被调用方法的版本（具体来说是调用哪一个方法），class文件的编译不包括链接步骤，方法调用在class文件中是符号引用，需要转化为直接引用（入口地址）。</p><p>3.解析调用：<br>在类加载阶段把符号引用转化为直接引用，在方法运行前有可确定的调用版本并且在运行时不可变，也就是说在编译时确定了方法的调用。java中方法调用的直接码指令有：<br>1.invokestatic 静态方法<br>2.invokespecial 实例构造器<init>、私有方法、父类方法<br>3.invokeinterface方法接口，运行时确定是实现接口的对象<br>4.invokedynamic<br>5.invokevirtual虚方法<br>其中invoke static、invoke special都可以在解析阶段确定，invoke virtual中带有final的方法。解析调用是静态过程，在编译期确定了，不会到运行期再去完成。</init></p><p>4.分派：<br>分派调用可能是静态的也可能是动态的。<br>静态分派：重载，java中变量有静态类型（外观类型）、实际类型。静态类型在编译期已知，实际类型在运行期才可以确定，所以重载是属于静态分派，在编译期已经确定了，并不是由jvm来确定，重载时也会选择最佳的匹配方法。<br>动态分派：重写，根据对象实际类型选择方法调用。动态分派过程如下：<br>(1).找到对象实际类型C<br>(2).在类型C中找到与常量描述都相同的方法，进行访问权限校验，通过返回直接引用否则返回java.lang.IllegalAccessError<br>(3).否则，按照继承关系对父类进行第二步的搜索验证<br>(4).没有找到合适方法，抛出java.lang;AbstractMethodError<br>其中，静态分派调用是一方面会判断对象的静态类型也会判断方法的参数，所以它属于静态多分派；动态分派只会根据实际类型判断，所以属于动态多分派。<br>动态分派在实现时，jvm在方法区存放了一个虚方法表，同样invokeinterface存在一个接口方法表，虚方法表中存放了方法的实际入口地址，若子类未复写则子类和父类地址一致，指向父类入口，若复写了则指向子类实现的入口地址，方法表在类加载阶段连接是进行，初始化类变量后对方法表也进行了初始化。</p><h2 id="编译-优化">编译、优化</h2><p>Java语言的编译阶段主要有2种，包括了前端编译期（java－&gt;class）、运行期编译期（JIT编译器，字节码－&gt;机器码）。</p><p>1.早期编译<br>java编译器本身由java语言编写，它对代码的运行效率几乎没有任何优化措施，性能优化主要集中在JIT中。javac编译器的编译过程主要有3个过程：<br>1.1解析和填充符号表过程<br>词法分析、语法分析；填充符号表<br>2.1插入式注解处理器的注解处理过程<br>注解支持<br>3.1分析和字节码生产过程<br>语义分析（标注检查、数据流、控制流分析）；解语法糖（泛型、自动装箱）；字节码生成</p><p>2.晚期优化<br>混合编译模式：<br>java程序最初通过解释器进行解释执行，当jvm发现某个代码运行频繁时，将把这些代码认为“热点代码”，在运行时把这些代码编译成本地机器码进行各种层次优化，这些都由JIT编译器完成，下面以hotspot为例介绍运行期的优化方法。<br>主流的JVM都同时包含了解释器和编译器。解释器省去编译时间可以迅速启动，在程序运行中编译器可以把代码编译成本地代码提高执行效率，而且当编译器激进优化不成立时能够通过逆优化退回到解释执行。HotSpot中设置了2个即时编译器，分别为client、server，server优化程度更深更复杂。<br>编译优化触发条件：<br>被编译优化的“热点代码”主要有2类：多次调用的方法、多次执行的循环体。第一种编译器以整个方法作为编译对象，后一种编译由循环体触发，但JIT还是会以整个方法（而不是循环体）作为编译对象，这种方式发生在方法执行过程中，成为栈上替换（on stack replacement）OSR，方法在栈上，方法被替换了。</p><p>热点代码的判定方法主要有2种：采样热点探测、计数器探测<br>2.1基于采样热点探测：jvm周期性检查线程栈顶，某个方法经常出现则为热点代码，并能发现方法的调用关系，但容易受外界干扰（线程阻塞）<br>2.2基于计数器热点探测：建立计数器，统计方法执行次数，超过阈值即为热点代码，但不能发现方法调用关系<br>hotspot以第二种方法判断热点代码，计数器有方法计数器和回边计数器，方法调用计数器、回边计数器运行过程分别如下：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/method.png)![img](http://oqcre1dsl.bkt.clouddn.com/huibian.png)</center>如果不做设置，方法调用计数器统计的不是绝对次数，而是相对次数，在一定时间的调用次数，超过一定时间会减半即热衰减，也可以设置来关闭热衰减。回边计数器，统计了方法中循环体的次数，回边计数器没有热衰退。在方法调用发出即使编译请求后，在代码编译未完成前仍然按解释方式执行，编译过程在后台编译线程中执行，也可以设置关闭后台编译，等待编译完成在执行编译后本地代码。    编译方式比解释方式执行速度快，一方面是执行本地代码快，另一方面JIT编译时进行了优化，主要的优化有：    1.公共子表达式消除    2.数组范围检查消除    3.方法内联    4.逃逸分析]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java作为跨平台的语言离不开jvm的支持，java语言首先经过javac编译器编译为class字节码文件然后被jvm解释、编译为本地机器码，然后被os执行，由于jvm中间这一层的存在所以java语言才能跨平台，同时除了java，ruby、scala等语言经过编译后的字节码只要符合jvm字节码规范也能够被jvm执行，所以字节码是一种规范，了解jvm执行引擎对学习java也很有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://lifeloner.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="https://lifeloner.github.io/2016/09/04/classloader/"/>
    <id>https://lifeloner.github.io/2016/09/04/classloader/</id>
    <published>2016-09-04T12:04:12.000Z</published>
    <updated>2017-11-19T08:23:27.387Z</updated>
    
    <content type="html"><![CDATA[<p>类从被加载到虚拟机内存中开始到卸载出内存，整个的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备、解析阶段统成为连接，7阶段关系如下图：</p><a id="more"></a><center>![img](http://oqcre1dsl.bkt.clouddn.com/classloader.jpg)</center>其中，加载、验证、准备、初始化、卸载顺序是确定的，而解析阶段不一样，可以在初始化之后再开始，这是为了支持java的运行时绑定。这些阶段通常都是互相交叉混合进行，在一个阶段执行过程中调用激活另一个阶段。<h2 id="类加载时机">类加载时机</h2><p>java虚拟机规范没有约束加载阶段，由具体的虚拟机实现来把握，而初始化阶段却有严格的规定，以下五种情况必须对类进行初始化：</p><p>（1）使用new、getstatic、putstatic、invokestatic字节码指令时，类没有初始化，必须对类进行初始化<br>（2）使用reflect对类进行反射调用<br>（3）初始化类时，父类未初始化则需要触发类初始化<br>（4）jvm启动，会初始化指定包含main方法那个类<br>（5）jdk1.7动态语言支持，java.lang.invoke.methodhandle实例后的解析结果REF_getStatiic、REF_putStatiic、REF_invokeStatiic的方法句柄，这个方法句柄对应类没有初始化，首先要初始化该类</p><p>对于这5种初始化场景成为类主动引用，除此之外其他的方式成为被动引用，不会触发初始化，常见的被动引用有：</p><p>（1）子类使用父类中static字段<br>（2）new对象数组<br>（3）使用类的final static字段</p><h2 id="加载过程">加载过程</h2><p>加载阶段jvm完成以下3件事情：<br>（1）通过类的全限定名来获取类的二进制字节流<br>（2）将字节流代表的静态存储结构转化为方法区运行时数据结构<br>（3）在内存中（方法区）生产代表这个类的class对象</p><p>其中第一条并没有指定必须从class文件获取，其实有很多技术建立在这一基础上：<br>（1）从zip包获取：jar、war、ear格式基础<br>（2）网络获取，applet<br>（3）运行时生产，动态代理技术，proxy，cglib<br>（4）数据库或其他文件获取</p><h2 id="验证">验证</h2><p>验证阶段保证了class文件的字节流信息符合jvm要求，不会危害jvm安全，主要包含了：<br>（1）文件格式验证<br>（2）元数据验证<br>（3）字节码验证<br>（4）符号应用验证</p><p>具体验证内容需要对类文件结构有一定理解。</p><h2 id="准备">准备</h2><p>准备阶段为类变量分配内存设置变量初始值，这里分配的是static变量，而非实例对象，并将static变量初始化为“零值”，而final static变量在准备阶段以及赋值为指定的值。</p><h2 id="解析">解析</h2><p>解析阶段将常量池中符号引用替换为直接引用，主要包含：<br>（1）类、接口解析<br>（2）字段解析<br>（3）类方法解析<br>（4）接口方法解析</p><h2 id="初始化">初始化</h2><p>初始化是类加载最后一步，该阶段开始执行用户java代码，在准备阶段对类变量赋值为零值，而初始化将对类变量赋初始值。从另一个角度来说初始化阶段是执行类构造器<clinit>方法过程，<clinit>收集类变量赋值和static块（有先后顺序），有以下几点需要注意：<br>（1）jvm保证子类clinit执行前，父类clinit已经执行完毕<br>（2）clinit对于类并非必须，没有类变量和static也就不需要了<br>（3）接口不能使用static块，但有变量初始化过程，与类不同之处在于接口clinit方法不需要执行父接口clinit方法，除非使用了父接口的变量<br>（4）jvm会保证clinit方法的同步、加锁，只执行一次</clinit></clinit></p><h2 id="类加载器">类加载器</h2><p>java中任何一个类，都需要一个类加载器来进行加载，比较2个类是否相等，需要保证其来自的class文件相同并且被同一类加载器加载，否则是2个不同的类。java中类加载机制称为双亲委派模型，如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/doubleparent.jpg)</center>(1).BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。(2).Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。(3).Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。<p>上述三个JDK提供的类加载器虽然是父子类加载器关系，但是没有使用继承，而是使用了组合关系，加载顺序如下：</p><p>(1).如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。<br>(2).每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。<br>(3).如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。</p><p>在JDK1.2之前，自定义类加载器都要覆盖loadClass方法去实现加载类的功能，JDK1.2引入双亲委派模型之后，loadClass方法用于委派父类加载器进行类加载，只有父类加载器无法完成类加载请求时才调用自己的findClass方法进行类加载，因此在JDK1.2之前的类加载的loadClass方法没有遵循双亲委派模型，因此在JDK1.2之后，自定义类加载器不推荐覆盖loadClass方法，而只需要覆盖findClass方法即可。<br>双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。</p><h2 id="tomcat案例分析">Tomcat案例分析</h2><p>tomcat web服务器解决的问题：<br>（1）不同web应用使用了同一个第三方类库的不同版本，需要包装不同webapp类库可以相互独立<br>（2）同一web服务器上的webapp使用的java类库相互共享，如spring，如果将所有类库都进行加载，加载的类太多，方法区可能会溢出，所以需要解决共享问题<br>（3）web服务 器需要保证自身安全，自身类库和webapp类库隔离<br>（4）某一个webapp的jsp应用<br>tomcat采用了不同的类加载器来解决这些问题，它有／common、／server、／shared目录，web应用的类库在自己目录／WEB_INF下,一共有4类目录，tomcat在处理时采用了如下方式：<br>（1）／common：被tomcat和所有webapp共享<br>（2）／server：只能被tomcat使用<br>（3）／shared：只能被所有webapp使用<br>（4）／webapp／web－info：仅对某一webapp使用<br>类加载器如下：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/tomcat.png?imageMogr2/thumbnail/!40p)</center>tomcat遵循了双亲委派机制，而OSGI作为一种灵活的类加载架构，对类加载有更大的启发，以后有时间多学习学习。]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类从被加载到虚拟机内存中开始到卸载出内存，整个的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备、解析阶段统成为连接，7阶段关系如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://lifeloner.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://lifeloner.github.io/2016/07/22/maven/"/>
    <id>https://lifeloner.github.io/2016/07/22/maven/</id>
    <published>2016-07-22T15:08:48.000Z</published>
    <updated>2017-08-07T13:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 是一个项目管理和构建自动化工具，它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统，和用来运行定义在生命周期阶段中插件目标的逻辑。<br>使用maven创建项目后，文件目录如下：</p><a id="more"></a><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:center">目的</th></tr></thead><tbody><tr><td style="text-align:left">${basedir}</td><td style="text-align:center">存放 pom.xml和所有的子目录</td></tr><tr><td style="text-align:left">${basedir}/src/main/java</td><td style="text-align:center">项目的 java源代码</td></tr><tr><td style="text-align:left">${basedir}/src/main/resources</td><td style="text-align:center">项目的资源，比如说 property文件</td></tr><tr><td style="text-align:left">${basedir}/src/test/java</td><td style="text-align:center">项目的测试类，比如说 JUnit代码</td></tr><tr><td style="text-align:left">${basedir}/src/test/resources</td><td style="text-align:center">测试使用的资源</td></tr></tbody></table><p>maven中重要的一个文件是pom文件，上面是一个简单的pom文件：其中groupId, artifactId, packaging, version 叫作 maven 坐标，它能唯一的确定一个项目。有了 maven 坐标，我们就可以用它来指定我们的项目所依赖的其他项目，插件，或者父项目。在复杂的项目中，大项目一般会分成几个子项目。在这种情况下，每个子项目就会有自己的 POM 文件，然后它们会有一个共同的父项目。这样只要构建父项目就能够构建所有的子项目了，子项目的 POM 会继承父项目的 POM。<br>下面我们从maven库，生命周期，依赖库来对maven进行介绍：</p><h2 id="maven库">Maven库</h2><p>maven库分本地库、中央存储库、远程存储库。其中，本地库指 maven 下载了插件或者 jar 文件后存放在本地机器上的拷贝。在 Linux，mac os 上，它的位置在 ~/.m2/repository，在 Windows XP 上，在 C:\Documents and Settings\username.m2\repository ，在 Windows  上，在 C:\Users\username.m2\repository，我们可以修改setting.xml中localRepository结点来改变本地库的位置。当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 – http://repo1.maven.org/maven2/ 查找下载。在Maven中，当你声明的库不存在于本地存储库中，也没有不存在于Maven中心储存库，可以设置从远程存储库中搜索，设置的方式如下，会从java.net中搜索需要的jar：</p><p>所以Maven的依赖库查询顺序为：<br>在 Maven 本地资源库中搜索，如果没有找到，进入第 2 步，否则退出。<br>在 Maven 中央存储库搜索，如果没有找到，进入第 3 步，否则退出。<br>在java.net Maven的远程存储库搜索，如果没有找到，提示错误信息，否则退出。</p><h2 id="maven-生命周期">Maven 生命周期</h2><pre><code>  Maven的生命周期就是对所有的构建过程进行抽象和统一。包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。Maven有三套相互独立的生命周期，分别是clean、default和site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面。</code></pre><p>clean生命周期：清理项目，包含三个phase。<br>1）pre-clean：执行清理前需要完成的工作<br>2）clean：清理上一次构建生成的文件<br>3）post-clean：执行清理后需要完成的工作</p><p>default（build）生命周期：构建项目，重要的phase如下。<br>1）validate：验证工程是否正确，所有需要的资源是否可用。<br>2）compile：编译项目的源代码。<br>3）test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。<br>4）Package：把已编译的代码打包成可发布的格式，比如jar。<br>5）integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。<br>6）verify：运行所有检查，验证包是否有效且达到质量标准。<br>7）install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。<br>8）Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</p><p>site生命周期：建立和发布项目站点，phase如下<br>1）pre-site：生成项目站点之前需要完成的工作<br>2）site：生成项目站点文档<br>3）post-site：生成项目站点之后需要完成的工作<br>4）site-deploy：将项目站点发布到服务器</p><p>各个生命周期相互独立，一个生命周期的阶段前后依赖，如mvn clean install，调用clean生命周期的clean阶段和default的install阶段，实际执行pre-clean和clean，install以及之前所有阶段。maven插件目标可以绑定到生命周期阶段上。一个生命周期阶段可以绑定多个插件目标。当 maven 在构建过程中逐步的通过每个阶段时，会执行该阶段所有的插件目标。</p><h2 id="maven依赖管理">Maven依赖管理</h2><pre><code>  赖是使用Maven坐标来定位的，而Maven坐标主要groupId, artifactId, version构成，随着项目的增大，依赖越来越多，兼容性和冲突问题将会出现，maven通过依赖范围和传递性依赖以及排除依赖来管理依赖问题。下面是一个简单的依赖配置文件：</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p>maven不但下载了 junit-3.8.1.jar，还下载了它的 POM 文件。这样 maven 就能检查 junit 的依赖关系，把它所需要的依赖也包括进来。依赖的主要几个元素如下：</p><p>groupId,artifactId和version：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖<br>type: 依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值是jar<br>scope: 依赖的范围<br>optional: 标记依赖是否可选<br>exclusions: 用来排除传递性依赖<br>scope指依赖范围，主要有compile、test、provided、runtime、system这几类，是用来控制依赖与这三种classpath(编译classpath、测试classpath、运行classpath)的关系，它们的范围如下：<br>compile: 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行<br>test: 测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效<br>provided: 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。<br>runtime: 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。<br>system: 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。</p><p>当我们引入第三方jar包的时候，难免会引入传递性依赖，有些时候这是好事，然而有些时候我们不需要其中的一些传递性依赖，可以在们可以使用exclusions元素声明排除依赖，exclusions可以包含一个或者多个exclusion子元素，因此可以排除一个或者多个传递性依赖。需要注意的是，声明exclusions的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖，不会出现重复。<br>当同一个模块，所依赖的几个模块版本都相同时，可以使用maven里的属性做分类依赖，依赖版本升级时改一处即可，如Spring Framework的依赖，可以使用 如下方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure><p>然后在dependency中使用这个版本即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven 是一个项目管理和构建自动化工具，它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统，和用来运行定义在生命周期阶段中插件目标的逻辑。&lt;br&gt;
使用maven创建项目后，文件目录如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://lifeloner.github.io/categories/Tools/"/>
    
    
      <category term="Maven" scheme="https://lifeloner.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Concurrenthashmap</title>
    <link href="https://lifeloner.github.io/2016/07/19/concurrenthashmap/"/>
    <id>https://lifeloner.github.io/2016/07/19/concurrenthashmap/</id>
    <published>2016-07-18T16:28:08.000Z</published>
    <updated>2017-11-19T08:24:39.823Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道Java集合框架中，hashmap是非线程安全的，在并发环境下会出现错误情况，具体的原因分析参考：hashmap线程安全性。java也提供了相应的线程安全类，如hashtable、ConcurrentHashMap等。下面介绍一下ConcurrentHashmap。</p><a id="more"></a><p>首先hashtable也是线程安全的，通过分析源码发现hashtable是通过synchronized同步了整个hash表，只允许一个线程对hashtable进行读写，所以并发时造成多个线程等待效率较低。而ConcurrentHashMap允许多个线程并发操作，其关键在于使用了锁分离技术，它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。对于有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。</p><p>ConcurrentHashmap的结构如下：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/concurrenthashmap.png)</center>由上图可以看出，ConcurrentHashmap是整个hash表，它由多个（默认16个）segment组成，相当于一个hashtable，hashentry是链表一个节点。下面看一下主要的源代码：<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractMap&lt;K</span>, <span class="title">V&gt;</span>  <span class="title">implements</span> <span class="title">ConcurrentMap&lt;K</span>, <span class="title">V&gt;</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> int segmentMask;</div><div class="line">    <span class="keyword">final</span> int segmentShift;</div><div class="line">    <span class="keyword">final</span> <span class="type">Segment</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;[] segments;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这表明ConcurrentHashmap的segment是不可变的，扩容只能增加segment的大小，其数量不会发生变化。segment的源码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397</span>L;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HashEntry是volatile，则其修改对于其他线程是可见的，hashentry源码如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt;&#123;</div><div class="line"><span class="keyword">final</span> K key;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line"><span class="keyword">volatile</span> V value; </div><div class="line"><span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除了value不是final的，其它值都是final的，所以不能从hash链的中间或尾部添加或删除节点，为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。<br>ConcurrentHashmap这种设计，保证读取操作能够读取到几乎最新的修改，所以读操作大多数情况了不需要加锁。</p><p>下面看一下remove操作：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">    hash = hash(<span class="built_in">key</span>.hashCode());</div><div class="line">    <span class="keyword">return</span> segmentFor(hash).remove(<span class="built_in">key</span>, hash, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>整个操作是先定位到段，然后委托给段的remove操作。当多个删除操作并发进行时，只要它们所在的段不相同，它们就可以同时进行。下面是Segment的remove方法实现：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/conmaprm.png)</center>整个操作是在持有segment锁的情况下执行的，先定为代需要删除的节点e，然后将e前面的节点都复制一遍，因为entry是不可变的，所以必须要复制前面的节点，这种不可变性使得不需要同步从而节省了时间。例如删除前的数据为：1、2、3、4，删除3后链表变为：2、1、4。 整个remove实现并不复杂，但是需要注意如下几点。第一，当要删除的结点存在时，删除的最后一步操作要将count的值减一。这必须是最后一步操作，否则读取操作可能看不到之前对段所做的结构性修改。第二，remove执行的开始就将table赋给一个局部变量tab，这是因为table是 volatile变量，读写volatile变量的开销很大。编译器也不能对volatile变量的读写做任何优化，直接多次访问非volatile实例变量没有多大影响，编译器会做相应优化。<p>接下来看一下put操作：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/conmapput.png)</center>修改数据是不能并发进行的，所以该方法也是在持有segment锁的情况下执行，然后判断是否超限确保容量不足时能够rehash。接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n。<p>然后看一下get操作：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/conmapget.png?imageMogr2/thumbnail/!80p)</center>get操作不需要锁。第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count 变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。接下来就是根据hash和key对hash链进行遍历找到要获取的结点，对hash链进行遍历不需要加锁的原因在于链指针next是final的。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在 table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。因为put操作的语句：tab[index] = new HashEntry<k,v>(key, hash, first, value)，在这条语句中，HashEntry构造函数中对value的赋值以及对tab[index]的赋值可能被重新排序，这就可能导致结点的值为空，所以可能需要在加锁情况在在读一遍：<center>![img](http://oqcre1dsl.bkt.clouddn.com/conmapread.png?imageMogr2/thumbnail/!70p)</center>contains方法更简单了，他不需要读值，所以不需要加锁了。最后看一下size（）操作：<center>![img](http://oqcre1dsl.bkt.clouddn.com/conmapsize.png)</center>size方法主要思路是先在没有锁的情况下对所有段大小求和，如果不能成功（这是因为遍历过程中可能有其它线程正在对已经遍历过的段进行结构性更新），最多执行RETRIES_BEFORE_LOCK次，如果还不成功就在持有所有段锁的情况下再对所有段大小求和。在没有锁的情况下主要是利用Segment中的modCount进行检测，在遍历过程中保存每个Segment的modCount，遍历完成之后再检测每个Segment的modCount有没有改变，如果有改变表示有其它线程正在对Segment进行结构性并发更新，需要重新计算。<p>ConcurrentHashmap主要的方法大概这么多，其同步的方法在于使用了分段锁、final、volatile等减少了同步的范围，并保证了可见行。它的实现也比较复杂，需要多多思考和理解。</p></k,v>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家都知道Java集合框架中，hashmap是非线程安全的，在并发环境下会出现错误情况，具体的原因分析参考：hashmap线程安全性。java也提供了相应的线程安全类，如hashtable、ConcurrentHashMap等。下面介绍一下ConcurrentHashmap。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrent" scheme="https://lifeloner.github.io/categories/Concurrent/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
      <category term="DataStructure" scheme="https://lifeloner.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>Violate</title>
    <link href="https://lifeloner.github.io/2016/07/18/violate/"/>
    <id>https://lifeloner.github.io/2016/07/18/violate/</id>
    <published>2016-07-17T16:19:22.000Z</published>
    <updated>2017-11-19T08:39:50.963Z</updated>
    
    <content type="html"><![CDATA[<p>在Java高并发环境下，多个线程之间可能存在资源共享情况，可能造成了数据不一致情况。很多人都想到可以利用加锁的方式来实现，如java中的synchronized同步块和Lock，然而这种方式虽然可以解决问题，但加锁的本质是thread，只允许同一时刻只有一个线程来访问同步块，而在有些情况下我们并不需要严格的同步，只保证能读写最新的值即可，所以volatile能达到这个效果。</p><a id="more"></a><p>在学习java并发编程前，我们先简单了解一下java内存模型。</p><h2 id="jmm">JMM</h2><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/jmm.png?imageMogr2/thumbnail/!50p)![img](http://oqcre1dsl.bkt.clouddn.com/readwrite.png?imageMogr2/thumbnail/!38p)</center>read and load 从主存复制变量到当前工作内存use and assign  执行代码，改变共享变量值store and write 用工作内存数据刷新主存相关内容<p>如：x＝1这条语句     执行线程必须先在自己的工作线程中对变量x所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值1写入主存中。<br>下面继续分析并发编程中原子性、可见行、顺序性等概念。</p><h2 id="原子性">原子性</h2><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，这些操作是不可被中断的，要么执行，要么不执行，这和数据库中事物的原子性概念很类似。</p><p>如 x = 10;  y = x;     x＋＋；x＝x＋1<br>在上面4个语句中，只有第一个是原子操作，其他都是复合操作，语句2包含2个操作，它先要去读取x的值，再将x的值写入工作内存，语句3和4都包含3个操作：读取x的值，进行加1操作，写入新的值  。<br>所以只有简单的读取、赋值（变量之间的相互赋值不是原子操作）才是原子操作，另外在32位机器上，long等64位数据赋值也不是原子操作。</p><h2 id="可见性">可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h2 id="有序性">有序性</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行，如下例子所示：</p><p>int i = 0;<br>boolean flag = false;<br>i = 1;                //1<br>flag = true;          //2</p><p>上面例子中，语句1和2之间没有任何关系，jvm不能保证1一定在2前面执行，因为有可能发生指令重排序。指令重排序是指处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。下面是另一个例子：</p><p>int a = 10;<br>int r = 2;<br>a = a + 3;   //1<br>r = a*a;     //2</p><p>这种情况下语句2不会在语句1前面执行，因为r的计算依赖语句1的操作结果。<br>所以有序性只保证程序最终执行结果和代码顺序执行的结果是一致的，并没有强调执行语句必须与程序代码一致，这样在单个线程中不会出现任何问题，然而在多个线程下会存在问题，上面例子中语句1，2在不同线程中，则r的值有可能不正确。要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。</p><p>java中volatile关键字来保证了一定的“有序性”，同样synchronized和Lock也可以保证有序性。另外jvm内存模型中具备了一些先天的有序性：happens-before 原则，具体规则如下：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h2 id="volatile剖析">volatile剖析</h2><p>在简单理解了jmm后，我们先在分析一下volatile关键字的作用。<br>volatile实际上有2个作用：<br>1).保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2).禁止进行指令重排序(内存屏障），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</p><p>下面结合一些经典的例子讲解一下：在java中，thread的stop方法是极不推荐的，为了停止线程通常的做法设置一个标记：</p><p>//线程1<br>boolean stop = false;<br>while(!stop){<br>doSomething();<br>}<br>//线程2<br>stop = true;</p><p>线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。用volatile修饰之后会强制将修改的值立即写入主存，导致线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取，所以stop的值就是最新的值，线程就停止了。</p><p>下面是另一个典型的例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        final Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)</div><div class="line">            Thread.<span class="keyword">yield</span>();</div><div class="line">        System.<span class="keyword">out</span>.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的操作大多数情况下都不是1000，因为volatile并不能保证原子性。上述例子中关键在于inc＋＋这个复合操作，分为读取、增加、写入三部操作，假设线程1从主存中读取了值，然后将值加一但还未写入主存，此时线程2也从内存中读取了值（此时和线程1读取的值一样，因为线程1还没将结果写入）然后增加写入，此时线程1继续执行，它已经不需要读取inc的值了，直接把计算的结果写入，所以这个时候线程2的增加操作被覆盖，导致只增加一次。使用synchronized和lock可以保证执行结果的正确性，也可以使用concurrent包下面的AtomicInteger类等。</p><p>volatile不能保证操作的原子性，但可以保证有序性。在单例模式中，通常通过double－check来提升单例的执行效率：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line"></div><div class="line">    private volatile static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="attribute">instance</span>==null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="attribute">instance</span>==null)</div><div class="line">                   <span class="built_in"> instance </span>= new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用volatile关键在于instance = new Singleton()这条语句本质包括了3个步骤：<br>1:在堆中分配内存    2： 初始化堆中的对象   3:将堆中对象引用复制给instance<br>然后，上述三步中2和3是有可能发生指令重排序的，若先执行了3，此时instance非null，但堆中对象未初始化不能使用，若另一线程刚好执行到getInstance（）第一行，在判断 if(instance==null) 时程序会出现异常，所以volatile内存屏障防止了指令重排序，保证了2先于3发生。</p><h2 id="总结：">总结：</h2><p>volatile在某些情况下能保证并发的执行效率，但它并不能保证原子性，所以使用volatile时synchronized和lock一定能达到同样的效果，但反过来就不能保证。理解java中并发编程需要对jvm和操作系统有一定的了解，还需要多多学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java高并发环境下，多个线程之间可能存在资源共享情况，可能造成了数据不一致情况。很多人都想到可以利用加锁的方式来实现，如java中的synchronized同步块和Lock，然而这种方式虽然可以解决问题，但加锁的本质是thread，只允许同一时刻只有一个线程来访问同步块，而在有些情况下我们并不需要严格的同步，只保证能读写最新的值即可，所以volatile能达到这个效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrent" scheme="https://lifeloner.github.io/categories/Concurrent/"/>
    
    
      <category term="Java" scheme="https://lifeloner.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC框架概括</title>
    <link href="https://lifeloner.github.io/2016/07/16/dispatchservlet/"/>
    <id>https://lifeloner.github.io/2016/07/16/dispatchservlet/</id>
    <published>2016-07-16T14:56:57.000Z</published>
    <updated>2017-11-19T08:27:26.853Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC是web开发中一种优良的MVC框架，它分离了控制器、模型对象、分派器以及处理程序对象的角色。当前的MVC框架有多种，主要有Struts1.x、Struts2、SpringMVC，而这些MVC框架都是在围绕着Controller进行重构和改善，他们主要的特点可以简单的概括为下图。</p><a id="more"></a><center>![img](http://oqcre1dsl.bkt.clouddn.com/servlet.png)</center>Struts1.x是一个早期的MVC框架实现，它保留了servlet中HttpServletRequest和HttpServletResponse这两大接口作为参数，另外它将返回值改为ActionForward完成对响应结果的处理，除此之外它增加了ActionMapping和ActionForm两大参数，相比传统的servlet，它优化了逻辑处理过程。struts2主要有2个创新点，首先消除了HttpServletRequest或者HttpServletResponse这样的原生Servlet对象，其次将请求参数和响应数据从响应方法中剥离到controller对象中的属性。这样整个Controller类彻底与Web容器解耦，摆脱了servlet的束缚，最后servlet引入了ThreadLocal模式，使得Controller成为一个线程安全的对象被servlet模型使用，它的拦截器、OGNL等技术使它成为一个流行的MVC框架。<p>SpringMVC的创新之处在于它引入Annotation来完成请求-响应的映射关系 ，在JDK1.5普及之后，Annotation作为一种新兴的Java语法，逐渐被大家熟知和应用。另外SpringMVC在响应方法上，可以支持多种多样不同的参数类型和返回值类型，当参数类型为Model时，SpringMVC将会自动将请求参数封装于Model内部而传入请求方法；当返回值类型是String时，直接表示SpringMVC需要返回的视图类型和视图内容，在写Controller的代码时可以随心所欲，不再受到任何契约的束缚。</p><p>SpringMVC的主要工作流程如下图所示：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/springmvc.png)</center> 1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； 2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； 3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter，如果成功获得HandlerAdapter后，此时将开始执行拦截器的方法，拦截器的作用是拦截用户请求并在执行controller中方法之前或之后进行相应的处理，主要有3个方法，boolean preHandle在处理请求之前被调用，当一     个请求中存在多个拦截器时，拦截器会根据其声明顺序依次执行其preHandle 方法，返回为false 时则请求结束，后续拦截器和对应Handler都不会再被调用，当返回值为true 时就会继续调用下一个拦截器的preHandle方法。 void postHandle是处理请求之后DispatcherServlet 对视图进行渲染之     前被调用。postHandle方法被调用的顺序与拦截器声明的顺序相反。 void afterCompletion在DispatcherServlet 渲染视图之后被调用，当对应的拦截器的preHandle方法的返回值为true时才会执行，主要用于进行资源清理工作。 4.DispatcherServlet调用ViewResolver，ViewResolver根据ModelAndView对象中的信息解析得到对应的View对象（使用了freemarker的视图解析器）； 5.DispatcherServlet调用View，View根据ModelAndView对象中Model中的数据进行页面渲染； 6.DispatcherServlet返回响应给用户。<p>在项目使用Spring MVC首先需要在web.xml配置对应的servlet，servlet-mapping配置指定了由Spring MVC 处理的请求的路径。<br>在web.xml中也可以通过配置context-param来指定spring配置文件的路径，可以指定多个配置文件的路径。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/appservlet.png)</center>在spring的配置文件中配置ViewResolver，HandlerMapping和HandlerAdapter，项目中可以使用freemarker实现视图， <mvc:annotation-driven>配置会在spring容器中注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter。<center>![img](http://oqcre1dsl.bkt.clouddn.com/applicationcontext.png)</center>最后在controller类中调用service类进行业务处理，最终结合了mybaits操作修改了数据库。</mvc:annotation-driven>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringMVC是web开发中一种优良的MVC框架，它分离了控制器、模型对象、分派器以及处理程序对象的角色。当前的MVC框架有多种，主要有Struts1.x、Struts2、SpringMVC，而这些MVC框架都是在围绕着Controller进行重构和改善，他们主要的特点可以简单的概括为下图。&lt;/p&gt;
    
    </summary>
    
      <category term="Frameworks" scheme="https://lifeloner.github.io/categories/Frameworks/"/>
    
    
      <category term="SpringMVC" scheme="https://lifeloner.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="https://lifeloner.github.io/2016/07/16/springmvc/"/>
    <id>https://lifeloner.github.io/2016/07/16/springmvc/</id>
    <published>2016-07-16T13:50:21.000Z</published>
    <updated>2017-11-19T08:54:34.037Z</updated>
    
    <content type="html"><![CDATA[<h1>SpringMVC请求与controller映射</h1><p>SpringMVC通过DispatcherServlet 来处理请求信息，其中servlet-mapping配置指定了由Spring MVC 处理的请求的路径。下图中url-pattern被指定为/，这与/*有很大不同。</p><a id="more"></a><center>![img](http://oqcre1dsl.bkt.clouddn.com/dispatcherservlet.png)</center>Tomcat在启动时会扫描web.xml文件，得到servlet的映射数据servletMappings，据此可以知道每个servlet处理的请求路径。通过分析源码，通常把路径4类：1. 以 /* 结尾的。 path.endsWith("/*")2. 以 *. 开头的。 path.startsWith("*.")3. 是否是 /      path.equals("/")4. 以上3种之外的<p>上述4种映射处理后会被放入 wrapper中，这里Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收，其中4类servlet对应的wrapper如下：</p><ol><li>/* 对应的Servlet会放在wildcardWrappers中</li><li>*. 会被放到extensionWrappers中</li><li>/ 会被放到defaultWrapper中(缺省)</li><li>其他的映射都被放到exactWrappers中(精确匹配某一路径)</li></ol><p>用户的请求过来时，会对请求的url进行匹配，匹配规则的先后顺序如下：</p><ol><li>精确匹配，使用contextVersion的exactWrappers</li><li>前缀匹配，使用contextVersion的wildcardWrappers</li><li>扩展名匹配，使用contextVersion的extensionWrappers</li><li>使用资源文件来处理servlet，使用contextVersion的welcomeResources属性，这个属性是个字符串数组</li><li>使用默认的servlet，使用contextVersion的defaultWrapper</li></ol><p>下面我们继续分析对于某个具体的请求(如http://ip:port/contextPath/path)<br>SpringMVC如何找到对应的Controller方法，即请求与Controller之间的映射关系。DispatcherServlet根据url得到对应的HandlerAdapter进行处理，处理过程中有几个重要的接口，HandlerMethodArgumentResolver、HandlerMethodReturnValueHandler。HandlerAdapter在处理每个请求时会实例化一个ServletInvocableHandlerMethod对象进行处理，处理请求时会根据ServletInvocableHandlerMethod的属性argumentResolvers（这个属性是它的父类InvocableHandlerMethod中定义的）进行处理，其中argumentResolvers属性是一个HandlerMethodArgumentResolverComposite类，这个类是实现了HandlerMethodArgumentResolver接口的类， 处理响应的时候，会根据ServletInvocableHandlerMethod的属性returnValueHandlers进行处理，returnValueHandlers属性是一HandlerMethodReturnValueHandlerComposite类，这个类是实现了HandlerMethodReturnValueHandler接口的类，这2个属性都在ServletInvocableHandlerMethod实例化的时候被赋值（通过HandlerAdapter的属性进行赋值），HandlerAdapter的相关属性是在HandlerAdapter进行实例化由Spring容量注入。</p><p>在常见的注解中，使用@ResponseBody注解的话最终返回值会被RequestResponseBodyMethodProcessor类处理，该类同时实现了HandlerMethodReturnValueHandler和HandlerMethodArgumentResolver这两个接口，所以它支持的请求类型是Controller方法参数中带有@RequestBody注解，支持的响应类型是Controller方法带有@ResponseBody注解，其他常用的HandlerMethodArgumentResolver实现类如下：<br>1.RequestParamMethodArgumentResolver<br>支持带有@RequestParam注解的参数或带有MultipartFile类型的参数<br>2.RequestParamMapMethodArgumentResolver<br>支持带有@RequestParam注解的参数 &amp;&amp; @RequestParam注解的属性value存在 &amp;&amp; 参数类型是实现Map接口的属性<br>3.PathVariableMethodArgumentResolver<br>支持带有@PathVariable注解的参数 且如果参数实现了Map接口，@PathVariable注解需带有value属性<br>4.MatrixVariableMethodArgumentResolver<br>支持带有@MatrixVariable注解的参数 且如果参数实现了Map接口，@MatrixVariable注解需带有value属性<br>5.RequestResponseBodyMethodProcessor<br>方法参数中带有@RequestBody注解<br>6.ServletRequestMethodArgumentResolver<br>参数类型是实现或继承或是WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、Locale、TimeZone、InputStream、Reader、HttpMethod这些类。<br>7.ServletResponseMethodArgumentResolver<br>参数类型是实现或继承或是ServletResponse、OutputStream、Writer这些类<br>8.RedirectAttributesMethodArgumentResolver<br>参数是实现了RedirectAttributes接口的类<br>9.HttpEntityMethodProcessor<br>参数类型是HttpEntity</p><p>常用的HandlerMethodReturnValueHandler实现类如下：<br>1.ModelAndViewMethodReturnValueHandler<br>返回值类型是ModelAndView或其子类<br>2.ModelMethodProcessor<br>返回值类型是Model或其子类<br>3.ViewMethodReturnValueHandler<br>返回值类型是View或其子类<br>4.HttpHeadersReturnValueHandler<br>返回值类型是HttpHeaders或其子类<br>5.ModelAttributeMethodProcessor<br>返回值有@ModelAttribute注解<br>6.ViewNameMethodReturnValueHandler<br>返回值是void或String</p><p>SpringMVC中将一个类添加@Controller以表示该类是一个controller，其他常用的注解如下：</p><p>1.@RequestMapping</p><p>用来标记请求的路径，它可以标记在类上面，也可以标记在方法上，当方法上和类上都标记了@RequestMapping的时候，那么对应的方法对应的Url就是类上的加方法上的。在RequestMapping中还可以指定一个属性method，其主要对应的值有RequestMethod.GET和RequestMethod.POST，@RequestMapping中还有一个属性params，可以通过该属性指定请求参数中必须包含某一参数，或必须不包含某一参数，或某参数的值必须是什么，以此来缩小指定的映射范围。</p><p>2.@PathVariable<br>可以标记在方法的参数上，利用它标记的参数可以利用请求路径传值，下面是一个具体的例子<br>@RequestMapping(value=&quot;/comment/{blogId}&quot;, method=RequestMethod.POST)<br>public void comment(Comment comment,@PathVariable int blogId, HttpSession session, HttpServletResponse response) throws IOException<br>}</p><p>3.@RequestParam<br>用来给参数传值的，但是它是从头request的参数里面取值，相当于request.getParameter(“参数名”)方法。它的取值规则跟@PathVariable是一样的，当没有指定的时候，默认是从request中取名称跟后面接的变量名同名的参数值，当要明确从request中取一个参数的时候使用@RequestParam(“参数名”)。</p><p>4.返回值</p><ul><li>返回一个ModelAndView，其中Model是一个Map，里面存放的是一对对的键值对，其可以直接在页面上使用，View是一个字符串，表示的是某一个View的名称</li><li>返回一个字符串，这个时候如果需要给页面传值，可以给方法一个Map参数，该Map就相当于一个Model，往该Model里面存入键值对就可以在页面上进行访问了</li><li>返回一个Model也就是一个Map，这个时  返回一个Model也就是一个Map，这个时候将解析默认生成的view name</li><li>任何其他类型的对象。这个时候就会把该方法返回类型对象当做返回Model模型的一个属性返回给视图使用，这个属性名称可以通过在方法上给定@ModelAttribute注解来指定，否则将默认使用该返回类名称作为属性名称。</li></ul><p>5.@SessionAttributes<br>只能声明在类上，而不能声明在方法上，表示模型对象的特定属性具有 Session 范围的作用域<br>如：@SessionAttributes(types = {User.class,Dept.class},value={“attr1”,“attr2”})</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;SpringMVC请求与controller映射&lt;/h1&gt;
&lt;p&gt;SpringMVC通过DispatcherServlet 来处理请求信息，其中servlet-mapping配置指定了由Spring MVC 处理的请求的路径。下图中url-pattern被指定为/，这与/*有很大不同。&lt;/p&gt;
    
    </summary>
    
      <category term="Frameworks" scheme="https://lifeloner.github.io/categories/Frameworks/"/>
    
    
      <category term="SpringMVC" scheme="https://lifeloner.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://lifeloner.github.io/2016/07/16/mybatis/"/>
    <id>https://lifeloner.github.io/2016/07/16/mybatis/</id>
    <published>2016-07-16T13:33:12.000Z</published>
    <updated>2017-11-19T08:38:15.204Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis是支持普通SQL查询和高级映射的优秀持久层框架。它消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录。</p><a id="more"></a><p>MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心，它是SqlSessionFactoryBuilder对象通过配置文件Configuration类实例中来构建SqlSessionFactory对象，在使用时常通过Spring来集成和整合，下面是SqlSessionFactory的基本配置文件。</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/sessionfactory.png)</center>可以看出，sqlSessionFactory被注册为spring容器中的bean，配置了使用的数据源，还有mybatis配置文件的位置、mapper xml文件的位置。sqlSessionFactory主要用来产生sqlSession，而sqlSession在Spring中使用了它的实现类sqlSessionTemplate，还定义了mapper接口的包路径，这里配置的MapperScannerConfigurer会将basePackage里的mapper接口注册为spring容器中的bean，并同时注入sqlSessionTemplate到mapper接口对象中，否则需要单独定义每一个mapper接口的bean。具体的Spring配置如下：<center>![img](http://oqcre1dsl.bkt.clouddn.com/template.png)</center>由上面分析可以看出，sqlSessionFactory的产生流程如下：首先sqlSessionFactoryBean根据mybatis配置文件构造出configuration对象，.然后通过sqlSessionFactoryBuilder的build方法构造出一个sqlSessionFactory实例，sqlSession的产生是通过sqlSessionFactory创建了它的实现类sqlSessionTemplate。<p>下面继续分析Mybatis中mapper接口，通常在程序中我们通过如下方式使用mapper：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/mapper.png)</center>在上面的spring配置中，将basePackage里的mapper接口注册为spring容器中的bean，在session调用getMapper时，扫描basePackage内的所有mapper接口并将这些bean设置为MapperFactoryBean.class，还添加了sqlSessionTemplate对象的引用。所以mapper对象由MapperFactoryBean来创建，在调用SqlSessionTemplate.getMapper时会调用MapperRegistry的getMapper方法，进而又通过了MapperProxyFactory对象创建mapper对象，MapperRegistry还记录了mapper接口和MapperProxyFactory对象的映射关系。MapperProxy类实现了InvocationHandler接口，mapper对象是其实是实现了对应mapper接口的动态代理对象，对mapper接口方法的调用都会调用代理对象的invoke方法，mapper对象的创建流程如下图：<center>![img](http://oqcre1dsl.bkt.clouddn.com/mapperpeoxy.png)</center>所以mybatis整合spring时，先通过SqlSessionFactoryBean创建了SqlSessionFactory，SqlSessionFactory创建了sqlSession，然后通过MapperFactoryBean生成了mapper对象，mapper对象的创建使用了java动态代理，mapper接口方法的调用都在代理对象的invoke方法中完成。<p>下面继续分析一条sql语句的执行过程：</p><center>![img](http://oqcre1dsl.bkt.clouddn.com/sql.png)</center>在getMapper方法得到mapper对象后，调用接口相关的语句时，经过上面的分析会调用MapperProxy对象的invoke方法(每一个MapperProxy对应一个dao接口)，然后会触发MapperMethod调用excute方法，该方法会根据根据类型去选择到底执行sqlSession中的哪个方法（insert、update、delete、select），然后执行相应的SqlSession的CRUD方法，之后会执行Excutor的doQueryQ方法，最后一步一步的封装最终通过PreparedStatement处理相关sql语句，然后执行结果逐步返回给sqlsession。最后在Mapper的的映射文件...Maper.xml文件中有很多动态sql语句，大大减少了sql语句拼接的复杂度，主要有insert、update、delete、select、if、choose、when、otherwise、where、set、foreach、trim等标签，具体的使用可参考帮助文档。 MyBatis的动态sql语句http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html。]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MyBatis是支持普通SQL查询和高级映射的优秀持久层框架。它消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Frameworks" scheme="https://lifeloner.github.io/categories/Frameworks/"/>
    
    
      <category term="Mybatis" scheme="https://lifeloner.github.io/tags/Mybatis/"/>
    
  </entry>
  
</feed>
