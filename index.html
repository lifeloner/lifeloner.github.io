<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.css.network/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/photo.png?v=5.1.2" />






<meta name="description" content="Keep Moving!">
<meta property="og:type" content="website">
<meta property="og:title" content="lifeloner">
<meta property="og:url" content="https://lifeloner.github.io/index.html">
<meta property="og:site_name" content="lifeloner">
<meta property="og:description" content="Keep Moving!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lifeloner">
<meta name="twitter:description" content="Keep Moving!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键词搜索","hits_empty":"找不到关于${query}的文章","hits_stats":"找到${hits}篇相关文章，花费${time}ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lifeloner.github.io/"/>





  <title>lifeloner</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lifeloner</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/10/11/midwares/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/11/midwares/" itemprop="url">大型系统中的中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T10:10:10+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Architecture/" itemprop="url" rel="index">
                    <span itemprop="name">Architecture</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/10/11/midwares/" class="leancloud_visitors" data-flag-title="大型系统中的中间件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大型系统的发展离不开中间件的支持，从大型网站系统的发展历程中，我们也看到了中间件发挥的重要作用。下面我们了解一下最常见的服务框架、数据访问中间件和消息中间件以及相关的软负载中心，学习它们的设计过程以及在大型系统中解决的问题。
&lt;!--more--&gt;</p>
<h2>服务框架</h2>
<p>在早期的互联网系统中，大多数网站系统如处于下图这个阶段，这样的系统结构在早期能够很好解决问题。随着网站规模扩大，业务复杂，应用开始变得臃肿。多个应用中会有大量重复冗余的代码，不利于系统的维护和稳定性。这种情况下，可以采用应用拆分的方法，将大应用拆分成小应用，降低冗余，但是仍然还在重复代码，不能从根本上解决问题。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/traditionalArch.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
另外可以采用服务化的方案，如下图所示，我们在底层的数据库、缓存系统和应用层之间增加一层服务层，服务可以有多层也可以相互访问，这样系统结构更清晰了，一些重复的代码都做成了服务。这样有两个好处：一方面服务由专门团队管理，提升了代码质量，另一方面，底层的资源由服务层来管理，结构清晰，开发效率高，也更加稳定。当然服务化带来的远程服务调用也需要进行管理，也就是所谓的服务治理，这也是很重要很关键的部分，关联着整个系统的稳定性。
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/soaArch.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h3>服务框架的设计与实现</h3>
<p>当把应用的结构改成包含有服务框架的多层结构时，服务化使得一些本地的调用变成了远程调用（RPC）。在这种改变下，服务框架的易用性和性能十分重要，下面我们看一下服务调用的客户端和服务端实现。</p>
<h4>远程调用方式</h4>
<p>调用端的实现中重要的一步是跟据调用的服务名称来获取提供服务的机器地址列表，然后从可用的服务地址中选择一个可调用的机器，然后发送参数和调用接口。在获取可选择服务机器时，常存在三种控制方式：（1）LVS或硬件负载均衡设备；（2）名称服务方式（3）规则服务器，该方式与名称服务很类似，只不过规则服务器常用于有状态的场景下，其中（2）（3）都是直连的方式。</p>
<h4>服务的路由</h4>
<p>在具体调用远程服务时需要通过服务名称进行寻址和路由，具体的控制需要由interfaceName+version（用于服务升级）+group（用于服务隔离、优先级设置等）来确定，这三部分通常在Java中通过Spring IOC注入为一个Bean。其次，我们需要解决服务框架和应用的依赖关系，通常有二种方式：（1）将服务框架做成应用的一个依赖包，随应用一起打包，但不够灵活，修改后需要重新打包，（2）将服务框架作为容器的一部分。最后，对于服务框架和应用的Jar包冲突问题，一般通过自定义类加载器来进行隔离。</p>
<h4>网络通信</h4>
<p>在完成了寻址和路由情况下，需要进行数据发送和通信，这里涉及到序列化与反序列化，这里一方面需要定义协议的通信方式（如HTTP协议）以及序列化协议（XML，Json），此外也应该考虑一些常用的其他特点，如是否支持数据压缩等等。服务端根据服务名称、版本号、方法名称得到具体的服务接口，然后根据参数进行调用，最后把结果返回给调用端。
在具体的网络通信中，有BIO，NIO，AIO方式，其中NIO是一种常用的方式，它也是一种同步调用的方式，采用NIO的方式远程调用的方式如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/serviceNio.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
IO线程用于Socket连接发送数据，发送的数据也会首先放入数据队列。通信对象用于阻塞和唤醒请求的线程，并把结果传递给请求线程或通知超时。
当采用异步调用方式时，常有3三种方式：
(1)Callback回调
如下图所示，调用方将数据放入数据队列后开始继续执行业务，IO线程收到远程调用结果后通知回调对象，然后执行回调方法，回调方法的执行最好在新的线程中，以免执行时间太长。
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/callback.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;
(2)Future：Java中的Future本身支持回调
(3)消息队列：依赖消息中间件来异步</p>
<p>&lt;!-- #### 服务管理
(1)服务隔离
当某些服务执行非常慢时，为避免占用太多资源影响其他服务，可以将某些接口的服务调用进行隔离，使之路由到指定的集群。同样也可以对某些请求用户进行特殊处理，根据需求进行细粒度的服务规则设计。
(2)多机房
当存在多个机房（同城、异地）部署时，为了更快速执行服务调用，可以在服务注册查找中心进行地址过滤，根据不同的调用者提供相同不同的调用者集群；此外也需要考虑不同机房处理能力是否相同，机房是否负载均衡等问题。
(3)流控
为了保证服务系统的稳定性，防止恶意攻击，需要对服务进行流量控制。通常有二种设置方式：简单的0-1开关以及设置阈值（对接口设置不同阈值，也可以对根据不同调用方设置不同阈值）</p>
<h4>服务框架实战</h4>
<p>服务拆分：需要拆分服务往往是通用的基础功能
服务粒度：根据业务需求
分布式环境下请求合并：对于常用的请求，可以将它路由到同样的机器上，然后进行缓存或单机上任务合并（其他现场有同样的任务，可以等待完成，避免重复计算）
服务质量：最好、最差的服务；服务质量趋势
服务容量：服务水位展示与排序、历史趋势图
服务依赖：依赖服务展示、被依赖展示、依赖变化
服务分布：同机房、不同机房、服务负载均衡分布
服务统计：调用次数与排名、出错次数、响应时间统计、趋势
服务查询：容量、质量、次数等等
服务监视：关键数据采集、告警
服务报表：数据统计生成报表
服务上下线：指定服务、指定机器
服务路由：路由规则、管理、回滚
服务限流降级：根据调用来源、具体服务、流控、多版本
服务线程池：线程工作状态、不同业务线程池 --&gt;
&lt;!-- 服务授权：授权信息及规则、多版本支持与回滚 --&gt;</p>
<h2>数据访问中间件</h2>
<p>随着数据量和访问量的上升，数据库也会成为瓶颈，所以需要减少数据库的压力，常用的解决方案主要有三种：（1）对应用进行优化；（2）加入缓存系统和搜索引擎；（3）分布式数据库。然而分布式数据库相对于单机数据库也更加复杂，引入了很多新的问题。</p>
<h3>分布式数据库的挑战与应对方案</h3>
<p>1.垂直/水平拆分的困难
垂直拆分把不同业务数据分到不同的数据库，而水平拆分根据一定的规则把同一业务的数据拆分到多个数据库，但单机数据库的一些特性就不支持了。
(1)ACID事务被打乱，要么修改实现，要么依靠分布式事务
(2)Join操作困难，跨库Join需要特殊实现
(3)外键约束场景收到影响
(4)数据库Id自增生成
(5)水平拆分后同一个表的查询收到影响</p>
<p>2.分布式Sequence处理
当水平拆分后，数据库的Sequecne及自增Id如何保证，这引发了2个问题：Id的唯一性和连续性。对于唯一性可以采用UUID的生成方式，或者根据业务特点使用种子（IP、MAC、时间戳等），但不能保证连续性。为了保证唯一性和连续性，可以将Id统一在一个地方进行管理，即使用Id生成器，所有节点通过Id生成器来获取Id，这种方式当然也存在一定的不足：（1）性能问题，（2）稳定性，单点问题，（3）存储问题，备份容灾</p>
<p>3.分布式数据查询
跨库Join：（1）将Join操作分成多次数据库操作，（2）数据冗余，数据表中增加常用的数据，（3）借助外部系统（搜索引擎等）
外键约束：应用层的判断、容错
跨库常见查询
（1）简单查询：通过条件定位到某个库某个表
（2）复杂查询：先通过条件定位到某些库某些表，然后合并查询结果
（3）排序操作：若从单个库查出来已经有序，直接做一个归并排序；否则在应用层面上需要合并结果后做一个全排序
（4）函数处理：如max、sum、count等，则对每个来源数据分别进行函数处理，然后最后合并
（5）平均值：对所有来源数据先分别进行sum和count处理后，在计算avg
（6）非排序分页：一般有2种；等步长：每页每个数据源数据量相同；等比例：每页中按不同数据源比例不同
（7）排序后分页：相比非常麻烦，必须从每个数据源得到足够的数据</p>
<h3>数据访问层的设计与实现</h3>
<p>数据访问层就是方便应用数据读/写访问的抽象层，在这一层解决访问数据层的通用问题。通常，解决数据访问的方式常有3种方案；（1）专有API方式，但通用性很差，扩展性差；（2）基于JDBC，数据访问层作为JDBC的实现，暴露出JDBC的接口给应用；（3）基于ORM方式，在ORM上再包装一层，实现数据层的功能，对外暴露扔是原来框架的接口。下图展示了这三种方式的结构。
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dataservice.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;
可以看出，基于JDBC成本最高，但兼容性和扩展性最好；基于ORM具备一定的通用性，实现成本相对较低。</p>
<p>下面我们继续分析一下数据层的整体流程，大致的步骤如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/datastream.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;</p>
<h4>SQL解析</h4>
<p>SQL解析主要考虑的问题有2点：（1）SQL的支持程度，是否需要支持全部SQL；（2）支持多少SQL方言。另外SQL解析可以利用缓存来提升解析速度，也需要注意缓存的容量限制。SQL解析后得到一些关键信息，如表名、字段、条件等。</p>
<h4>规则处理</h4>
<p>（1）固定hash算法做规则
该方法通常对某个字段取模，hash规则的设置和实现都比较简单，但是扩容比较复杂，数据迁移很麻烦。
（2）一致性hash算法
该算法增删节点时，影响节点少，数据迁移较少，但很难保证各个节点的负载均衡，可以通过虚拟节点来改进，使得节点负载均衡。
（3）自定义规则
该方法自定义函数来解决数据访问规则，用于解决热点数据访问和不完全符合规则进行补充。</p>
<h4>SQL改写</h4>
<p>数据库分库分表后，需要对SQL进行改写，比如一个表变成多个数据库的多个表，表名、索引名称是否一样；分页操作处理；一些函数操作如max、sum、avg也需要特殊处理。</p>
<h4>数据源的选择</h4>
<p>对于SQL的执行，一方面由于数据库分库分表带来了变化，另一方面也由于数据库的主从备份、读写库、事务等导致SQL的执行必须选择合理的数据源。
数据源的配置一般是三层的结构，当数据库分库分组后，我们使用groupDataSource来进行配置和管理；在分库分组后，再按照数据源的功能进行切分，使用AtomDataSource来管理一个具体的数据库，数据访问三层结构如下图所示。
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/threedatasource.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;</p>
<h4>实现方式</h4>
<p>对于数据访问层对应用的呈现方式，从数据层物理部署来说分为Jar包和Proxy方式，如果采用Proxy方式，客户端应用与数据访问层的协议有两种选择：数据库协议与私有协议，如下所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dbprotocol.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;
数据库协议特点：应用将Proxy当成一个数据库，使用JDBC实现连接Proxy，应用到Proxy，Proxy到DB都采用数据库协议，少了一次协议到对象然后对象到协议的转换，但实现成本高且不能复用。
私有协议特点：实现简单，应用需要一个数据库访问层客户端，并且应用到Proxy的连接可以复用，从应用到数据库底层的整个结构如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dbstructure.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h4>数据读写分离和复制</h4>
<p>1.主从库对称
根据应用特点将数据延迟不敏感的读切换到备库，然后复制时注意延迟
2.主从库非对称
（1）多从对一主库
使用消息系统，如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dbmsg.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
通过消息系统将数据变更通知发出，数据同步服务器获取通知后根据分库规则进行数据复制
（2）主备分库方式不同
在大多数情况下，数据库复制是对等的，但由于业务需求，主数据库和备用数据库并非完全对等复制，即源数据库和目标数据库是不同的实现，如图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dbcopy.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
主库中，根据买家id分库，备库中根据卖家id分库，这样在查询卖家订单时只用在备库中进行查询了，避免了跨库操作，但复制的过程也增加了数据的控制和分发，不是简单的复制了！
（3）数据变更平台
在大型系统中，有一些其他场景也会关注数据的变更，如缓存系统（缓存失效）和搜索引擎（索引建立），可以构建一个通用的平台来管理和控制数据变更，如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dbplatform.png?imageMogr2/thumbnail/!50p" alt="img">
&lt;/center&gt;
在系统中引入Extractors与Applier，其中Extractors把源数据变更信息加入数据分发平台，而Applier把变更通知应用到目标上，数据分发平台由多个管道组成。</p>
<h4>数据平滑迁移</h4>
<p>对于无状态的应用，扩容和缩容比较容易，而对于数据库，扩容缩容会引起数据的迁移。若允许停机操作，处理相对容易，若不能停止，就比较麻烦了，因为迁移的过程中可能有新数据的变化。可以采取以下方案：
（1）开始进行数据迁移，并记录数据库的数据变更增量日志
（2）数据复制到新库，也有新的更新记录下来
（3）全量迁移结束后把增量日志数据也迁移进来，此时还会有新的增量日志，这是一个逐步收敛过程
（4）进行数据对比，记录源库和目标库不一样的数据
（5）停止需要迁移数据的写操作，增进增量数据处理，使得新库数据是最新的
（6）更新路由规则，所有新数据到了新库，完成迁移操作</p>
<h3>总结</h3>
<p>随着数据量、访问量的增加，我们会进行分库和分表，这也带来了一些共性的问题。数据访问层正是为此为应用提供统一的接口。整个数据层的结构如下图所示，应用层有多种选择，代理层除了可以使用DB的native API方式外，也可以像应用一样使用各种方式来工作。从应用到DB就是一个链式处理过程，这一过程中大多数的组件都是对外提供JDBC的实现，方便各个组件进行替换。
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/dbArch.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h2>消息中间件</h2>
<h3>初始消息中间件</h3>
<p>消息中间件给应用带来了异步、解耦的特性，下面我们从一个具体的例子来看消息中间件的如何做到应用解耦。
假如有一个应用登陆系统，主要功能是，用户登陆成功后发送一条短信到用户手机，然后把用户登陆信息录入安全系统进行处理，此时的系统的结构示意图如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/mqdirect.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
但是如果还需要增加别的功能，就会反复修改登录系统来进行其他调用，这种直接调用非常不便维护和扩展。我们仔细分析可以看出，登录系统并不依赖于短信服务和安全系统服务，恰恰相反后者依赖与前者，如果引入消息中间件则可以将上面的结构解耦，通过消息传递来替代服务调用。登录系统不用关注有多少系统关注登陆成功事件，也不用关心如何通知，只需要往消息中间件发消息，其他系统订阅消息，系统之间互不干扰，系统结构示意图如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/mq.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h3>消息中间件的关键点</h3>
<p>在介绍消息中间件之前，我们先了解一下JMS（Java Message Service），它是Java EE的一个消息规范，ActiveMQ也是这个规范的具体实现。在消息中间件的设计中，有一些非常重要的因素需要保证，其中有消息的顺序保证、可靠性、扩展性、消息发送与业务操作的一致性、多集群订阅者等，下面我们分别分析这些方面。</p>
<h4>消息发送一致性</h4>
<p>消息一致性是指消息发送与产生消息的业务操作一致，若业务操作成功，则消息要发送出去；业务失败则消息不应该发出。在JMS中，基于XA系统的接口，利用了分布式事务来保证消息一致性，但JMS也存在一定的弊端：（1）分布式事务开销大，复杂性高；（2）业务操作的资源必须支持XA协议，才能与发生消息一起做分布式事务。
既然JMS的XA协议比较不适应，那么我们可以设计一种解决方案，该方案对正常流程影响小，在出现问题后能够解决问题，即使用最终一致性的解决方案，如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/mqc.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
步骤如下：
（1）业务应用首先把消息发送给消息中间件，标记消息状态为待处理
（2）中间件收到消息把消息进行存储，并不投递消息
（3）消息中间件存储后返回消息存储结果
（4）业务收到中间件结果进行处理，若失败则放弃执行业务，若成功则执行业务
（5）业务操作完成，将业务结果发送给消息中间件
（6）消息中间件收到业务执行结果进行后续处理，若业务失败则删除消息；若成功则更新消息为可发送，然后进行消息的投递
在这些过程中，难免会存在很多异常，那么我们分析下每一步异常可能导致的后果：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/mqexception.png?imageMogr2/thumbnail/!50p" alt="img">
&lt;/center&gt;
由此可以看出，主要的异常有三类：
（1）业务未执行，消息未存储
（2）业务未执行，消息存储，状态待处理
（3）业务执行，消息存储，状态待处理
第（1）种是正常情况，而后面两种需要中间件去主动询问业务执行情况，然后业务检查执行结果进行反馈（成功，失败，等待，等待表示业务还在执行中），该过程称为反向过程，是一个补偿方案，用于解决不一致的情况，如下图所示：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/mqback.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
当然，该反向补偿方案也会存在异常，但前三步都是查询操作，不影响状态，最后一步更新失败可以重试，也没有特别大错误。所以，正向和反向的结合，保证了最终的一致性状态。该方案相比传统的方式不同之处如下：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/mqcompare.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;
可以看出，该方案相比传统的方案之多出了2步，所以额外开销并不是很大。</p>
<h4>消息中间件与应用的依赖问题</h4>
<p>在保证业务操作和发送消息的一致性方案中，我们更多关注了如何解决一致性问题，但是也导致了一个问题，消息中间件成为了业务应用的必要依赖。一旦消息中间件不可用，即使业务应用正常也将无法继续进行，可以采用的一个方案：将消息中间件中影响业务操作的部分的可靠性与业务自身可靠性相同，业务成功消息必须入库，即使中间件出现了问题，可以接受延迟，但是必须保证消息入库。可行的一种设计思想如下：
&lt;center&gt;	
<img src="http://oqcre1dsl.bkt.clouddn.com/appmq.png?imageMogr2/thumbnail/!35p" alt="img">
&lt;/center&gt;
将中间件的消息表与业务数据表放在一个数据库中，从而将业务操作与写入消息作为一个本地事务完成，然后通知消息中间件有消息可以发送，但这一步在图中是虚线，表示它并不是一个必要操作，中间件可以定时去轮询消息表，找到发送的消息。但该方式也有3个不足：
（1）需要业务数据库承载消息
（2）消息中间件需要访问业务数据库
（3）业务操作的对象是数据库，必须支持事务的存储，这个存储也必须支持中间件
基于上述方式，我们进行改进，消息中间件不再与业务数据库打交道，完全由业务应用控制消息生成、重试，消息中间件更多只是接受消息并进行投递，如下图所示：
<img src="http://oqcre1dsl.bkt.clouddn.com/appmqd.png?imageMogr2/thumbnail/!35p" alt="img">
&lt;/center&gt;
这两种方式虽然能解决大部分问题，但都依赖于支持事务的数据库，具有局限性，可以将本地磁盘作为消息的存储，消息中间件不可用时可以将消息存储在本地磁盘，等中间件恢复后再将消息发送到中间件，这样消息的管理、重试等也是在中间件进行，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/appmqf.png?imageMogr2/thumbnail/!35p" alt="img">
&lt;/center&gt;
但是若中间件不可用，写入本地磁盘也出错，则消息丢失了，需要补偿机制。本地磁盘作用有2个：（1）消息的容灾，（2）保证业务操作和存储消息的时间，也便于应用与消息中间件之间做一些批量处理，提升效率。</p>
<h4>消息模型对消息接收影响</h4>
<p>在JMS中，消息模型有Queue（点对点）和Topic（发布/订阅）两种，下面我们分别看一下两种模型的特点。
1.Queue模型
在Queue中，消息根据到达顺序形成一个队列，所有连接到Queue上的应用共同消费了所有的信息，一个消息只能被一个应用去消费，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mqqueue.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
2.Topic模型
Topic和Queue区别在于，每一个消息接收方可以接受全部消息，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mqtopic.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
现实业务中，常见的业务需求有：（1）消息发送方和接收方都是集群；（2）一个消息需要被不同集群消费；（3）一个消息在一个集群中只能被消费一次
在JMS中一个进程可以有多个Connection，支持发送方和接收方都是集群，但是Topic和QUeue都难于保证一个消息只能被同一集群的某个节点消费，所以需要一种混合的方式。具体来说把Topic和Queue的特点结合起来，同一集群使用一个clusterId来消费消息，具体方式如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mqmix.png?imageMogr2/thumbnail/!50p" alt="img">
&lt;/center&gt;</p>
<h4>消息订阅模式</h4>
<p>消息订阅模式分为持久/非持久方式。
非持久模式：消费者应用退出后，消息不会为消费者保存，消费者应用启动后又可以重新消费消息了。
持久订阅：消费者应用退出后，消息会保存下来，除非消费者应用取消订阅，消费者重启后会将消息不遗漏的发送消费者。
可以看出，持久订阅是一种可靠的消息订阅模式。</p>
<h4>保证消息可靠性</h4>
<p>在持久订阅模式下，保证消息的可靠性对于消息中间件至关重要。我们知道，消息从发送端到接受端主要有3个过程：（1）消息发送者-消息中间件；（2）消息中间件对消息进行存储；（3）消息中间件将消息投递给消息接受者，所以必须保证这三步都可靠，才能保证整个消息的可靠，下面分别从这三方面进行介绍。
1.消息发送端的可靠性
消息从发送者到中间件，只有当中间件及时、明确地返回成功才意味消息到达了中间件，返回错误、超时等情况都是发送动作失败。这里要注意中间件返回到异常被内部消化而没有发现异常。
2.消息存储的可靠性
消息存储采用的存储系统有很多，如关系型数据库、分布式文件系统、Nosql等，这些产品各有特色适用不同的场景下。
（1）文件系统
分布式文件系统的稳定性和性能有待提升，对于消息的检索也是不支持的，但消息直接存储在本地不需要额外的存储，针对机械硬盘的特点尽量进行顺序写和顺序读。此外，当消息被消费时，文件容易存在“空洞”现象（类似GC中的内存碎片），需要额外的整理操作。对消息的检索处理也需要考虑索引对内存消耗。
（2）关系型数据库
再利用关系型数据库进行消息存储时，数据库的设计会十分复杂，不会遵循常见的数据库范式设计，常采用数据冗余的方式实现。数据冗余避免了表关联查询，也需要考虑数据的备份和容灾。
（3）双机内存的消息存储
基于文件系统和关系型数据库的方式，系统性能受到限制，所以可以采用混合的方式进行存储和管理，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mqmemory.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;
采用双内存的方式来保证数据可靠性，正常情况下消息持久存储不工作，当一台机器故障时，则停止另一台机器的写操作，然后将数据写入磁盘永久存储。只要不遇到两台机器同时故障，而且一台故障另一台写入持久存储错误时，消息是可靠的。这种方式适合消息存储在中间件后被及时消费的情况，能很好提升性能。
（4）消息系统的扩容
	-消息中间件自身扩容
	消息中间件没有持久状态，扩容相对容易。主要让发送者和接受者能够感知有新消息中间件加入到集群中，这是通过软负载中心实现的。不同的消息中间件可能共用存储，也可能使用不同的存储，如下图所示：
	&lt;center&gt;
	<img src="http://oqcre1dsl.bkt.clouddn.com/mqstore.png?imageMogr2/thumbnail/!45p" alt="img">
	&lt;/center&gt;
	-消息存储的扩容
	消息的存储一方面不用保证消息有序；另一方面提供了服务端对消息的投递，不支持主动获取消息。
	在数据访问层提到了数据库的分库分表、路由规则等，但消息中间件不需要支持外部主动去查询消息，因为发送者发送消息到中间件时，中间件肯定知道消息存储位置，投递时也知道消息在哪。
3.消息投递的可靠性
这一步需要保证消息中间件收到接受者处理信息完毕的信号才能删除消息，不能根据网络层判断消息是否已经送达，一定要从应用层入手。此外接受者在处理消息异常时 ，不要吃掉异常而返回成功，这样会丢失消息。
此外，投递消息时为了提升效率可以采取多线程的方式，将投递消息和处理返回结果线程分开，投递线程只投递消息，投递完一条消息继续投递其他消息，处理结果返回后再由处理线程处理。另一个优化地方，对同一一个应用的多个模块订阅同一个消息，中间件可以避免多次投递消息，仅投递一次消息到应用，由应用在应用内复制消息提示消息投递性能。</p>
<h4>消息重复</h4>
<p>消息重复的原因有二类：发送端重复发送消息和中间件重复投递消息
1.发送端消息重复发送
该步骤原因有二种：（1）发送端发送消息到中间件，中间件此时故障未返回消息，导致重复发送；（2）中间件返回结果超时（中间件负载高、网络延迟等），发送端重复发送消息，该问题可以通过在发送端产生消息Id来解决。
2.中间件重复投递
该步骤主要原因有2个：（1）消息中间件投递消息后未收到应用反馈结果（应用故障、中间件故障、网络问题）（2）中间件投递后超时了，中间件重试，该问题比较复杂，在中间件处理重复消息比较困难，常用做法是在消息接受端处理重复消息，也就是保证消息幂等性（多次执行得到同样结果），但这也给接受端应用带来了复杂设计。
消息接受者对消息接受一般会出现at least once 和 at most once两种，exactly once较难保证，需要额外处理，十分复杂。</p>
<h4>消息投递其他属性</h4>
<p>1.消息优先级
一般消息是先到先投递，为了对消息进行优先级处理，可以根据设置消息的优先级属性，也可以把消息设计不同的类型，同一类型的消息在根据优先级进行不同处理。
2.消息处理顺序和分级订阅
一般情况下，多个消息订阅者之间互不干扰，但有时需要维持消息订阅者处理消息的顺序，这种情况下一方面可以设置优先处理消息的订阅者集群Id，即消息订阅者处理消息顺序，另一方面也可以分级处理，优先接受者处理消息成功后再把消息放入其他中间件，然后其他订阅者再处理，但这样重复发送了消息，多了一次消息入库操作。
3.自定义属性
一般出了消息自身的创建时间、类型、投递次数等属性，一些自定义的属性如消息过滤等对消息的特殊处理带来很多便利
4.消息局部顺序
局部顺序性是指部分消息之间有处理顺序，但全局的消息之间没有顺序。如商品的购买-付款-发货，某一具体商品三个消息之间有顺序，但任何两个商品的消息之间无任何顺序，所以需要在消息上设置一个属性，来表明该消息与那些消息有顺序。</p>
<h4>保证顺序的消息中间件</h4>
<p>在某些场景下，我们需要一种高效的支持顺序的多集群订阅消息中间件实现，如数据变更通知平台。在这种消息顺序场景下，接受端的设计也从Push模式改成Pull模式，这是为了方便接受者更好控制消息的接受和处理，中间件的设计如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mqorder.png?imageMogr2/thumbnail/!45p" alt="img">
&lt;/center&gt;
具体实现中，消息存储顺序的写入本地文件，但不存在文件空洞，因为消息是按顺序去消费的。接受端维护一个指针指向当前处理的消息，不同消费者维护各自的指针，并通过回溯指针重复消费消息，中间件更多关注消息的可靠性，消费者灵活控制消息的消费。</p>
<p>但当单机队列过多时，消息写入接近随机写入了，性能有明显的下降，改进思路是将消息进行顺序写入然后在每个队列上建立索引，每个队列索引是独立的，索引保存了存储数据的物理队列的位置，这样带来的好处有：（1）队列轻量化，每个队列数据量少；（2）磁盘访问串行化、避免磁盘竞争，不会导致IO等待增加
虽然消除了随机写但也带来了问题：（1）写是顺序写，但读确实随机读；（2）读消息时，先读逻辑队列在读物理队列增加了开销；（3）需要保证逻辑与物理队列一致，编程复杂
为了解决消息的可靠性，一般需要考虑消息的复制问题。一般有2种复制方案，同步和异步。
	（1）将消息中间件变为Master/Slave节点，Slave订阅Master的消息，进行消息的备份，该复制是一个异步的操作，Slave可能存在消息丢失风险
	（2）Master/Slave同步复制，Master收到消息也往Slave发送，收到Slave成功响应后返回成功给发送端，该方式更可靠
保证消息可靠后，也需要保证消息的扩容，在顺序情况下，扩容更加复杂。基本思路是发送端知道消息需要写入新的消息队列，消费者知道去新的队列获取消息。主要的关键点有：
	（1）队列扩容有有一个标志，即使有新的消息过来也不再接受
	（2）通知消息发送端新队列的位置
	（3）消息接受端在消费消息时，队列上有新旧两个位置，旧队列接受完毕后，去新队列接受消息，完成新旧位置切换</p>
<h4>Push和Pull方式对比</h4>
<p>消息中间件Push和Pull实现方式的对比如下：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mqpushpull.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h2>软负载中心与集中配置管理</h2>
<p>在服务框架中，我们利用服务注册查找中心来定位服务器的地址；同样在消息中间件中，消息发送端和接受端也需要感知中间件服务器；这些都需要软负载中心来实现。可以看出软负载中心的最基本功能：
（1）聚合地址：软负载中心聚合地址列表，供使用方使用
（2）生命周期感知：软负载中心需要能够对服务器的上下线自动感知，并更新服务地址数据</p>
<h3>软负载中心结构</h3>
<p>软负载中心主要包含服务端和客户端两部分。
服务端负责感知提供服务机器是否在线，聚合提供服务机器的信息并传给使用的应用；
客户端主要有2个功能：（1）作为服务提供者，把服务提供者的信息主动传给服务器，并且随着信息变化去更新数据通知服务器；（2）作为服务使用者，从服务器获取需要的数据并更新数据，并进行本地缓存，提高效率和性能。下图展示了软负载中心与应用的关系：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/loadbalance.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
可以看出，软负载中心内部主要有三部分重要数据：
（1）聚合数据
聚合后的地址信息列表，在软负载中心内部使用dataId来标识一个服务信息，同样的dataId支持分组（group）信息，则可以形成一个二维的结构，（dataId，group）可以定位到唯一的数据内容，在内部是一个key-value结构。
（2）订阅关系
对于需要数据的应用，需要把（dataId，group）信息告诉软负载中心，所以软负载中心维护了（dataId，group）到应用分组（consumerGroupId）列表的映射关系，一旦数据发生变化则通过映射关系找到通知的应用。
（3）连接数据
连接数据是指应用和软负载中心建立连接的管理，每一个应用都有一个groupId，连接数据使用这个groupId作为key来管理该连接，通过连接来传递数据。</p>
<h3>内容聚合功能</h3>
<p>内容聚合主要工作有2个：保证数据正确；高效聚合数据
（1）保证数据的正确性
内容聚合主要保证并发场景下的数据聚合正确性，可以使用ConcurrentHashMap来保证数据的正确性。另一方面也需要考虑机器短时间内上下线问题等异常场景，数据的修改变化主要有新增、更新、删除操作，这里尤其需要注意网络断开后删除数据与新增数据的先后关系，比如发布了数据后马上下线，这时如果先删除数据再增加数据肯定会导致错误，所以数据的顺序性需要仔细考虑。
（2）性能保证
在保证数据安全的前提下，更新操作的性能也是需要考虑。虽然ConcurrentHashMap有较好的性能，但是在大量修改数据情况下有大量的线程并发冲突，并不难保证较高的性能。所以可以考虑一个改进方案，我们可以把对同样的数据修改在同一个线程中处理，即对同样的（dataId，groupId）放在一个队列中，该队列是一个线程安全的容器，然后用同一个线程来从队列取数据进行更新操作，那么整体上一个线程处理同样的数据，减少了线程冲突提升了性能。</p>
<h3>服务上下线感知</h3>
<p>软负载中心判断服务器是否可用的方式主要有两种。
（1）客户端与服务端的连接感知
软负载中心与应用之间通过长连接保持通信，通过心跳来判断服务是否在线，但该方法有一定缺陷。当软负载中心负载很高时会产生误判，将服务下线，或者网络通信故障也会导致软负载中心误判。此时可以通过服务调用方服务提供者来进一步确认。
（2）通过地址和端口进行连接检查
该方式是一种补偿的方式，通过一个监控应用去连接服务器的地址和端口，进行进一步的确认，该方法同样也存在网络通信故障缺陷，还是需要应用调用发和应用提供方通信做进一步检查。</p>
<h3>软负载中心的数据分发设计</h3>
<p>（1）数据分发与消息订阅的区别
数据分发目的是保证数据订阅者能够收到可用的服务地址列表，消息订阅是使得每一条消息都能被获取，二者区别主要有两条。
-消息中间件的消息订阅需要保证每一条消息都送到订阅者，软负载中心只需要保证最新的数据送到订阅者，并不需要保证每次的变化都让订阅者感知。
-订阅者集群的分组。消息中间件中所有集群共享消息，每一条消息都只需要被一台机器消费；软负载中心需要分发消息到所有的订阅者
（2）提升数据分发性能
	-数据压缩：降低流量、节省带宽
	-全量与增量：数据变化时，需要发送最新数据到订阅者。全量发送实现简单，效率低；增量实现复杂，效率高</p>
<h3>针对服务化特性的支持</h3>
<p>（1）软负载分组
通过（dataId，group）唯一确定数据，使用group目的是把相同的dataId内容分开，相当于多了一个namepspace，可以应用于不同环境的隔离（测试，线上）以及分优先级的隔离
（2）上下线开关
机器的上下线，需要由软负载中心来控制，主要的目的有2个：
	-优雅停止应用：直接停止服务会导致正在执行的任务失败，应当从服务列表去除机器，然后执行完当前的任务在停止应用
	-应用排错：当服务出错时，可以把出错的机器下线，以免新的请求进来
（3）维护管理路由规则
路由规则需要由软负载中心来统一管理。</p>
<h3>软负载中心集群</h3>
<p>当应用规则不大时，利用单机加备份机器可以充当软负载中心，但随着应用集群规模扩大，单机的推送数据能力有限，需要一个集群来处理。从单机到集群也引入了新的变化，集群需要处理2类问题：数据管理问题和连接管理问题，解决方案也有数据统一管理方案和数据对等管理。
（1）数据统一管理
该方案把数据聚合放在一起，这样负责管理连接的机器可以是无状态的了，方案如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/datacenter.png?imageMogr2/thumbnail/!30p" alt="img">
&lt;/center&gt;
系统分为三层：聚合数据这一层负责管理数据；软负载中心负责管理连接，并且这层机器都是对等的。这里可以做一个改进，把软负载中心的职责分开，即把数据聚合和数据推送分开，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/datadepart.png?imageMogr2/thumbnail/!30p" alt="img">
&lt;/center&gt;
这样发布者和订阅者的连接是分开的，更精细能够提升性能，在负责推送的机器上也可以做缓存。但这两种方式都必须保证“聚合数据”这一点必须可用。
（2）数据对等方案
该方案将数据分散在各个软负载中心节点上，并相互之间进行数据复制和同步，如下图所示。但该方式同步开销太大，实现中可以间隔一定时间进行批量同步。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/datap2p.png?imageMogr2/thumbnail/!30p" alt="img">
&lt;/center&gt;
同样，也可以将软负载中心节点职责分开，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/datap2pd.png?imageMogr2/thumbnail/!30p" alt="img">
&lt;/center&gt;
数据聚合节点之间没有关系，数据分发节点之间也没有关系，但数据聚合节点会将数据分发给数据分发节点，这种方式可以提升效率。但如果数据量很大时，单个节点无法存储所有数据，则需要按照（dataId，group）进行分组管理，这样的话应用可能根据情况连接多个数据分发节点来获取需要的数据，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/datap2pf.png?imageMogr2/thumbnail/!35p" alt="img">
&lt;/center&gt;</p>
<h3>集中配置管理中心</h3>
<p>软负载中心负责管理服务地址列表、路由规则、消息订阅关系等，这些数据可以按照是否持久以及是否需要聚合两个维度进行分类。其中持久是指数据本身与数据发布者的生命周期无关，如消息订阅、路由规则、数据库访问分库分表等，非持久则数据本身与发布数据者生命周期有关，如服务地址列表；聚合是指数据是否需要合并，如地址列表，订阅关系等需要合并。具体来说可以分为：持久/聚合、持久/非聚合、非持久/聚合、非持久/非聚合4类。
软负载中心用于管理非持久的数据，集中配置中心用于管理持久数据，它们都可以支持数据的聚合。集中配置管理比较关心数据的可靠性、稳定性，然后进一步考虑数据分发的性能。
集中配置管理的大致结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/centerconf.png?imageMogr2/thumbnail/!30p" alt="img">
&lt;/center&gt;
通过主备方式来保存持久数据，集中配置管理这一层由多个对等的节点构成，它们负责提供数据给应用也负责数据库的更新。在单个节点中，有Web应用和Nginx构成，Web应用主要负责相关的程序逻辑，单机文件（Local File）为了容灾和提升性能，客户端通过Nginx直接从本地文件获取数据。
集中配置中心的主要提供的功能有2个：
（1）提供客户端给应用：应用通过客户端来读取配置信息
（2）为控制台提供SDK：SDK支持数据的读写，进行配置的修改
下面我们具体看一下集中配置中心的容灾策略。</p>
<h4>客户端实现和容灾策略</h4>
<p>客户端通过HTTP协议与集中配置管理中心进行通信，考虑到服务端的压力，轮询间隔不能太短，但太长会影响数据的实时性。所以可以改进普通轮询，使用一种长轮询的方式，该方式特点如下：建立连接后，如有数据，长轮询与普通轮询直接返回，若没有数据，普通轮询直接返回，而长轮询会等待数据直到超时，然后重新建立连接。长轮询相对普通轮询实时行好，但是需要不断建立连接，这时相对Socket长连接的弱点，是在降低服务器负载下的一个折中方案。
对于容灾，客户端提供了4个特性：（1）数据缓存：缓存一方面提高了效率，另一方面在服务器不可用情况下也保证系统可用，但数据实时行不高；（2）数据快照：数据快照保存了最近的几次更新数据，比缓存的数据旧一些，但保存了最近的几个版本，可以在服务器和缓存均不可用时提供数据，也可以用于数据恢复。（3）本地配置：应用需要使用服务器给的配置工作，本地配置保存了这些配置，在服务器不可用时，本地配置优先级最高。（4）文件格式：在最坏情况下，系统退化为一个单机应用，需要直接修改配置数据，那么配置文件的格式十分重要了。</p>
<h4>服务端实现和容灾策略</h4>
<p>在集中配置管理中心中，Web应用中实现了主要的业务逻辑，Nginx用于请求的处理和结果的返回，供返回的数据都在本地文件系统中。通过Nginx直接返回本地文件中的数据比通过Web应用从数据库获取数据快很多，能够明显提升系统吞吐量；此外本地文件也可以用于数据库的容灾。
服务器端也需要考虑数据的同步问题，主要有2个方面：（1）当有数据更新时，通过SDK请求服务端更新数据库，并且同时更新本地文件，也要通知其他集群更新数据；（2）定时检查服务端数据是否与数据库数据一致，确保本地文件与数据库数据一致，也需要保证数据更新通知不能送达其他服务器时，服务器需要定时检查本地文件与数据库数据是否是一致的。</p>
<h4>数据库策略</h4>
<p>数据库一方面需要保证主备方式来达到容灾目，另一方面需要支持配置的版本管理，方便配置对比及配置回滚。</p>
<h2>大型网站其他要素</h2>
<p>大型网站的发展中，虽然中间件起到了十分关键的作用，软负载中心和集中配置管理中心也起到了桥梁的作用，但还有一些其他的组件也至关重要，下面我们列举一些常见的组件。</p>
<h3>CDN</h3>
<p>CDN（Content Delivery Network）内容分发系统，CDN将用户需要的内容分发到离用户近的地方，这样可以使用用户能够就近获取所需要的内容，提升效率。CDN系统分为CDN源站和CDN节点，源点提供数据源头，节点一般部署在离用户比较近的地方，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/cdn.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
CDN本质是一种网络缓存技术，把一些先对稳定的资源放在离用户比较近的地方，节省带宽，提升网络速度，一般把静态文件（图片、视频、JS、页面框架）放在CDN中。下面我们看一下有无CDN的访问过程区别。
无CDN时，浏览器访问网站过程如下：
（1）用户向浏览器提交域名；
（2）浏览器对域名进行解析，得到IP地址
（3）浏览器向IP地址发送请求
（4）浏览器获取返回数据，进行渲染
加入CDN后，访问网站的过程发生了变化，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/cdnrequest.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
（1）用户提交访问域名
（2）浏览器进行域名解析，CDN对域名解析进行调整，得到域名对应的CNAME记录
（3）对CNAME再次进行解析，得到IP。这一过程使用全局负载均衡DNS解析，根据地址位置信息以及所在的ISP来返回结果，让不同地区不同接入商的用户得到最适合的CDN
（4）得到IP发起请求
（5）CDN根据请求内容是否在本地缓存进行不同处理：若在直接返回，否则CDN请求源站获取内容后返回
可以看出CDN几个关键技术：
（1）全局调度：这一步需要根据用户区域，接入运营商，以及CDN负载情况进行调度
（2）缓存技术：CDN缓存需要保证有足够多数据，当没有命中的时候去源站获取数据可以进行合并批量操作来加快速度；此外缓存预加载也是一个提高命中率的办法
（3）内容分发：对CDN的数据进行管理，数据的分发效率和一致性问题
（4）带宽优化：CDN流量很大，节省带宽和数据压缩等</p>
<h3>存储支持</h3>
<p>在大型网站中，存储系统是一个很重要的支撑系统，大型网站刚开始一般从关系型数据库开始，关系型数据库建立在key-value基础是那个，但仅仅使用关系型数据库并不能满足存储需求。</p>
<h4>分布式文件系统</h4>
<p>对于图片、文本的存储，使用关系型数据库就不再适合了，一般采用分布式文件系统。常见的分布式文件系统有Google的GFS以及Java版本的HDFS等，解决了单机文件系统存储及安全性问题，把多台机器组成一个分布式文件系统，提供文件系统服务。</p>
<h4>NoSQL</h4>
<p>处于分布式文件系统和关系型数据库之间的数据库系统都可以被称为NoSQL；NoSQL和SQL都是基于key-value发展而来，下面我们看一下常见的数据库系统。
（1）Key-Value
这是最基础的技术支撑，但不支持高效的范围查询
（2）Ordered-Key-Value
这是对Key-Value的一个改进，Key是有序的，可以解决范围查询效率问题。
（3）Big Table
Google的结构化数据的分布式存储系统，对Value进行了Schema支持，Value由多个Column Family组成，Column Family内部是Column。Hbase是对BigTable的一个开源实现。
（4）Document
Document数据库可以在Value中自定义复杂Scheme，不再是简单的Map嵌套，同时有支持索引和全文搜索。
（5）Graph
支持图结构的数据模型。</p>
<h4>缓存系统</h4>
<p>缓存系统是一种非持久的存储，为了加速对数据的读取。开源的缓存系统有Redis和Memcache，可以降低对底层数据库的读压力。但缓存系统需要注意缓存和数据库一致性的问题。
大型网站系统中缓存的另一种重要场景是对Web应用的页面渲染内容缓存，相对静态的内容可以进行缓存，不用每次进行渲染，具体实现技术有ESI等。</p>
<h3>搜索系统</h3>
<p>当网站规模较小时，一些查询可以依靠数据库的Like查询来实现，但这种查询效率较低，也不够智能，随着数据量的增大，需要使用搜索技术来解决查询问题。</p>
<h4>倒排索引</h4>
<p>倒排索引是搜索引擎中一项重要技术，倒排是相对于正向索引来说。正向索引的key为文章id，value为文章的单词，而倒排索引的key为单词，value为文章id，所以当需要搜索关键词时，倒排索引十分方便。但也要需要设计如何分词，即key的选取问题，需要根据设计需求合理设计。</p>
<h4>查询预处理</h4>
<p>预处理需要对用户输入的搜索内容进行分词，然后进行一些预处理包括同义词替换纠错等。</p>
<h4>相关度计算</h4>
<p>再经过查询分析处理后，搜索引擎会返回处理的结果，但同时也需要对搜索的结果进行排序，这里需要计算结果的相关度，相关度有向量空间模型、概率模型等。</p>
<h3>数据计算支撑</h3>
<p>再解决了数据的存储后，需要解决的问题是数据计算，从实时行角度来看，计算分为离线计算和实时计算。</p>
<h4>离线计算</h4>
<p>离线计算是业务产生的数据离开生产环境后进行的计算。把数据从生产环境移动到离线存储中，然后进行数据处理的过程，实效性较差，延迟高。MapReduce是著名的离线计算模型，包含了map和reduce两个阶段，Hadoop是MapReduce的一个开源实现，利用了HDFS进行存储，而Spark则基于内存的集群计算，效率更高。</p>
<h4>在线计算</h4>
<p>在线计算是一种实时的计算模型，比较常见的方式是流式计算，如Strom。</p>
<h3>发布系统</h3>
<p>当完成应用的开发和测试后，需要对应用进行上线来提供服务。当需要管理的应用服务器很多时，如何保证发布过程不影响用户体验，如何支持灰度发布时就十分复杂了。发布应用时关键的几个要点如下。</p>
<h4>分发应用</h4>
<p>我们首先需要高效地把程序包分发到线上机器中，这一过程如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/appdispatch.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
在多机房情况下，我们考虑在每个机房都部署发布服务器，由发布服务器负责本机房的程序包分发，发布控制台可以将程序包分发给任意一台发布服务器，由发布服务器之间相互分发，也可以将程序包分发给所有机房的发布服务器。另一方面，当应用服务器过多时候，可以采用P2P技术进行程序包的分发，加快分发速度。</p>
<h4>启动校验</h4>
<p>当完成程序包的分发后，需要停止当前的应用程序并启动新的应用程序。新应用程序包启动后，需要进行校验，一般通过校验脚本来判断返回结果是否正确。
在停止应用时，若采取暴力的方式，会影响当时正在执行的请求服务，所以需要首先控制不让新的请求进来，在完成所有请求后再关闭应用。这里一般通过软负载均衡中心来完成，首先从软负载中心移除设备然后优雅关闭应用，当新的程序启动校验后，再把机器加入软负载中心，进而提供服务。在控制应用下线、重启、上线时，需要保证整个集群的可用机器数量，否则可能导致可用机器无法承受负载，所以操作的应用服务器比例一定是要支持可调的。</p>
<h4>灰度发布</h4>
<p>应用虽然进行了严格的测试，但为了保证万无一失，还是需要进行灰度发布，即对应用进行分批发布，逐步扩大新应用在整个集群的比例直到最后全部完成，并在灰度发布中记录关键数据、状态。</p>
<h3>应用监控</h3>
<p>应用上线后，需要对应用的运行情况以及出现问题进行监视和控制。
（1）数据监视维度：系统数据（CPU、内存、IO等）和应用自身数据（调用次数、成功率、响应时间、异常数量）
（2）数据记录方式：进行监视的数据，需要考虑被采集数据的记录方式。系统自身数据记录到本地磁盘，应用数据记录在应用自身的目录中，也可以把应用日志通过网络发送到采用服务器情况，以此来减轻本地写日志压力，在写日志时可以批量写入，间隔一段时间统计。
（3）数据采集方式：监控中心获取集群中各个服务器的数据有二种方式。服务器自己推送数据到监控中心，需要考虑监控中心的负载能力；监控中心从服务器拉取数据。
（4）展现与告警：采用图表提供Web展示，根据告警条件和接受人进行告警，通过短信、手机APP来告警。除此之外，需要对应用进行监控，出现问题时可以通过重启应用解决，更精细化的做法可以进行降级。降级是指遇到大量请求且不能扩容时进行功能限制。</p>
<h3>依赖管理系统</h3>
<p>在大型的分布式系统中，系统中有各种各样的应用集群，这些集群和底层系统之间有相互的依赖关系，随着网站功能的增多，应用之间的关系也越来越复杂，理清这些依赖关系并进行管理十分重要。首先，我们需要知道应用在完成某个功能时依赖那些系统，也需要知道哪些是强依赖哪些是弱依赖。</p>
<p>依赖的检测有静态和动态两种方式。静态检测分析应用的代码调用情况获取依赖关系，但不能检测出依赖的强弱性；动态监测在运行阶段监测功能调用关系，并可以进行强弱依赖的检测。Google发表的论文Dapper中，通过一种更细粒度的方式检测应用依赖情况，应用调用时都会传递一个traceId，以此来构造应用调用链。</p>
<p>对于依赖的控制，主要通过白名单和黑名单机制完成，应用的识别通过IP和应用名完成，另外也可以通过密码的方式进行应用的鉴权。</p>
<h3>多机房问题</h3>
<p>多机房主要用于容灾，以及改进不同区域用户访问速度，有同城机房和异地机房。
同城的机房主要用于容灾，突破但机房集群规模限制。对于数据库系统，则会把主备放在不同的机房，当主数据库故障时，需要进行主备切换；此外在软负载中心也需要尽量避免跨机房调用。
异地机房比较难于处理，两地间通信延迟较高。首先把数据同步到异地机房，把一些数据延迟不敏感系统部署到异地，一般是一些只读的系统，这样便于异步的用户快速访问应用。最后将写应用也放在异地，这一步是最复杂的。</p>
<h3>系统容量规划</h3>
<p>有了监控的依赖管理系统，能够及时发现问题并进行补救，但还需要知道系统的容量和水位。我们把系统的能够提供的并发能力和当前的压力分别称为容量和水位。知道各个系统的容量和水位是一件很重要的事情，希望通过扩容来支持更多的请求，而不是降级方案。</p>
<p>容量的测量是一个基础的工作，最终希望能够预测系统的容量增长曲线，以便规划服务器数量等来降低成本，当然预测准确十分困难，需要结合过去的增长规律和人为判断。当然也需要弄清楚以下几件事情：（1）系统的高峰期水位；（2）各个系统的容量；（3）设置警戒线，水位高于警戒线就增加容量。其中，系统水位通过监控系统得到数据，系统的容量需要通过测试来获取。首先需要保证依赖的服务系统不是瓶颈，测试时也需要贴近用户的真实请求，注意观察系统的响应时间。
对于提供服务的应用，通过负载均衡设备使得单台服务器承受更多的请求，注意处理时间的变化，一旦时间很长说明负载很大，我们通过单机容量来计算整个集群的容量，但这些是对于无状态服的测量，但对于数据库等有状态的服务，放大请求量是一个可行的方案，将一次读取重复多次，这适用于读操作；对于写操作不能单纯采用此方法，因为会引发脏数据，可以复制一份数据库，让测试走测试数据库，在请求中增加参数区分正常请求和测试请求，来达到使用不同的数据库的目的。
以上是对于集群的单个机器测试，而对于整个集群的全站压测是十分困难的。</p>
<h3>内部私有云</h3>
<p>内部私有云为大型系统的运维带来了很多便利，私有云要求我们的资源能够动态扩展，并在不需要动态收缩，判断扩容还是缩容与系统容量和水位有很大关系，这也涉及到人工智能的一些技术来实现智能化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/09/10/consistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/consistency/" itemprop="url">分布式一致性协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T09:10:00+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed-System/" itemprop="url" rel="index">
                    <span itemprop="name">Distributed System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/10/consistency/" class="leancloud_visitors" data-flag-title="分布式一致性协议">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着计算机系统的规模变大，将所有的业务部署在一台机器上已经不能满足当今计算机系统了。微型机的出现及互联网的不断发展也促使了大量灵活多变的系统架构出现，尤其是分布式处理方式越来越受到工业界的青睐，计算机系统正在从集中式走向分布式架构。
&lt;!--more--&gt;</p>
<h2>集中式到分布式</h2>
<p>由于大型机成本较高，也存在单点问题，无法满足互联网应用爆炸式的增长需求。
集中式的特点:（1）部署简单；（2）单点故障
分布式特点:（1）分布性 （2）对等性（节点没有主/从之分）（3）并发性（多个节点并发操作共享资源）（4）缺乏全局时钟（无法确定事件先后顺序） （5）故障总会发生
分布式环境的常见问题:（1）通信异常（延迟）（2）网络分区（脑裂：只有部分节点能正常通信，这些小集群完成整个系统才能完成的任务） （3）三态（成功、失败、超时）（4）节点故障</p>
<h2>分布式事务</h2>
<h3>ACID</h3>
<p>事务是对系统中数据进行访问与更新操作组成的一个程序执行逻辑单元，事务具有4个特征：原子性，一致性，隔离性，持久性（ACID）。
原子性：事务必须是原子操作单元，各项操作要么全部执行成功，要么全部不执行；任何一项操作失败都会导致整个事务回滚，全部操作成功才意味着事务的成功完成。
一致性：事务的执行不能破坏系统的完整性和一致性，事务在执行前后系统都必须处于一致性状态，即事务执行使得系统从一个一致性状态转变到另一个一致性状态。若事务执行发生故障后，只有一部分操作修改写入数据库，那数据库就处于不一致性的状态。
隔离性：并发的事务是相互隔离的，一个事务不能被其他事务干扰，并发执行的事务又各自完整的数据空间，事务之间相互不干扰。SQL隔离性（未授权读、授权读、可重复读、串行化）
持久性：事务一旦提交，它的修改就应该是永久性的，即使系统崩溃后，重新修复也能恢复到事务提交成功后的状态</p>
<p>在单机上实现事务比较简单，但在分布式系统中，分布式事务由多个分布式操作序列组成，而实现分布式事务的ACID更为复杂（通信、多节点、宕机）。当追求分布式系统严格一致性时，系统的可用性会收到影响，即可用性和一致性永远无法存在一个两全齐美的方案，折中考虑出现了CAP和BASE分布式理论。</p>
<h3>CAP</h3>
<p>CAP理论：分布式系统不可能同时满足一致性，可用性和分区容错性，这三个最多只能满足其中二项
一致性：数据在多个副本之间保持一致性（强一致性）（放弃C，放弃强一致性，保留最终一致性，时间窗口，最终达到一致性状态）
可用性：分布式系统提供的服务必须一致处于可用的状态，对每一个用户的请求总是在有限的时间内返回结果（有限时间、结果）（放弃A，在故障期间无法提供服务）
分区容错性：分布式系统在遇到任何网络分区故障时仍能对外提供一致性和可用性的服务，除非整个网络环境发生了故障 （放弃P意味着单机部署）</p>
<p>在分布式系统中，分区容错性是必须解决的问题，所以往往需要在可用性和一致性之间寻求平衡。</p>
<h3>BASE</h3>
<p>BASE理论：基本可用、软状态、最终一致性。BASE是对CAP一致性和可用性权衡的结果，其核心思想是分布式系统无法做到强一致性，每个应用可以根据自身业务特点来使系统达到最终一致性
基本可用：分布式系统在出现故障时，允许损失部分可用性（并不等价于不可用，如响应时间损失、服务降级）
弱状态：系统中允许存在中间状态，该状态不会影响系统的整体可用性，即允许存在一定的延迟
最终一致性：经过一段时间的同步后，系统最终能够达到一致性的状态，不需要实时保证一致性，是一种弱一致性
最终一致性的变种：因果一致性、读己之所写、回话一致性、单调读一致性、单调写一致性</p>
<h2>一致性协议</h2>
<p>在分布式系统进行架构设置时，往往在可用性与一致性之间反复权衡，于是就产生了一系列的分布式一致性协议，经典的一致性协议如下。</p>
<h3>2PC</h3>
<p>在分布式系统时，每一个节点都知道自己的事务是否成功，但是不知道其他节点的事务执行情况，因此为了保证事务的ACID，需要引入一个协调者来统一调度所有节点。协调者调度参与者的行为，并最终决定参与者是否把事务真正提交。基于这个思想出现了2PC、3PC协议。</p>
<p>2PC：二阶段提交，常用于数据库领域，绝大数的关系型数据库都采用了二阶段提交协议。2PC是一种一致性协议，被广泛应用于分布式系统中。
执行流程：
	1.提交事务请求
		（1）事务询问：协调者向参与者发送事务内容，咨询是否可以执行事务，等待参与者响应
		（2）执行事务：参与者执行事务操作，并将undo与redo记录事务日志
		（3）参与者反馈事务响应：若参与者成功执行事务则反馈yes给协调者，若执行失败则反馈no
	2.执行事务提交
	若协调者从参与者的反馈都是yes，则执行事务提交
		（1）执行事务提交：向所有参与者发出commit请求
		（2）事务提交：参与者接受commit请求，提交事务并释放资源
		（3）反馈事务执行结果：参与者执行事务后，返回ack给协调者
		（4）完成事务：协调者收到所有参与者的ack后，完成事务
	3.中断事务
	若任何一个参与者反馈了no，或者超时无响应，那么就会中断事务
		（1）发送回滚请求：协调者发出rollback请求
		（2）事务回滚：参与者收到rollback后，利用日志中的undo信息来回滚，并释放资源
		（3）反馈结果：参与者回滚后向协调者发出ack消息
		（4）中断事务：协调者收到所有参与者的ack后完成事务中断</p>
<p>二阶段提交将分布式事务执行分成投票和执行两个阶段，即先尝试后提交处理方式，因此它是一个强一致性的协议。</p>
<p>优缺点：
	优点：实现简单
	缺点：
		（1）同步阻塞：参与事务的逻辑都处于阻塞状态，无法进行其他任何操作，影响分布式系统性能
		（2）单点问题：协调者一旦出现问题，事务将会失败
		（3）数据不一致：若协调者发送commit后挂掉，只有部分参与者收到了消息，则导致了数据不一致现象
		（4）过于保守：任何一个节点的失败都导致了整个事务的失败</p>
<h3>3PC</h3>
<p>三阶段提交是对二阶段提交的改进，将二阶段的“提交事务请求”拆分成2个阶段，由CanCommit、PreCommit、DoCommit三个阶段组成的事务处理协议。
执行阶段：
	1.CanCommit
		（1）事务询问：协调者向所有参与者发送CanCommit请求，询问是否可以执行事务提交操作，等待响应
		（2）参与者反馈询问：参与者收到请求后，若正常情况反馈yes，进入预备状态，否则又问题返回no
	2.PreCommit
	协调者根据参与者的反馈情况来决定是否可以进行事务的PreCommit操作
		（1）执行事务提交
			若协调者收到的都是yes，就会执行事务预提交
			发送预提交请求：协调者PreCommit请求进入Prepared阶段
			事务预提交：参与者收到PreCommit后执行事务操作，记录undo、redo到事务日志
			反馈：参与者反馈ack给协调者
		（2）中断事务:若任何一个参与者反馈了no或超市，协调者将会中断事务
			发送中断请求：发送abort请求
			中断事务：无论收到了abort还是等待协调者超时，参与者都将中断事务
	3.DoCommit
		（1）执行提交
			发送提交请求:协调者收到所有的ack响应后，他将从预提交转变到提交状态，并发送DoCommit请求
			事务提交：参与者收到DoCommit请求后，执行事务提交操作，释放资源
			反馈：参与者提交事务后，返回ack;协调者收到ack后，完成事务
		（2）中断事务：协调者收到任何一个no
			发送中断请求：发送abort
			事务回滚：参与者收到abort后利用undo来执行回滚操作，并释放资源
			反馈：事务回滚后，向协调者反馈ack
			中断事务：协调者收到ack后中断事务</p>
<p>在进入阶段三后，若协调者挂掉或者协调者与参与者通信故障，都导致DoCommit或abort请求无发送到，在超时后参与者都会提交事务</p>
<p>优缺点：
	优点：降低了阻塞范围
	缺点：第三阶段无法收到DoCommit请求后，参与者继续提交事务，引发数据不一致性</p>
<h3>Paxos</h3>
<p>Paxos是一种基于消息传递且具有高度容错性的一致性算法，它主要解决的问题是在发送各种异常的分布式系统中，快速正确地在集群内部达成一致。
在Paxos一致性算法中，有三种参与角色，分别为：Proposer、Acceptor、Learner；在具体的实现中，一个进程可能充当不止一种角色。参与者可以以任意的速度执行，可能会出错而停止也可能会重启，消息在传递过程中也可能会出现不可预知的延迟，也可能会重复或丢失。</p>
<p>Paxos被广泛应用于分布式系统中，如Google Chubby（分布式锁服务）以及Hypertable（分布式数据库）中，下面我们看看Paxos协议的工作过程。</p>
<h4>提案生成与选定</h4>
<p>提案的选定
	一个提案必须被半数以上的Acceptor批准；
	若提案[M,V]被批准，那么之后任何Proposer产生的编号比M高的提案，其Value值必须为V</p>
<p>Proposer提案生成算法
	1.Proposer选择一个提案编号M，然后向某个Acceptor集合发出请求，并提出要求 （Prepare请求阶段）
		（1）承诺不再批准编号小于M的提案
		（2）若Acceptor已经批准过任何提案，那么就像Proposer反馈已经批准编号小于M的最大编号的提案的值
	2.如果Proposer收到了半数以上的Acceptor响应结果，他可以产生编号为[M,V]的提案，其中V是所有响应中编号最大的提案Value值；当然若没有半数以上Acceptor批准提案，V值可以任意选取
	3.确认提案后，Proposer将该提案再次发送个Acceptor集合（该集合并不一定是上次响应Prepare请求的集合，但任意两个半数以上集合肯定有公共的Acceptor），期望获得他们的批准</p>
<p>Acceptor批准提案
	根据上述Prosposer提案生成流程，Acceptor会收到两种请求：Prepare与Accept
	Prepare请求：Acceptor可以响应任何一个Prepare请求
	Acceptor请求：在不违背现有承诺下，可以响应Acceptor请求
所以，Acceptor只要未响应过任何编号大于M的Prepare请求，他就可以接受这个编号M的提案；若已经对编号大于M的请求进行了响应，它可以忽略该编号为M的提案。因此每个Acceptor只需要记住它已经批准的最大编号以及已经做出Prepare请求响应的提案最大编号。</p>
<p>选取主Proposer
	当然该算法还有一点问题，考虑一个特殊情况：若Proposer p1提出了编号为M1的提案，并完成了Propare阶段，此时Proposer p2提出了编号更大的M2提案，那么当p1进入阶段二时的Accept请求会被Acceptors忽略，如果p1再次生成新的更高编号M3，则p2第二阶段也失败，如此程序将陷入死循环。
	为了解决该问题，Paxos通过选取主Proposer来解决死循环，只有主Proposer才能提出议案，所以只要主Proposer和过半Acceptor正常工作，主Proposer提出更高编号的议案最终会被批准。</p>
<h4>算法陈述</h4>
<p>阶段一
	1.Proposer选择一个提案M，然后向Acceptor某个超过半数的集合发出Prepare请求
	2.如果Acceptor收到编号为M的Prepare请求，且该编号大于它已经响应过的所有Prepare请求，那么它可以把已经批准过的最大编号提案反馈给Proposer，并承诺不再批转任何小于M的提案
阶段二
	1.如果Proposer收到半数以上Acceptor对于发出编号为M的Prepare请求响应，它会生成一个[M,V]提案的Acceptor请求给Acceptor，V是收到的响应中编号最大的提案的值，若响应中没有提案，则V是任意值均可
	2.若Acceptor收到提案为[M,V]的Accept请求，只要它会同意任何编号大于M的Prepare请求，他就可以批准该提案</p>
<h4>Learner获取提案</h4>
<p>在提案选定后，Learner角色需要获取提案，获取的方式主要有三种。
	1.一旦Acceptor批准了一个提案，就将该提案发给Learner（通信次数太多）
	2.选定一个主Learner，将提案发给主Learner，由主Learner通知其他Learner（通信次数减少，主Learner单点问题）
	3.选取一个主Learner集合（方案二的改进）</p>
<h2>ZooKeeper</h2>
<h3>ZooKeeper简介</h3>
<p>ZooKeeper是一个开源的分布式协调服务，它将分布式中复杂容易出错的一致性协议封装起来，以简单易用的接口为用户提供服务。分布式应用程序可以基于它实现许多功能，如数据发布与订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选取、分布式锁、分布式队列等。</p>
<p>特点：
	（1）顺序一致性：统一客户端的事务请求，按照其顺序应用在ZooKeeper中
	（2）原子性：所有事务请求处理结果在整个集群上是一致的，要么都成功要么都失败
	（3）单一视图：客户端无论连接哪个ZooKeeper服务器，看到的数据模型都是一样的
	（4）实时性：保证在一定时间段内，客户端能够读取到最新的数据状态
	（5）可靠性：事务引起的状态变化会保存下来，直到下一个事务对其更改
设计目标：
	（1）简单数据模型：共享的、树型结构名字空间来相互协调（树型结构是ZooKeeper内存的一个数据模型，由Znode数据节点构成，类似文件系统，Znode是层级关系）
	（2）构建集群：集群由一组机器构成，每台都在内存中维护服务器状态，服务器间保持通信，只要超过一半机器工作正常，整个集群就能对外提供服务。
	（3）顺序访问：对于客户端的每个请求，ZooKeeper都会生成一个全剧唯一的递增编号，这个编号反应了事务的先后顺序
	（4）高性能：ZooKeeper将数据保存在内存中</p>
<h3>ZooKeeper中的基本概念</h3>
<p>1.集群角色
	Leader、Follower、Observer三种角色。Observer不参与Leader选举和“过半写成功”策略，但它可以提升集群读性能
2.会话Session
	客户端通过TCP长连接来连接ZooKeeper，在第一次建立连接后，session的生命周期也开始了。客户端通过心跳检测机制来保持回话有效，也能够接受服务器的Watch事件通知。当服务器压力太大或网络故障导致连接断开时，只要在sessionTimeout时间内重新连接上任意一台服务器，那么之前创建的会话依然有效。
3.数据节点Znode
	ZooKeeper将数据保存在内存中，数据模型是一颗树（Znode Tree），由/分割的路径就是一个Znode，Znode保存数据内容及属性信息。Znode分为持久节点和临时节点，临时节点与客户端会话绑定，一旦会话失效，则临时节点会被删除。
4.版本
	ZooKeeper为每个Znode维护一个Stat数据结构，记录了三个版本信息，version（Znode版本），cversion（Znode子节点版本），aversion（ACL版本）。
5.Watcher
	Watcher事件监听器，允许客户端在节点上注册Watcher，并在特定事件触发时，将事件通知给感兴趣的客户端。该机制是ZooKeeper实现分布式协调服务的重要特性。
6.ACL
	ACL策略用来进行权限控制，ZooKeeper定义了5种权限
	（1）create：创建子节点
	（2）read：读取节点数据和子节点列表
	（3）write：更新节点数据
	（4）delete：删除子节点
	（5）admin：设置节点ACL</p>
<h3>ZAB协议介绍</h3>
<p>ZooKeeper并没有使用Paxos协议，而是使用了ZooKeeper Atomic Broadcast（原子消息广播算法）作为一致性的核心算法。ZAB不像Paxos是一种通用的分布式一致性算法，它是专门为ZooKeeper设计的崩溃可恢复的原子消息广播算法。基于该算法，ZooKeeper使用单一的的主进程来接受处理客户端的事务请求，使用ZAB协议将数据状态变更以事务Proposal形式广播到所有副本进程。所以这种主备模型保证了集群中只有一个主进程来处理请求，也保证了请求事务的顺序。</p>
<p>下面我们详细分析ZAB协议的具体内容，ZAB包括两种基本模式：崩溃恢复与消息广播。在服务框架刚启动或Leader挂掉后，ZAB协议进入恢复模式选举新的Leader，当选举完成并且有过半Follwers进行状态同步后，ZAB协议退出恢复模式进入消息广播模式。当一台新的服务器加入集群后，它将进入恢复模式，找到Leader进行数据同步然后参与广播模式。Leader服务器在接收到事务请求后进行事务广播协议，若其他服务器接收到事务请求将转发给Leader。当Leader崩溃或不再与半数以上服务器正常通信时，ZAB协议将从消息广播模式进入到崩溃恢复模式，所以Leader必须要有半数以上的服务器支持。</p>
<h4>消息广播</h4>
<p>ZAB的消息原子广播协议类似一个二阶段提交过程，针对客户端的事务请求，Leader生成对应的事务Proposal然后发送给其余机器，在收集选票后执行事务提交。与二阶段提交不同之处在于，ZAB移除了中断模式，Followers可以反馈事务Proposal可以抛弃，只要有过半Followers反馈后就可以提交事务，这种简化的二阶段提升了效率也带来了数据不一致问题。ZAB使用崩溃恢复模式来解决。此外，消息广播使用了FIFO的TCP协议进行通信，保证了事务的顺序性。</p>
<p>Leader生成的Proposal事务消息都会有一个ID（ZXID），该事务ID用于保持事务之间的顺序，具体来说，Leader为每一个Follower分配一个单独的队列，将事务放入队列按照FIFO规则进行发送，得到半数以上Follwers反馈ACK后进行提交，同时也给Followers发送Commit消息。</p>
<h4>崩溃恢复</h4>
<p>当Leader崩溃后，ZAB需要选举出新的Leader，需要保证（1）已经在Leader上提交的事务最终被所有服务器提交（2）丢弃那些只在Leader上提出的事务
结合上述两种极端情况，ZAB需要保证提交已经被Leader提交的事务，丢弃已经被跳过的事务。所以ZAB保证新选取的Leader拥有集群中最大的事务ID（ZXID），该机器一定具有已经提交的提案。</p>
<p>在选举出新Leader后，ZAB还需要保证集群中过半服务器已经提交了所有事务Proposal，即数据同步。具体来说，Leader向每一个Follower的队列中发送未完成的事务Proposal，并在每一个事务后紧接着发送Commit消息表示该事务已提交，等Follower服务器将所有事务都同步过来后，Leader将它加入真正可用的Followers列表。</p>
<p>在特殊情况下，ZAB需要处理需要丢弃的事务。ZAB的事务编号ZXID是一个64位数字，其中低32位是自增的数字代表了Leader处理的事务顺序，高32位代表了Leader的周期epoch。没当选举出新的Leader时，都会从最大事务ZXID中取出epoch值并加1代表新的epoch值，然后将低位置0。基于该策略，当一个上一个Leader周期尚未提交事务Proposal机器加入时，它作为Follower与Leader同步时，Leader根据自己最大事务进行对比，然后让该Follower执行回退操作，回退到已经被半数以上机器提交的最新事务，因而保证丢弃了未提交的事务。</p>
<h3>深入理解ZAB</h3>
<p>在大概了解ZAB协议的内容后，我们详细分析ZAB的算法流程。
ZAB协议主要包含了消息广播和崩溃恢复两个过程，进一步可以细分为三个阶段：发现，同步，广播。组成ZAB协议的每一个分布式进程会循环执行这三个阶段，这一循环过程称为主进程周期</p>
<h4>发现</h4>
<p>发现就是Leader选举过程，其工作流程如下：
	1.Follower将自己最后接受的事务epoch发给准Leader
	2.接受来自过半Follower的epoch消息后，准Leader产生新的epoch值并发给这些Follower（新的epoch值为来自Follower中最大的值，然后加1）
	3.Follower接受来自准Leader的新epoch值后，若大于当前的epoch则更新epoch并发送ack给准Leader，并将自己已执行的事务Proposal集合发给准Leader
	4.准Leader接受ack后，会从中选择一个Follower的其事务集合初始化自身事务集合I（该Follower选取条件：ZXID最大，即epoch最大，若有epoch相同，则事务ID最大）</p>
<h4>同步</h4>
<p>在同步阶段中，Leader和Follower进行事务消息同步，具体流程如下：
	1.Leader将epoch和事务集合I发送给过半集合Follower
	2.Follower接受消息后，对比epoch若不相同（还在上一轮），直接进入下一轮，不参与本轮的同步；若相同则执行I中事务并反馈给Leader
	3.当Leader收到过半Follower反馈后，发送Commit消息，然后Follower提交事务</p>
<h4>广播</h4>
<p>在数据同步后，Leader可以接受客户端的事务请求，并进行消息广播，具体流程如下：
	1.Leader接受客户端事务请求，生成事务CXID，按顺序发送给Follower
	2.Follower根据接受事务顺序，添加到事务集合，并反馈给Leader
	3.收到过半Follower针对事务的ack消息后，Leader发送Commit消息，要求它们提交事务
	4.Follower收到Commit消息后提交事务，此时上一个事务肯定已经提交了</p>
<p>下图展示了ZAB协议的工作过程的三个阶段：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/ZAB.png" alt="img">
&lt;/center&gt;</p>
<h4>运行分析</h4>
<p>ZAB协议中，每一个进程处于以下三种状态之一：
	-Looking：Leader选举
	-Following：Follower与Leader同步
	-Leading：Leader领导状态
进程刚启动时，都处于Looking状态，选举出Leader后，Follower切换到Following状态，Leader处于Leading状态。</p>
<h2>ZAB与Paxos联系与区别</h2>
<p>联系：
	1.两者都存在Leader与Follower角色
	2.Leader都会等待超过半数Follower反馈后在提交事务
	3.两者协议都存在主进程周期说法，ZAB的epoch，Paxos的Ballot
区别：
	Paxos在产生Leader后，进行两个阶段，分别为读阶段，写阶段。读阶段，主进程会和Follower通信，收集上一个主进程的提出议案，并把它提交；写阶段主进程提出自己的议案
	ZAB增加一个同步阶段，同步前ZAB也有一个类似的读阶段称为发现阶段，然后同步阶段确保过半Follower提交了上一周期的所有事务Proposal，同步完成后同样执行写阶段，处理客户端请求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/08/10/distributed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/distributed/" itemprop="url">大型网站架构概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T16:20:30+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Architecture/" itemprop="url" rel="index">
                    <span itemprop="name">Architecture</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/10/distributed/" class="leancloud_visitors" data-flag-title="大型网站架构概念">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大型网站是一种常见的分布式系统，在理解大型网站架构前，首先需要对分布式相关基础有一定了解。关于大型网站的概念，一个很直观的想法是访问量很大，然而有些网站访问量很高但并不
&lt;!--more--&gt;能称为大型系统，如www.tao123.com，所以访问量并不是大型网站的充分条件。另一方面，海量量也是需要关注的另一个维度，一个大型系统也应该需要海量的数据才行，数据就是财富。因此，访问量和数据是量是大型网站的必要条机，二者缺一不可，此外系统业务本身和复杂度也是需要考虑的！</p>
<p>大型网站要支撑海量的数据和较高的并发量，那他一般是一个分布式的系统，往往需要集群来工作，下面我们先看看分布式系统的基础知识。</p>
<h2>初识分布式系统</h2>
<p>分布式系统定义很多，而这些定义的本质都几本相同，其中最主要的为：一组分布在网络上的计算机通过消息传递来相互通信协调工作，而对用户来看仿佛是单一的机器再提供服务。分布式系统的出现的主要原因也主要有以下几点：单机性能瓶颈（cpu，存储等），稳定性和可用性（单点故障）。</p>
<p>我们都知道，计算机基本组件由控制器，运算器，存储器，输入设备，输出设备五部分构成。相关的技术模式涉及多线程、多进程（代价大，涉及序列化与反序列化）模式，IO（BIO、NIO、AIO）模式。 相比传统的单机系统，分布式系统的控制器、运算器、存储器有着明显的变化。下面我们以控制器为主看看主要的的变化和区别：</p>
<p>&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/hardware.png?imageMogr2/thumbnail/!50p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/lvs.png?imageMogr2/thumbnail/!50p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/%E5%90%8D%E7%A7%B0%E6%9C%8D%E5%8A%A1.png?imageMogr2/thumbnail/!50p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/%E8%A7%84%E5%88%99.png?imageMogr2/thumbnail/!50p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/master-slave.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
在分布式系统中为了使用负载均衡，常有以上5种方式，分别为：
（1）硬件负载均衡
（2）软件负载均衡（如LVS），该方式会存在流量增加和延迟二个不足。
（3）名称服务：名称服务收集服务器地址，并提供服务器地址给请求方
（4）规则服务器：只提供规则给请求方，而不提供服务器地址
（5）master-salve：master节点来管理</p>
<p>分布式系统在带来优势同时，也存在相比单机系统更复杂的问题，主要的挑战和难点有：
（1）缺乏全局时钟：较难处理顺序执行问题
（2）故障独立性：分布式系统往往存在部门系统故障，如何处理局部故障而不影响全局业务需要考虑
（3）单点故障：若分布式系统中某个功能由单个节点完成，需要处理好备份和降低单点影响范围问题
（4）事物：分布式事务相对单机事物复杂的多，如何保证一致性十分困难，分布式协议理论CAP，BASE，2PC，3PC，raft，Paxos，ZAB等。</p>
<h2>大型系统的架构演进</h2>
<p>大型网站往往由小网站慢慢发展起来，这一过程中需要解决的问题也是构建大型网站和中间件的基础，我们先了解一下大型网站的发展过程。
（1）Java技术和单机系统：Java，Web，MVC，JSP，Spring，JDBC等技术
我们以交易系统业务为例，系统整体的结构图可以抽象为如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/singleJava.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
（2）数据库与应用服务分离
随着服务器负载过大，我们可以将应用服务器与数据库服务器分离
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/dbServer.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
（3）应用服务器集群化
服务器负载仍然过大，这个时候可以利用服务集群解决单机性能不足问题。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mulServer.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
然后该方式存在session失效问题，因为客户端往往通过http协议进行请求，http是无状态的协议，所以在第一次请求时会分配一个sessionId，下一次请求时浏览器带上这个sessionId，session存放在服务端，若在分布式情况下，并不能保证同一客户端每次请求落在同一台服务器上，所以会存在session失效问题，而分布式系统中解决session失效问题也有如下几种方式：
1）Session Sticky
该方案如下图所示，通过负载均衡设备让相同的session请求发送在同一服务器上。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/sticky.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
2）Session Replication
该方案如下所示，服务器之间相互复制数据，保证session的共享，该方案也存在浪费带宽和存储的缺陷
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/replication.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
3）Session集中存储
该方案比较简单，如下图所示
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/centerSession.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
4）cookie based
该方案将session放入cookie中，从cookie中生成session，该方式也存在缺陷：cookie长度的限制，性能延迟影响，安全性等。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/cookie.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
以上方式中，（1）（3）是常用的方式。
（4）数据库读写分离（读压力）
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/readwrites.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
随着数据量和访问量的变大，尤其是多读少写的情况，所以可以增加一个数据库，只用来读数据。该方式如下图所示，也存在数据复制和数据源选择问题。首先数据在复制时存在延迟问题，即数据一致性问题，Mysql的Master-Slave模式，支持异步复制，也支持semi-sync复制方式。此外，对于数据源的选择，写操作和事物读肯定发生在主库中，一般读操作可以在从库，应用可根据需求合理选取数据源。
（5）搜索引擎（读库）
搜索引擎其实是一个读库，通过复制数据来建立索引，加快数据查询效率，索引的建立分为全量/增量，实时/非实时方式。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/search.png?imageMogr2/thumbnail/!55p" alt="img">
&lt;/center&gt;
（6）缓存
缓存可以加速数据的访问，有数据缓存和页面缓存。数据缓存主要用于缓解数据库读压力，页面缓存主要缓存页面中经常访问的数据（热数据）！
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/cachedb.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
（7）分布式数据库系统
分布式文件系统、分布式key-value系统、分布式数据库系统
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/dbdistribute.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
（8）数据库拆分
当数据库数据过多，压力依然很大时，可以进行数据库拆分，主要有垂直拆分和水平拆分。
垂直拆分是把不同的业务数据拆分到不同的数据库中，这样导致了一方面需要配置多个数据源，另一方面需要采用分布式事务保持数据一致性。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/cz.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
水平拆分是指单表的数据过大，数据读写速度太慢，需要将一个表拆成多个子表，这样就存在了sql路由问题，数据库id自增问题，数据表联合查询问题等。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/sp.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
（9）新挑战
1）业务拆分：根据功能将应用拆分多部分
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/gncf.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
2）服务化结构：分层，服务调用
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/fwh.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
3）中间件：异步和解耦
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/midware.png?imageMogr2/thumbnail/!60p" alt="img">
&lt;/center&gt;
中间件为软件应用提供了操作系统所提供服务之外的服务，中间件不是操作系统也不是应用，它起到了桥梁的作用，是处于“中间”位置的组件，让开发人员更好的专注自己的应用开发！常见的中间件主要有以下几种：
-远程过程调用和对象访问中间件：分布式应用下应用相互访问问题，也是应用服务化的基础
-消息中间件：应用之间消息传递、异步、解耦
-数据访问中间件：应用访问数据库的共性问题
Java中间件的基础知识：JVM、GC、JMM；并发（线程池、常用类库）；动态代理及反射，网络通信（BIO，NIO，AIO）</p>
<h2>总结</h2>
<p>在列举了大型网站系统的发展过程后，我们总结一下相关的知识，用下图来展示了大型网站的相关技术。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/bigsystem.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
在将中间件放入系统中后，大型网站的系统结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/bigsysmidware.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
后面我们将分别学习服务框架、消息中间件及数据库中间件等基础知识！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/06/26/io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/io/" itemprop="url">Java IO浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T20:44:40+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/26/io/" class="leancloud_visitors" data-flag-title="Java IO浅析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java中IO主要分为字符流和字节流，字符流处理的单元为2个字节的Unicode的字符，而字节流处理的单元为一个字节。Java内用Unicode编码存储字符，字符流处理类负责将外部的其他编码的字符流和java内Unicode字符流之间的转换。而类InputStreamReader和OutputStreamWriter处理字符流和字节流的转换。
&lt;!--more--&gt;
而Java IO按照阻塞/非阻塞，同步／异步又可以分为BIO，NIO，AIO，下面我们简单介绍下这几类IO。</p>
<h2>BIO</h2>
<p>下图展示了Java BIO的体系结构，主要相关部分分为流式结构、非流式结构(file相关)、其他(socket等)：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/io.png" alt="img">
&lt;/center&gt;
字节流和字符流的常见类如下图所示，主要采用了装饰者及适配器设计模式：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/io_stream.png" alt="img">
&lt;/center&gt;</p>
<h3>字符流</h3>
<p>字符流的基础抽象类是InputStream和OutputStream，下面简单看看它们的主要方法和具体实现类
1.InputStream
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//方法是读取一个byte字节,但是返回的是int</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//一次性读取内容到缓冲字节数组</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//从stream中跳过long类型参数个位置</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//关闭stream方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> available() <span class="keyword">throws</span> IOExceptionpublic <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span>;<span class="comment">//返回stream中的可读字节数</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> mark(<span class="keyword">int</span> readlimit) <span class="comment">//用于标记stream的作用,readlimit表示调用mark最多可以读多少字节</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//这个方法和mark方法一起使用的，让stream回到mark的位置判断</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span></span>;<span class="comment">//stream是否可以调用mark方法和reset方法</span></div></pre></td></tr></table></figure></p>
<p>这里需要注意下：mark(int readlimit)的参数并不是说读取readlimit个字节标记位才失效，也和BufferedInputStream类的缓冲区大小有关。若BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效，即是取readlimit和BufferedInputStream类的缓冲区大小（BufferedInputStream bis=new BufferedInputStream(in,2)）两者中的最大值。
下面介绍一些常用的具体实现类吧：
1）.ByteArrayInputStream ：把内存中的一个缓冲区作为 InputStream 使用
2）.FileInputStream ：把一个文件作为 InputStream
3）. PipedInputStream：实现了pipe，主要在线程中使用，管道输入流是指一个通讯管道的接收端。一个线程通过管道输出流发送数据，另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。
4）.SequenceInputStream：把多个 InputStream 合并为一个 InputStream，使用Enumeration作为参数
5）.ObjectInputStream：用于操作Object的stream，这个在stream主要用在对象传输的过程中，其中牵涉到了序列化的知识
6）.FilterInputStream：是一个过滤的InputStream，有很多具体的子类
	6.1）  BufferedInputStream:使用缓冲区的stream
	6.2）	 DataInputStream:数字格式化的stream（readInt,readFloat,readDouble）</p>
<p>2.OutputStream
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">int</span> b) <span class="keyword">throws</span> IOException; <span class="comment">//写入一个字节</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[]) <span class="keyword">throws</span> IOException；<span class="comment">//写入一个byte数组到stream中</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">write</span>(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> IOException；<span class="comment">//把byte数组中从offset开始处写入长度为len的数据</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> flush() <span class="keyword">throws</span> IOException；<span class="comment">//这个方法是用来刷新stream中的数据，让缓冲区中的数据强制的输出</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> close() <span class="keyword">throws</span> IOException；<span class="comment">//关闭流，这个是在操作完stream之后必须要调用的方法</span></div></pre></td></tr></table></figure></p>
<p>常见的具体实现类：
1）ByteArrayOutputStream： 把信息存入内存中的一个缓冲区中 . 该类实现一个以字节数组形式写入数据的输出流
2）FileOutputStream: 文件输出流是向 File 或 FileDescriptor 输出数据的一个输出流
3）PipedOutputStream: 管道输出流是指一个通讯管道的发送端。 一个线程通过管道输出流发送数据
4）ObjectOutputStream:输出Object对象的stream
5）BufferedOutputStream:带有缓冲区的stream
6）DataOutputStream:具有格式化的OutputStream
7）PrintStream:直接输出到控制台中：最熟悉的就是System.out是一个PrintStream</p>
<h3>字符流</h3>
<p>字符流的基础抽象类是Reader、Writer，下面看一下主要方法和具体实现类
Reader和InputStream的方法基本上一致，区别在于前者使用了char读取字符，而后者使用了byte读取字节
1）CharArrayReader：此类实现一个可用作字符输入流的字符缓冲区char[],与 ByteArrayInputStream 对应
2）PipedReader：与 PipedInputStream 对应</p>
<ol start="3">
<li>BufferReader: 与BufferInputStream对应
4）StringReader：从字符串读取
5）InputStreamReader：将InputStream转化成Reader，从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。
6）FileReader：继承InputStreamReader
Writer和OutputStream的方法基本上一致：
1）CharArrayWriter： 与 ByteArrayOutputStream 对应
2）PipedWriter：与 PipedOutputStream 对应
3）StringWriter：输出到StringBuffer
4）BufferWriter: 与BufferOutputStream对应
5）OutputStreamWriter： 将Writer转化为OutputStream，根据指定的字符编码将多个字符转换为字节，是字符流到字节流的桥梁
6）FileWriter：继承OutputStreamWriter</li>
</ol>
<h3>字节流与字符流的选择Tips</h3>
<p>1）按照输入输出   输入： Reader, InputStream 类型的子类；输出： Writer, OutputStream 类型的子类
2）按照数据格式  二进制格式（只要不能确定是纯文本的） : InputStream, OutputStream 及其所有带 Stream 结束的子类  ； 纯文本格式（含纯英文与汉字或其他编码方式）； Reader, Writer 及其所有带 Reader, Writer 的子类
3）是否需要缓冲 	要缓冲： BufferedInputStream, BufferedOutputStream,( 字节流 ) BufferedReader, BufferedWriter( 字符流 )
4）按数据来源（去向）分类：
	是文件： FileInputStream, FileOutputStream, ( 字节流 )FileReader, FileWriter( 字符 )
	是 byte[] ： ByteArrayInputStream, ByteArrayOutputStream( 字节流 )
	是 Char[]: CharArrayReader, CharArrayWriter( 字符流 )
	是 String: StringReader, StringWriter( 字符流 )
	网络数据流： InputStream, OutputStream,( 字节流 ) Reader, Writer( 字符流 )
5）其他特殊功能
	从 Stream 到 Reader,Writer 的转换类： InputStreamReader, OutputStreamWriter
	对象输入输出： ObjectInputStream, ObjectOutputStream
	进程间通信： PipeInputStream, PipeOutputStream, PipeReader, PipeWriter
	合并输入： SequenceInputStream
	更特殊的需要： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</p>
<h3>Java IO性能优化</h3>
<p>IO的性能瓶颈主要分为：
	1）错误的使用缓冲（buffer）
		a)为内存IO类（In-memory IO class）添加缓冲(错误用法)：如ByteArrayInput/OutputStream，根本没有使用到IO
		b)为已添加buffer的IO类再次添加buffer（错误用法）：多余的buffer只会引入更多的栈调用和垃圾创建
		c)Buffer版的IO类和显式使用buffer（使用byte[]或char[]）间的关系（概念上的误解）:实际上显示使用数组使用buffer效率更高
			Buffer版IO使用装饰者模式，效率较低; Buffer版IO方法有同步synchroized操作，同步导致效率低下
	2）过度的同步保护
		Java IO类存在很多同步方法，这样会导致效率低下</p>
<h2>NIO</h2>
<p>Java NIO是指New IO，相对于传统的IO支持非阻塞模式（文件除外），而且NIO是基于Buffer的，性能相比BIO有较大的提升，NIO中有三个主要的概念:Buffer、Channel、Selector.
1.Buffer
Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。具体的缓存区有：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer，其中ByteBuffer支持堆外直接内存分配。
每一个Buffer也有几个关键的信息如：position、limit、capacity、mark等等标记位来代表buffer数据状态情况（具体参考JDK源码）。
2.Channel
NIO 对数据的读取和写入要通过Channel。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。Channel主要分两大类：SelectableChannel用户网络读写，FileChannel用于文件操作。
3.Selector
Selector是NIO的基础，它提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。一个Selector可以同时轮询多个Channel，JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p>
<p>NIO相对BIO实现上复杂很多，下面我们简单写一个聊天功能吧：
服务端代码：
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/9/11.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> class NioServer &#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PORT = <span class="number">6060</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;<span class="keyword">String</span>&gt; userNames = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> initNioServer() &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        	<span class="comment">//  主线程注册等待连接事件</span></div><div class="line">            selector = Selector.<span class="built_in">open</span>();</div><div class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.<span class="built_in">open</span>();</div><div class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</div><div class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"NIO Server initial...Waiting for connecting on port 6060!"</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="built_in">int</span> n = selector.select();</div><div class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    SelectionKey <span class="built_in">key</span> = iterator.next();</div><div class="line">                    iterator.remove();</div><div class="line">                    handleMessage(<span class="built_in">key</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 发送消息，发送到其他所有的通道</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendMessages(Selector selector, SelectionKey sk, <span class="keyword">String</span> content) &#123;</div><div class="line">        <span class="keyword">for</span> (SelectionKey <span class="built_in">key</span> : selector.keys()) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">key</span> == sk) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            Channel channel = <span class="built_in">key</span>.channel();</div><div class="line">            <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> SocketChannel) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    ((SocketChannel) channel).write(charset.encode(content));</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//select监听到事件返回，然后解析具体的SelectionKey，读/写/连接,分别处理</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(SelectionKey <span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>.isAcceptable()) &#123;</div><div class="line">            ServerSocketChannel ssc = (ServerSocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                SocketChannel socketChannel = ssc.accept();</div><div class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                socketChannel.register(selector, SelectionKey.OP_READ);</div><div class="line">                System.out.<span class="built_in">println</span>(<span class="string">"client:"</span> + socketChannel.getRemoteAddress() + <span class="string">" is connecting"</span>);</div><div class="line">                socketChannel.write(ByteBuffer.wrap(<span class="string">"welcome guys,please input your name!"</span>.getBytes()));</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span>.isReadable()) &#123;</div><div class="line">            SocketChannel socketChannel = (SocketChannel) <span class="built_in">key</span>.channel();</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                socketChannel.read(buffer);</div><div class="line">                buffer.flip();</div><div class="line">                <span class="keyword">String</span> content = charset.decode(buffer).toString();</div><div class="line">                <span class="keyword">if</span> (content != <span class="keyword">null</span> &amp;&amp; content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">String</span>[] strings = content.<span class="built_in">split</span>(<span class="string">"_"</span>);</div><div class="line">                    <span class="keyword">if</span> (strings.length == <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (userNames.contains(strings[<span class="number">0</span>])) &#123;</div><div class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">"users already exists!"</span>.getBytes()));</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            userNames.<span class="built_in">add</span>(content);</div><div class="line">                            System.out.<span class="built_in">println</span>(content + <span class="string">", registered!"</span>);</div><div class="line">                            socketChannel.write(ByteBuffer.wrap((<span class="string">"welcome,"</span> + content).getBytes()));</div><div class="line">                            sendMessages(selector, <span class="built_in">key</span>, strings[<span class="number">0</span>] + <span class="string">",enter the char room!"</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sendMessages(selector, <span class="built_in">key</span>, content);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="built_in">key</span>.cancel();</div><div class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        socketChannel.close();</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</div><div class="line">                        e1.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioServer().initNioServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端代码比较简单：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class NioClient &#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> PORT = <span class="number">6060</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> userName=<span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> init() &#123;</div><div class="line">        <span class="built_in">try</span> &#123;</div><div class="line">            selector = Selector.<span class="built_in">open</span>();</div><div class="line">            <span class="comment">//连接远程主机的IP和端口</span></div><div class="line">            SocketChannel sc = SocketChannel.<span class="built_in">open</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, PORT));</div><div class="line">            sc.configureBlocking(false);</div><div class="line">            sc.<span class="keyword">register</span>(selector, SelectionKey.OP_READ);</div><div class="line">            <span class="comment">//开辟一个新线程来读取从服务器端的数据</span></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientThread()).start();</div><div class="line">            <span class="comment">//在主线程中 从键盘读取数据输入到服务器端</span></div><div class="line">            Scanner scan = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">            <span class="built_in">while</span> (scan.hasNextLine()) &#123;</div><div class="line">                <span class="keyword">String</span> <span class="built_in">line</span> = scan.nextLine();</div><div class="line">                <span class="built_in">if</span>(userName.length()==<span class="number">0</span>)&#123;</div><div class="line">                    userName=<span class="built_in">line</span>;</div><div class="line">                    sc.<span class="built_in">write</span>(charset.encode(userName));</div><div class="line">                &#125;<span class="built_in">else</span> &#123;</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"Me: "</span>+<span class="built_in">line</span>);</div><div class="line">                    sc.<span class="built_in">write</span>(charset.encode(userName+<span class="string">"_"</span>+<span class="built_in">line</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//新起一个线程接受服务器的数据</span></div><div class="line">    <span class="keyword">private</span> class ClientThread implements Runnable &#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</div><div class="line">            <span class="built_in">try</span> &#123;</div><div class="line">                <span class="built_in">while</span> (true) &#123;</div><div class="line">                    <span class="keyword">int</span> k = selector.select();</div><div class="line">                    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">                    Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</div><div class="line">                    <span class="built_in">while</span> (iterator.hasNext()) &#123;</div><div class="line">                        SelectionKey sk = iterator.next();</div><div class="line">                        iterator.<span class="built_in">remove</span>();</div><div class="line">                        <span class="built_in">if</span> (sk.isReadable()) &#123;</div><div class="line">                            <span class="comment">//使用 NIO 读取 Channel中的数据</span></div><div class="line">                            SocketChannel sc = (SocketChannel) sk.channel();</div><div class="line">                            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">                            <span class="keyword">String</span> content = <span class="string">""</span>;</div><div class="line">                            <span class="built_in">while</span> (sc.<span class="built_in">read</span>(buff) &gt; <span class="number">0</span>) &#123;</div><div class="line">                                buff.flip();</div><div class="line">                                content += charset.decode(buff);</div><div class="line">                            &#125;</div><div class="line">                            <span class="built_in">if</span> (content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">String</span>[] strs = content.split(<span class="string">"_"</span>);</div><div class="line">                                <span class="built_in">if</span>(strs.length&gt;<span class="number">1</span>) &#123;</div><div class="line">                                    System.out.<span class="built_in">println</span>(strs[<span class="number">0</span>] + <span class="string">": "</span> + strs[<span class="number">1</span>]);</div><div class="line">                                &#125;<span class="built_in">else</span> &#123;</div><div class="line">                                    <span class="built_in">if</span>(content.equals(<span class="string">"users already exists!"</span>)) &#123;</div><div class="line">                                        System.out.<span class="built_in">println</span>(content);</div><div class="line">                                        userName = <span class="string">""</span>;</div><div class="line">                                    &#125;<span class="built_in">else</span> &#123;</div><div class="line">                                        System.out.<span class="built_in">println</span>(content);</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="built_in">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</div><div class="line">        <span class="keyword">new</span> NioClient().init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可以看出，NIO服务端利用了IO多路复用，相比BIO使用了更少的线程，资源利用率更高！
总结一下 BIO的优势：1）事件驱动模型，2）单线程处理多任务，避免了多线程等待，3）非阻塞I/O，I/O读写不再阻塞，而是返回0 4）IO多路复用大大提高了Java网络应用的可伸缩性和实用性
更多的NIO教程可以参考JDK源码。</p>
<h2>IO模式对比</h2>
<p>下面我们对比一下NIO与BIO的模式，然后再分析一下Java IO中的同步与异步、阻塞与非阻塞概念。</p>
<h3>BIO VS NIO</h3>
<p>BIO模式中，服务端由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/bio.png" alt="img">
&lt;/center&gt;
BIO最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，当线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就down机，所以BIO主要的问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程来处理这条链路，无法满足高性能、高并发的场景。当然可以使用一个线程池来管理这写具体的数据处理，以此来达到线程服用，节省服务器资源，但是这种方法不能解决问题的根本，在大量线程处于等待情况下仍然不能很好利用资源。
NIO模式的处理流程如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/nio.jpg" alt="img">
&lt;/center&gt;
可以看出NIO服务端由一个单独的线程来轮询等待事件到来，在没有事件时不会存在大量的线程阻塞，只有有事件时才会在新的线程中处理任务，因此不会造成大量线程阻塞，支持更高的并发，性能相比BIO有较大的提升。</p>
<h3>同步与阻塞</h3>
<p>首先解释下一下同步、异步概念以及阻塞、非阻塞概念。
首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO也分为二步，等待数据就绪以及数据拷贝（核心态内存到用户态内存）。所以可以看出，同步异步主要是应用程序和内核的交互方式，若应用读写直到IO完成那么就是同步的，若由操作系统完成IO读写放入缓冲区然后会调通知应用直接取数据那么就是异步的；同样阻塞和非阻塞区别在于在应用访问数据的时候，根据IO操作的就绪状态来采取的不同方式，是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。
下面我们结合下图看一下常见的几种模式：
阻塞IO:阻塞在recvfrom调用
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/io_sb.png" alt="img">
&lt;/center&gt;
非阻塞IO:反复轮询recvfrom
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/io_sn.png" alt="img">
&lt;/center&gt;
IO多路复用:实质阻塞在select调用（select/poll,epoll轮询），数据准备好开始读取（核心态到用户态）
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/io_sm.png" alt="img">
&lt;/center&gt;
异步IO：发起aio-read请求，等待数据准备好并拷贝到用户态缓存区（依赖OS），然后读取
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/io_an.png" alt="img">
&lt;/center&gt;
在这里简单了解下多路复用的概念以及select／poll，epoll的区别：
I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符（fd）就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间
select的缺点：
1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（fd_set类似数组的结构需要遍历）
3）select支持的文件描述符数量太小了，默认是1024
poll和select几本一致，区别在于其描述符FD定义不同,它使用的是pollfd；
epoll是linux新出用于取代poll、select，处理上述三个问题时：
1）次注册新的事件到epoll句柄中时（epoll_ctl函数）会把所有的fd拷贝进内核，不会在epoll_wait的时候重复拷贝
2）epoll_ctl为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表,epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd(也有人说用了红黑树所以比数组快)
3）epoll没有最大FD这个限制</p>
<p>此外Java中BIO，NIO，AIO的模式区别：
BIO：同步阻塞方式，同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善
NIO：同步非阻塞方式，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，由多路复用器轮询到连接有IO请求时才启动一个线程进行处理，所以是非阻塞的。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，但是从内核读取数据到用户缓冲区需要应用程序自己完成，因此是同步的。
AIO：异步非阻塞，JDK1.7后出现，一个有效请求一个线程，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。常见的类有AsynchronousSocketChannel，AsynchronousServerSocketChannel，AsynchronousFileChannel，AsynchronousDatagramChannel
总结一下，BIO关注“我要读”，NIO关注&quot;我可以读了&quot;，在AIO模型关注的是“读完了”，此外NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。BIO，NIO，AIO也有不同的适用场景：
BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h2>Reactor与Proactor</h2>
<p>Reactor与Proactor是两种常用的IO模式，其中Reactor是同步IO模式，被广泛应用于网络编程中，如Redis、Netty；而Proactor是一种异步IO模式，由于操作系统的原因，相关的开源产品也少；在这先里我们学习下其模型结构，重点对比下两者的异同点；
首先我们先看一下reactor的结构：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/reactor.jpeg" alt="img">
&lt;/center&gt;
Reactor包含如下角色：
1.Handle 句柄；用来标识socket连接或是打开文件；
2.Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）
3.Event Handler：事件处理接口
4.Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；
其流程如下：
1.应用启动，将关注的事件handle注册到Reactor中；
2.调用Reactor，进入无限事件循环，等待注册的事件到来；
3.事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</p>
<p>而Reactor也包含了常见三种类型：
1.精典Reactor模式
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/reactor_1.png" alt="img">
&lt;/center&gt;
可以看出Acceptor处理客户端连接请，Reactor将I/O事件发派给对应的Handler，由Handlers 执行非阻塞读/写及数据处理操作，这种模式下一个线程同时监控多个请求状态。
2.多工作线程Reactor模式
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/reactor_2.png" alt="img">
&lt;/center&gt;
经典Reactor模式中，尽管一个线程可同时监控多个请求（Channel），但是所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势，同时读/写操作也会阻塞对新连接请求的处理。因此可以引入多线程，可以使用线程池来并行处理多个读/写操作。
3.多Reactor模式
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/reactor_3.png" alt="img">
&lt;/center&gt;
多工作线程Reactor模式下，主线程也需要监听多种事件，当并发量过大时也会导致性能瓶颈，也存在单点故障问题，所以引出了多Reactor，即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读/写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟，并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel提交给不同的子Reactor处理，每一个子Reactor包含一个Selector实例，用来监听监听事件，并且监听在子Reactor所在的线程中，保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换；同样每一个子Reactor中创建了一个静态的线程池，循环处理数据读取和操作，相比单一的Reactor大大提升了效率。</p>
<p>Proactor的结构如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/proactor.jpeg" alt="img">
&lt;/center&gt;
主要包含了如下角色：
1.Handle 句柄；用来标识socket连接或是打开文件；
2.Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；
3.Asynchronous Operation：异步操作
4.Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用
5.Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；
6.Completion Handler：完成事件接口；一般是由回调函数组成的接口；
7.Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；
其工作流程如下：
1.应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；
2.应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；
3.异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；
4.主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</p>
<h2>总结</h2>
<p>Java IO中包含了BIO、NIO、AIO等多种模式，每一个模式有不同的特点和应用场景，这些都是IO的基础知识。此外有时间一定要学习一些开源的框架如Netty，它基于NIO，使用了Reactor
模式，同时也要多了解一下AIO模式如Proactor（异步IO）等高性能的IO模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/06/10/AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/10/AQS/" itemprop="url">Java并发之AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-10T20:44:40+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concurrent/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrent</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/10/AQS/" class="leancloud_visitors" data-flag-title="Java并发之AQS">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并发是服务器端必不可少的技术，当谈到并发时往往联系到锁、同步、竞争资源等名词。下面我们从Java语言来简单了解下并发编程的基础。
&lt;!--more--&gt;
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/aqs.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
上图从下到上描述了Java并发的整个体系：首先是JVM的violate可见性读写以及操作系统CAS原子操作的支持，在这一基础上出现了基础并发框架AQS以及一些简单的原子变量类，最后对AQS进行扩展完善，出现了大量的并发容器、同步器、锁结构。</p>
<h2>AQS公共方法</h2>
<p>AQS提供了许多公用的方法来管理同步，并且也提供了一些抽象方法，子类通过继承AQS来实现它的抽象方法来管理同步状态，AQS提供的主要方法有：
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">getState</span><span class="params">()</span></span>：返回同步状态的当前值；</div><div class="line"><span class="function"><span class="title">setState</span><span class="params">(int newState)</span></span>：设置当前同步状态；</div><div class="line"><span class="function"><span class="title">compareAndSetState</span><span class="params">(int expect, int update)</span></span>：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</div><div class="line"><span class="function"><span class="title">tryAcquire</span><span class="params">(int arg)</span></span>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态；</div><div class="line"><span class="function"><span class="title">tryRelease</span><span class="params">(int arg)</span></span>：独占式释放同步状态；</div><div class="line"><span class="function"><span class="title">tryAcquireShared</span><span class="params">(int arg)</span></span>：共享式获取同步状态，返回值大于等于<span class="number">0</span>则表示获取成功，否则获取失败；</div><div class="line"><span class="function"><span class="title">tryReleaseShared</span><span class="params">(int arg)</span></span>：共享式释放同步状态；</div><div class="line"><span class="function"><span class="title">isHeldExclusively</span><span class="params">()</span></span>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占；</div><div class="line"><span class="function"><span class="title">acquire</span><span class="params">(int arg)</span></span>：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法；</div><div class="line"><span class="function"><span class="title">acquireInterruptibly</span><span class="params">(int arg)</span></span>：与acquire(int arg)相同，但是该方法响应中断，当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回；</div><div class="line"><span class="function"><span class="title">tryAcquireNanos</span><span class="params">(int arg,long nanos)</span></span>：超时获取同步状态，如果当前线程在nanos时间内没有获取到同步状态，那么将会返回false，已经获取则返回true；</div><div class="line"><span class="function"><span class="title">acquireShared</span><span class="params">(int arg)</span></span>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</div><div class="line"><span class="function"><span class="title">acquireSharedInterruptibly</span><span class="params">(int arg)</span></span>：共享式获取同步状态，响应中断；</div><div class="line"><span class="function"><span class="title">tryAcquireSharedNanos</span><span class="params">(int arg, long nanosTimeout)</span></span>：共享式获取同步状态，增加超时限制；</div><div class="line"><span class="function"><span class="title">release</span><span class="params">(int arg)</span></span>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒；</div><div class="line"><span class="function"><span class="title">releaseShared</span><span class="params">(int arg)</span></span>：共享式释放同步状态；</div></pre></td></tr></table></figure></p>
<h2>同步队列CLH</h2>
<p>此外AQS内部维护着一个CLH同步队列，该队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。CLH结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/CLH.png" alt="img">
&lt;/center&gt;
在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其定义如下：
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 共享 *</span>/</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 独占 *</span>/</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">    <span class="comment">//后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> SIGNAL    = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CONDITION = <span class="number">-2</span>;</div><div class="line">    <span class="comment">//表示下一次共享式同步状态获取将会无条件地传播下去</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PROPAGATE = <span class="number">-3</span>;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 等待状态 *</span>/</span></span></div><div class="line">    volatile <span class="built_in">int</span> waitStatus;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 前驱节点 *</span>/</span></span></div><div class="line">    volatile Node prev;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 后继节点 *</span>/</span></span></div><div class="line">    volatile Node next;</div><div class="line">    <span class="comment"><span class="markdown">/<span class="emphasis">** 获取同步状态的线程 *</span>/</span></span></div><div class="line">    volatile Thread thread;</div><div class="line">    Node nextWaiter;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2>同步状态的获取与释放</h2>
<h3>独占式</h3>
<p>acquire方法为AQS提供的模板方法，该方法为独占式获取同步状态，该方法对中断不敏感，即由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法由子类去实现
addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部
acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过，其代码如下：
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</div><div class="line">        boolean failed = <span class="literal">true</span>;</div><div class="line">        try &#123;</div><div class="line">            boolean interrupted = <span class="literal">false</span>;</div><div class="line">            // 自旋，直到满足下面条件</div><div class="line">            for (;;) &#123;</div><div class="line">                final <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</div><div class="line">                // 其前驱节点是头节点并且获取同步状态成功</div><div class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">                    p</span>.next = null; // help GC</div><div class="line">                    failed = <span class="literal">false</span>;</div><div class="line">                    return interrupted;</div><div class="line">                &#125;</div><div class="line">                // 获取同步失败，等待</div><div class="line">                if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line"><span class="title">                    parkAndCheckInterrupt</span>())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (failed)</div><div class="line">                cancelAcquire(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>
<p>可以看出只有其前驱节点为头结点才能够尝试获取同步状态，原因在于1）FIFO队列2）头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点,acquire流程如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/acquire.png" alt="img">
&lt;/center&gt;
AQS提供了acquire独占式获取同步状态，但该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态。为了响应中断，AQS提供了acquireInterruptibly方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常InterruptedException：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="comment">// 中断直接跑出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</div><div class="line">            doAcquireInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> doAcquireInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 中断后抛出异常</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                    parkAndCheckInterrupt())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AQS也提供了超时处理，tryAcquireNanos，该方法为acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回false，否则返回true：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</div><div class="line">            doAcquireNanos(arg, nanosTimeout);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> doAcquireNanos(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="comment">//nanosTimeout &lt;= 0</span></div><div class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//超时时间</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</div><div class="line">        <span class="comment">//新增Node节点</span></div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//自旋</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="comment">//获取同步状态成功</span></div><div class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                    setHead(node);</div><div class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                    failed = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//重新计算需要休眠的时间</span></div><div class="line">                nanosTimeout = deadline - System.nanoTime();</div><div class="line">                <span class="comment">//已经超时，返回false</span></div><div class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>L)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//如果没有超时，则等待nanosTimeout纳秒，该线程会直接从LockSupport.parkNanos中返回</span></div><div class="line">                <span class="comment">//如果nanosTimeout &lt;= spinForTimeoutThreshold ，就不需要休眠了，直接进入快速自旋的过程。原因在于 spinForTimeoutThreshold</span></div><div class="line">                <span class="comment">//已经非常小了，非常短的时间等待无法做到十分精确直接自旋</span></div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</div><div class="line">                <span class="comment">//线程是否已经中断了，中断直接抛出异常</span></div><div class="line">                <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryAcquireNanos的流程如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/acquireNano.png" alt="img">
&lt;/center&gt;
独占式同步状态释放
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="comment">// 尝试释放，子类实现</span></div><div class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">            Node h = head;</div><div class="line">            <span class="comment">// 唤醒后继节点</span></div><div class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">                unparkSuccessor(h);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>共享式同步状态获取与释放</h3>
<p>AQS提供acquireShared方法共享式获取同步状态：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="comment">// tryAcquireShared由子类实现</span></div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">//获取失败，自旋获取同步状态</span></div><div class="line">            doAcquireShared(arg);</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        /共享式节点</div><div class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">                <span class="keyword">if</span> (p == head) &#123;</div><div class="line">                    <span class="comment">//尝试获取同步</span></div><div class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</div><div class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        setHeadAndPropagate(node, r);</div><div class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                        <span class="keyword">if</span> (interrupted)</div><div class="line">                            selfInterrupt();</div><div class="line">                        failed = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                        parkAndCheckInterrupt())</div><div class="line">                    interrupted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                cancelAcquire(node);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>阻塞与唤醒</h2>
<p>在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞，其主要方法在acquireQueued
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></div><div class="line"><span class="title">                    parkAndCheckInterrupt</span>())</div><div class="line">                    interrupted = <span class="literal">true</span>;</div><div class="line"></div><div class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //前驱节点</div><div class="line">        int ws = pred.waitStatus;</div><div class="line">        //状态为signal，表示当前线程处于等待状态，直接放回<span class="literal">true</span></div><div class="line">        if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</div><div class="line">            return <span class="literal">true</span>;</div><div class="line">        //前驱节点状态 &gt; <span class="number">0</span> ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</div><div class="line">        if (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">            do &#123;</div><div class="line">                <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</div><div class="line">            &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">            pred.next = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">        &#125; </span></div><div class="line"><span class="title">        //前驱节点状态为Condition</span>、propagate</div><div class="line">        else &#123;</div><div class="line">            compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</div><div class="line">        &#125;</div><div class="line">        return <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 shouldParkAfterFailedAcquire，该算法的步骤如下：
1）如果当前线程的前驱节点状态为SINNAL，则表明当前线程需要被阻塞，调用unpark()方法唤醒，直接返回true，当前线程阻塞
2）如果当前线程的前驱节点状态为CANCELLED（ws &gt; 0），则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false
3）如果前驱节点非SINNAL，非CANCELLED，则通过CAS的方式将其前驱节点设置为SINNAL，返回false
shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// LockSupport调用UNSAFE类park方法来挂起当前线程</span></div><div class="line">        LockSupport.park(<span class="keyword">this</span>);</div><div class="line">        <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当线程释放同步状态后需要唤醒其后继节点：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="comment">//当前节点状态</span></div><div class="line">        <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">        <span class="comment">//当前状态 &lt; 0 则设置为 0</span></div><div class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">//当前节点的后继节点</span></div><div class="line">        Node s = node.next;</div><div class="line">        <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">            s = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//从tail节点来找可用节点</span></div><div class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                    s = t;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//唤醒后继节点</span></div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能会存在当前线程的后继节点为null，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，从tail尾节点开始，原因在于node.next仍然可能会存在null或者取消了，所以采用tail回溯办法找第一个可用的线程</p>
<h2>ReentrantLock</h2>
<p>ReentrantLock，可重入锁。它可以等同于synchronized的使用，但是ReentrantLock提供了比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率.
ReentrantLock实现了Lock接口，依赖内部类Sync类来管理同步状态，Sync继承了AQS，同时Sync有2个子类，分别支持公平锁和非公平锁NonfairSync与FairSync。下面我们看看Lock的常用方法：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    sync.<span class="keyword">lock</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReentrantLock里面大部分的功能都是委托给Sync来实现的，同时Sync内部定义了lock()抽象方法由其子类去实现，默认实现了nonfairTryAcquire(int acquires)方法，可以看出它是非公平锁的默认实现方式。下面我们看非公平锁的lock()方法：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//尝试获取锁CAS</span></div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">//获取失败，调用AQS的acquire(int arg)方法,acquire在AQS中定义，子类实现tryAcquire</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">            selfInterrupt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认非公平锁</span></div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="comment">//当前线程</span></div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="comment">//state == 0,表示没有该锁处于空闲状态</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//获取锁成功，设置为当前线程所有</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//线程重入</span></div><div class="line">        <span class="comment">//判断锁持有的线程是否为当前线程，是则增加次数，可重入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>释放锁：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// release在AQS中定义，包括了tryRelease，unparkSuccessor2个主要操作</span></div><div class="line">        sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 子类实现tryRelease</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">//减掉releases</span></div><div class="line">        <span class="keyword">int</span> c = getState() - releases;</div><div class="line">        <span class="comment">//如果释放的不是持有锁的线程，抛出异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//state == 0 表示已经释放完全了，其他线程可以获取同步状态了</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            free = <span class="keyword">true</span>;</div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        setState(c);</div><div class="line">        <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>公平锁的tryAcquire方法：其实只是多了一个hasQueuedPredecessors判断，即节点是否为头节点
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">        <span class="keyword">int</span> c = getState();</div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">            setState(nextc);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node t = tail;  <span class="comment">//尾节点</span></div><div class="line">        Node h = head;  <span class="comment">//头节点</span></div><div class="line">        Node s;</div><div class="line">        <span class="comment">//头节点 != 尾节点</span></div><div class="line">        <span class="comment">//同步队列第一个节点不为null</span></div><div class="line">        <span class="comment">//当前线程是同步队列第一个节点</span></div><div class="line">        <span class="keyword">return</span> h != t &amp;&amp;</div><div class="line">                ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面我们继续分析一下Lock的阻塞和唤醒:Condition
实现等待/通知模式二种方式：1）Synchronized来控制同步，配合Object的wait()、notify()。2）Lock提供了条件Condition，其线程的等待、唤醒操作更加详细和灵活。下图是Condition与Object的监视器方法的对比
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/condition.jpg" alt="img">
&lt;/center&gt;
Condition提供了一系列的方法来对阻塞和唤醒线程：
await() ：造成当前线程在接到信号或被中断之前一直处于等待状态。
await(long time, TimeUnit unit) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。
awaitNanos(long nanosTimeout) ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout – 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。
awaitUninterruptibly() ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。
signal()：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。
signal()All：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。
Condition接口有一个实现类ConditionObject，其位于AQS内部类：
每个Condition对象都包含着一个FIFO队列，该队列是Condition对象通知/等待功能的关键。在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程,其中Node和CLH同步队列的Node相同
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</div><div class="line">        private static final long serialVersionUID = <span class="number">1173984872572414699</span>L;</div><div class="line">        /** First <span class="keyword">node</span> <span class="title">of</span> condition queue. */</div><div class="line">        private transient <span class="keyword">Node</span> <span class="title">firstWaiter</span>;</div><div class="line">        /** Last <span class="keyword">node</span> <span class="title">of</span> condition queue. */</div><div class="line">        private transient <span class="keyword">Node</span> <span class="title">lastWaiter</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列同时释放锁。当从await()方法返回时，当前线程一定是获取了Condition相关连的锁,awaitl流程：首先将当前线程新建一个节点同时加入到条件队列中，然后释放当前线程持有的同步状态。然后则是不断检测该节点代表的线程释放出现在CLH同步队列中（收到signal信号之后就会在AQS队列中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p>
<p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 当前线程中断</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="comment">//当前线程加入等待队列</span></div><div class="line">        Node node = addConditionWaiter();</div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        <span class="keyword">long</span> savedState = fullyRelease(node);</div><div class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待</span></div><div class="line"><span class="comment">         * 直到检测到此节点在同步队列上</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</div><div class="line">            <span class="comment">//线程挂起</span></div><div class="line">            LockSupport.park(<span class="keyword">this</span>);</div><div class="line">            <span class="comment">//如果已经中断了，则退出</span></div><div class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//竞争同步状态</span></div><div class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">            interruptMode = REINTERRUPT;</div><div class="line">        <span class="comment">//清理下条件队列中的不是在等待条件的节点</span></div><div class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></div><div class="line">            unlinkCancelledWaiters();</div><div class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</div><div class="line">            reportInterruptAfterWait(interruptMode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>fullyRelease(Node node)，负责释放该线程持有的锁：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">long</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//节点状态--其实就是持有锁的数量</span></div><div class="line">            <span class="keyword">long</span> savedState = getState();</div><div class="line">            <span class="comment">//调用rlease释放锁</span></div><div class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> savedState;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (failed)</div><div class="line">                node.waitStatus = Node.CANCELLED;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>isOnSyncQueue(Node node)：如果一个节点同步队列上获取锁则返回true
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final boolean isOnSyncQueue(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //状态为Condition，获取前驱节点为null，返回<span class="literal">false</span></div><div class="line">        if (<span class="keyword">node</span>.<span class="title">waitStatus</span> == <span class="keyword">Node</span>.<span class="title">CONDITION</span> || <span class="keyword">node</span>.<span class="title">prev</span> == null)</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //后继节点不为null，肯定在CLH同步队列中，</div><div class="line">        if (<span class="keyword">node</span>.<span class="title">next</span> != null)</div><div class="line">            return <span class="literal">true</span>;</div><div class="line"></div><div class="line">        return findNodeFromTail(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>
<p>通知唤醒：
调用Condition的signal()方法，将会唤醒在等待队列里的头节点，在唤醒节点前，会将节点移到CLH同步队列中
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public final void signal() &#123;</div><div class="line">        //检测当前线程是否为拥有锁的独</div><div class="line">        if (!isHeldExclusively())</div><div class="line">            throw new IllegalMonitorStateException();</div><div class="line">        //头节点，唤醒条件队列中的第一个节点</div><div class="line">        <span class="keyword">Node</span> <span class="title">first</span> = firstWaiter;</div><div class="line">        if (first != null)</div><div class="line">            doSignal(first);    //唤醒</div><div class="line">&#125;</div><div class="line">//doSignal(<span class="keyword">Node</span> <span class="title">first</span>)主要是做两件事：<span class="number">1</span>.修改头节点，<span class="number">2</span>.调用transferForSignal(<span class="keyword">Node</span> <span class="title">first</span>) 方法将节点移动到CLH同步队列中</div><div class="line">private void doSignal(<span class="keyword">Node</span> <span class="title">first</span>) &#123;</div><div class="line">        do &#123;</div><div class="line">            //修改头结点，完成旧头结点的移出工作</div><div class="line">            if ( (firstWaiter = first.nextWaiter) == null)</div><div class="line">                lastWaiter = null;</div><div class="line">            first.nextWaiter = null;</div><div class="line">        &#125; while (!transferForSignal(first) &amp;&amp;</div><div class="line">                (first = firstWaiter) != null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</div><div class="line">        //将该节点从状态CONDITION改变为初始状态<span class="number">0</span>,</div><div class="line">        if (!compareAndSetWaitStatus(<span class="keyword">node</span><span class="title">, Node</span>.CONDITION, <span class="number">0</span>))</div><div class="line">            return <span class="literal">false</span>;</div><div class="line">        //将节点加入到CLH队列中去，返回的是CLH队列中<span class="keyword">node</span><span class="title">节点前面的一个节点</span></div><div class="line"><span class="title">        Node</span> p = enq(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">        int</span> ws = p.waitStatus;</div><div class="line">        //如果结点p的状态为cancel 或者修改waitStatus失败，则直接唤醒</div><div class="line">        if (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</div><div class="line">            LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</div><div class="line">        return <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Condition总结：一个线程获取锁后，通过调用Condition的await()方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过isOnSyncQueue(Node node)方法不断自检看节点是否已经在CLH同步队列了，如果是则尝试获取锁，否则一直挂起。当线程调用signal()方法后，程序首先检查当前线程是否获取了锁，然后通过doSignal(Node first)方法唤醒条件队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</p>
<h2>CountDownLatch</h2>
<p>CountDownLatch功能：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待
CountDownlatch与CyclicBarrier区别：
1）CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待
2）CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier
CountDownLatch在实现上同样依赖内部类Sync，Sync继承AQS，CountDownLatch仅有一个int类型的构造函数
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CountDownLatch(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</div><div class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(<span class="keyword">count</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374</span>L;</div><div class="line"></div><div class="line">        Sync(<span class="keyword">int</span> <span class="keyword">count</span>) &#123;</div><div class="line">            setState(<span class="keyword">count</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">int</span> getCount() &#123;</div><div class="line">            <span class="keyword">return</span> getState();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//获取同步状态</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> tryAcquireShared(<span class="keyword">int</span> acquires) &#123;</div><div class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//释放同步状态</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> releases) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> c = getState();</div><div class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">int</span> nextc = c<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个内部类Sync我们可以清楚地看到CountDownLatch是采用共享锁来实现的,下面我们看看它的核心方法await方法：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//AQS定义acquireSharedInterruptibly</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="comment">//tryAcquireShared见上面Sync类内部，若state不为0（countdown未减为0）则调用AQS的doAcquireSharedInterruptibly方法自旋等待同步状态</span></div></pre></td></tr></table></figure></p>
<p>countdown方法：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// releaseShared见上面Sync内部，若state为0直接返回fasle，若countdown减1后为0，则调用AQS的doReleaseShared唤醒，await继续执行</span></div></pre></td></tr></table></figure></p>
<h2>Semaphore</h2>
<p>Semaphore的实现也是依赖Sync，包含公平锁（FairSync）和非公平锁（NonfairSync），继承内部类Sync，其中Sync继承AQS
Semaphore提供了两个构造函数：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建具有给定的许可数和非公平的公平设置的 Semaphore,默认非公平</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</div><div class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建具有给定的许可数和给定的公平设置的 Semaphore</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过acquire来获取信号量：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 共享的可中断</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS定义的 acquireSharedInterruptibly，依赖sync实现的tryAcquireShared</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> acquireSharedInterruptibly(<span class="keyword">int</span> arg)</div><div class="line">            <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</div><div class="line">            doAcquireSharedInterruptibly(arg);</div><div class="line">&#125;</div><div class="line"><span class="comment">//  公平的tryAcquireShared</span></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">//判断该线程是否位于CLH队列的列头</span></div><div class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            <span class="comment">//获取当前的信号量许可</span></div><div class="line">            <span class="keyword">int</span> available = getState();</div><div class="line"></div><div class="line">            <span class="comment">//设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span></div><div class="line">            <span class="keyword">int</span> remaining = available - acquires;</div><div class="line"></div><div class="line">            <span class="comment">//CAS设置信号量</span></div><div class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                <span class="keyword">return</span> remaining;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 非公平的tryAcquireShared方法，少了一个头节点的判断</span></div><div class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> available = getState();</div><div class="line">                <span class="keyword">int</span> remaining = available - acquires;</div><div class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</div><div class="line">                    compareAndSetState(available, remaining))</div><div class="line">                    <span class="keyword">return</span> remaining;</div><div class="line">            &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>信号量释放：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        sync.releaseShared(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS的releaseShared，子类sync实现tryReleaseShared</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</div><div class="line">            doReleaseShared();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> current = getState();</div><div class="line">            <span class="comment">//信号量的许可数 = 当前信号许可数 + 待释放的信号许可数</span></div><div class="line">            <span class="keyword">int</span> next = current + releases;</div><div class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</div><div class="line">            <span class="comment">//设置可获取的信号许可数为next</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>CyclicBarrier</h2>
<p>CyclicBarrier：允许一组线程互相等待，直到到达某个公共屏障点。在一组固定大小的线程的程序中，这些线程必须不时地互相等待，barrier 在释放等待线程后可以重用。
构造函数：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="comment">// barrier数量</span></div><div class="line">        <span class="keyword">this</span>.parties = parties;</div><div class="line">        <span class="keyword">this</span>.count = parties;</div><div class="line">        <span class="comment">// 最后到达公共屏障点执行的任务</span></div><div class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用lock和condition来管理同步状态</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</div></pre></td></tr></table></figure></p>
<p>最重要的wait方法：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="function"><span class="keyword">return</span> <span class="title">dowait</span><span class="params">(<span class="keyword">false</span>, <span class="number">0</span>L)</span></span>;<span class="comment">//不超时等待</span></div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> dowait(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</div><div class="line">            <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</div><div class="line">            TimeoutException &#123;</div><div class="line">        <span class="comment">//获取锁</span></div><div class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//分代</span></div><div class="line">            <span class="keyword">final</span> Generation g = generation;</div><div class="line"></div><div class="line">            <span class="comment">//当前generation“已损坏”，抛出BrokenBarrierException异常</span></div><div class="line">            <span class="comment">//抛出该异常一般都是某个线程在等待某个处于“断开”状态的CyclicBarrie</span></div><div class="line">            <span class="keyword">if</span> (g.broken)</div><div class="line">                <span class="comment">//当某个线程试图等待处于断开状态的 barrier 时，或者 barrier 进入断开状态而线程处于等待状态时，抛出该异常</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">            <span class="comment">//如果线程中断，终止CyclicBarrier</span></div><div class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//进来一个线程 count - 1</span></div><div class="line">            <span class="keyword">int</span> index = --count;</div><div class="line">            <span class="comment">//count == 0 表示所有线程均已到位，触发Runnable任务</span></div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></div><div class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</div><div class="line">                    <span class="comment">//触发任务</span></div><div class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</div><div class="line">                        command.run();</div><div class="line">                    ranAction = <span class="keyword">true</span>;</div><div class="line">                    <span class="comment">//唤醒所有等待线程，并更新generation</span></div><div class="line">                    nextGeneration();</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 自旋直到所有线程到达，超时，broken，中断</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//如果不是超时等待，则调用Condition.await()方法等待</span></div><div class="line">                    <span class="keyword">if</span> (!timed)</div><div class="line">                        trip.await();</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>L)</div><div class="line">                        <span class="comment">//超时等待，调用Condition.awaitNanos()方法等待</span></div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</div><div class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        <span class="keyword">throw</span> ie;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></div><div class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></div><div class="line">                        <span class="comment">// "belong" to subsequent execution.</span></div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (g.broken)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</div><div class="line"></div><div class="line">                <span class="comment">//generation已经更新，返回index</span></div><div class="line">                <span class="keyword">if</span> (g != generation)</div><div class="line">                    <span class="keyword">return</span> index;</div><div class="line"></div><div class="line">                <span class="comment">//“超时等待”，并且时间已到,终止CyclicBarrier，并抛出异常</span></div><div class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//释放锁</span></div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>await处理流程：
如果该线程不是到达的最后一个线程，则他会一直处于等待状态，除非发生以下情况：
最后一个线程到达，即index == 0
超出了指定时间（超时等待）
其他的某个线程中断当前线程
其他的某个线程中断另一个等待的线程
其他的某个线程在等待barrier超时
其他的某个线程在此barrier调用reset()方法。reset()方法用于将屏障重置为初始状态
此外，Generation描述着CyclicBarrier的更显换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier，generation就会被更新换代。其中broken标识该当前CyclicBarrier是否已经处于损坏状态。
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程,在breakBarrier()中除了将broken设置为true，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void <span class="keyword">breakBarrier() </span>&#123;</div><div class="line">        generation.<span class="keyword">broken </span>= true<span class="comment">;</span></div><div class="line">        <span class="built_in">count</span> = parties<span class="comment">;</span></div><div class="line">        trip.signalAll()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当所有线程都已经到达barrier处（index == 0），则会通过nextGeneration()进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置count，generation
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</div><div class="line">        trip.signalAll();</div><div class="line">        count = parties;</div><div class="line">        generation = <span class="keyword">new</span> Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>总结</h2>
<p>AQS作为Java并发基础的框架提供获取状态，acquire，release等公共方法，子类通过实现具体的逻辑来达到不同的同步目的，此外Lock，CyclicBarrier，Semaphore，CountDownLatch作为最基础的同步类为其他同步类提供了基础。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/05/21/btree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/btree/" itemprop="url">B Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T20:48:59+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/21/btree/" class="leancloud_visitors" data-flag-title="B Tree">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>背景</h2>
<p>动态查找树：BST，AVL，红黑树，B树，B+树等。前三种属于二叉查找树，查找效率与树的深度d有关，降低树的高度可以提升查找效率！
在实际大规模存储过程中，数据量往往很大，树存储数据量有限，所以造成树的深度很大，而且也很难直接放在内存中直接处理。所以导致树的深度很大，多次查找硬盘I／O过于频繁，查询效率较低，所以降低树的深度很重要，那么就需要采用多叉树结构！而B树使得树深度较低，所以查找效率较高！
&lt;!--more--&gt;</p>
<h2>磁盘</h2>
<p>磁盘作为外存储器，读取效率比内存慢很多，它的结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/disk.png" alt="img">
&lt;/center&gt;
磁盘有多个盘片组成，盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了，每个盘面有一个磁头，它可以从一个磁到移到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。
磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。读/写磁盘上某一指定数据需要下面3个步骤：
(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。
(2)  如上图11.3中所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。
(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。
访问某一具体信息，由3部分时间组成：
● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。
● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一）因此一般旋转一圈大约0.0083s。
● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s
磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts</p>
<p>##B-树</p>
<p>B-树是一种多路查找树，能极大降低树的深度，许多数据库系统都一般使用B树或者B树的各种变形结构。B-树的定义如下：
一颗m阶的b-树结构
1）若根结点不是叶子结点，则至少有2个孩子，最多含有m个孩子（m&gt;=2）（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）
2）除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子，最多含有m个孩子（其中ceil(x)是一个取上限的函数）；
3）所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)
4）每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：
a)   Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki
b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)
c)   关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1</p>
<p>一颗3阶B树示例如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btree.png" alt="img">
&lt;/center&gt;
首先节点定义为：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="comment">/*文件数*/</span> 关键字个数</div><div class="line">    <span class="keyword">int</span>  file_num;</div><div class="line">    <span class="comment">/*文件名(key)*/</span>  即 key</div><div class="line">    <span class="keyword">char</span> * file_name[max_file_num];</div><div class="line">    <span class="comment">/*指向子节点的指针*/</span>  孩子指针</div><div class="line">     BTNode * BTptr[max_file_num+<span class="number">1</span>];</div><div class="line">     <span class="comment">/*文件在硬盘中的存储位置*/</span>  实际数据磁盘地址</div><div class="line">     FILE_HARD_ADDR offset[max_file_num];</div><div class="line">&#125;BTNode;</div></pre></td></tr></table></figure></p>
<p>B树包含N个关键字时，最大深度为：h=log┌m/2┐((N+1)/2 )+1，每一个非叶子结点含有ceil（m／2）个孩子</p>
<h3>插入过程</h3>
<pre><code>插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。
</code></pre>
<p>以一颗5阶B-树来展示插入过程：
插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S
（1）首先根节点空间充足，直接插入4个节点<br>
（2）插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中
（3）插入E,K,Q时，不需要任何分裂操作
（4）插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btree1.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree2.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree3.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree4.png" alt="img">
&lt;/center&gt;
（5）插入F,W,L,T不需要任何分裂操作
（6）插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中
（7）插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作
（8）当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btree5.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree6.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree7.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree8.png" alt="img">
&lt;/center&gt;</p>
<h3>删除操作</h3>
<p>找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况
删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）（还记得第一节中关于B树的第5个特性中的c点么?： c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： （ceil(m / 2)-1）&lt;= n &lt;= m-1。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：2&lt;=n&lt;=4），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点。</p>
<p>下面看删除H,T,R,E过程：
（9）首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）
（10）删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作
（11）删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btree9.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree10.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btree11.png" alt="img">
&lt;/center&gt;</p>
<p>（12）删除E， 删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点
然后发现父节点只包含一个元素G，没达标（因为非根节点包括叶子结点的关键字数n必须满足于2=&lt;n&lt;=4，而此处的n=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btree12.png" alt="img">
&lt;/center&gt;</p>
<p>在看一个删除操作：5阶B树，删除C
（a）先删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。
（b）这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B树结构性质
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btreea.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btreeb.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/btreec.png" alt="img">
&lt;/center&gt;</p>
<h2>B+树</h2>
<p>特点:
(1）有n棵子树的结点中含有n-1 个关键字
(2）所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
(3）所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/btree+.png" alt="img">
&lt;/center&gt;</p>
<p>优点：
（1）B+-tree的磁盘读写代价更低
B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
（2）B+-tree的查询效率更加稳定
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
（3）B+树支持范围查询
B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</p>
<h2>总结</h2>
<p>B树：有序数组+平衡多叉树；
B+树：有序数组链表+平衡多叉树；
（1）对于单个查询，b树可能更早的返回数据，因为内节点也存储了数据信息，而b+树需要查到叶子结点，但是b+树节点需要更少的空间所以磁盘I／O会少一点，除此之外，b+树支持范围查询和扫描，所以更加方便！
（2）b树和b+树在内存中没有任何优势，不如AVL和红黑树，但是在磁盘降低了树的深度，其I／O次数明显减少，所以大大降低了查询时间，被广泛用于数据库索引（Mysql）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/05/21/clone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/clone/" itemprop="url">Clone</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T20:06:49+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/21/clone/" class="leancloud_visitors" data-flag-title="Clone">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>背景</h2>
<p>Clone是Object类下的一个方法，用于产生一个创建一个新的对象副本。clone主要分为深复制和浅复制，下面我们分别介绍clone如何工作，以及如何实现深复制和浅复制。
&lt;!--more--&gt;
克隆对象
clone方法会返回原始对象的一个副本，一个良好的clone准则往往满足以下三个基本原则：
（1）a.clone()!=a  克隆对象与原对象在heap上是两个独立的对象
（2）a.clone().getClass()==a.getClass()    克隆的对象必须与原对象类型一致
（3）a.clone().equals(a)    两个对象要想等
这些并非强制要求，为了达到第三个目的，可能要重写equals方法。</p>
<p>clone工作过程
Object类提供了clone实现，它被声明为protect native，它的具体实现由本地代码完成，对象的复制通过super.clone()来完成。所以任何对象的复制最终通过一系列的调用到达Object的clone方法，它首先会检查当前类是否实现了Cloneable接口，如果没有实现则抛出CloneNotSupportted异常，该异常是一个受检异常。若该类实现了接口，则调用Object的clone方法创建一个拷贝给调用者。而这一过程通过创建一个新对象，然后将对象的各个域直接复制过来的，对于原始的类型和不可变类型这种方式没有任何问题，但对于可变的类型和引用类型，它们将指向相同的对象，所以在修改时容易相互影响。所以Object的clone是一种浅复制，必须覆盖clone方法来实现深复制。</p>
<h2>Example：</h2>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> standard;</div><div class="line"><span class="comment">/** * Created by fuyang on 2017/5/15. */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] money;    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span>[] money, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.money = money;       </div><div class="line">        <span class="keyword">this</span>.age = age;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMoney() &#123;</div><div class="line">        <span class="keyword">return</span> money;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.money[<span class="number">0</span>] = money;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(money.clone(),<span class="keyword">this</span>.age);</div><div class="line">    <span class="comment">//          return super.clone();    </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Student student=<span class="keyword">new</span> Student(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">100</span>&#125;,<span class="number">25</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Student cloneStu=(Student) student.clone();</div><div class="line">            System.out.println(cloneStu.getMoney()[<span class="number">0</span>]);</div><div class="line">            student.setMoney(<span class="number">200</span>);</div><div class="line">            System.out.println(student.getMoney()[<span class="number">0</span>]);</div><div class="line">            System.out.println(cloneStu.getMoney()[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果：</div><div class="line"><span class="number">100</span></div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">100</span></div><div class="line">改为  <span class="keyword">super</span>.clone();</div><div class="line">则：</div><div class="line"><span class="number">100</span></div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure></p>
<h2>Tips：</h2>
<ul>
<li>克隆方法用于创建对象的拷贝，为了使用clone方法，类必须实现java.lang.Cloneable接口重写protected方法clone，如果没有实现Clonebale接口会抛出CloneNotSupportedException</li>
<li>在克隆java对象的时候不会调用构造器</li>
<li>java提供一种叫浅拷贝（shallow copy）的默认方式实现clone，创建好对象的副本后然后通过赋值拷贝内容，意味着如果你的类包含可变对象，那么原始对象和克隆都将指向相同的内部对象，这是很危险的，因为发生在可变的字段上任何改变将反应到原始对象和副本对象上。为了避免这种情况，重写clone()方法。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/05/20/avl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/avl/" itemprop="url">AVL树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T20:39:02+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/20/avl/" class="leancloud_visitors" data-flag-title="AVL树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>定义：首先是BST，而且任何一个节点的左子树和右子树高度差不超过1
&lt;!--more--&gt;</p>
<h2>AVL定义：</h2>
<p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AvlTree&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="type">AvlTreeNode</span> root;</div><div class="line">    public <span class="type">AvlTree</span>() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AvlTreeNode&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="type">T</span> key;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> int height;</div><div class="line">        <span class="keyword">private</span> <span class="type">AvlTreeNode</span>&lt;<span class="type">T</span>&gt; left;</div><div class="line">        <span class="keyword">private</span> <span class="type">AvlTreeNode</span>&lt;<span class="type">T</span>&gt; right;</div></pre></td></tr></table></figure></p>
<p>AVL树在插入和删除时会改变它的平衡结构，具体的不平衡情况如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/avl1.png" alt="img">
&lt;/center&gt;</p>
<ul>
<li>LL：节点左子树的左子树的高度高</li>
<li>LR：节点左子树的右子树的高度高</li>
<li>RL：节点右子树的左子树的高度高</li>
<li>RR：节点右子树的右子树的高度高</li>
</ul>
<h2>AVL的旋转</h2>
<pre><code>为了保持平很需要进行旋转操作来保持平衡，4种不平衡情况具体的旋转操作情况如下：
</code></pre>
<p>（1）LL与RR
<img src="http://oqcre1dsl.bkt.clouddn.com/avl2.png?imageMogr2/thumbnail/!60p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/avl3.png?imageMogr2/thumbnail/!60p" alt="img">
LL旋转操作比较简单，只需要将不平衡的节点k2向右旋转，使得其左孩子k1成为“根”节点，然后k2成为其右孩子，k1的右子树称为k2的左子树，此时树已经平衡了，最后把k1和k2的高度进行更新
RR以此类似，只需要把k2向左旋转
LL旋转：
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode leftLeftRotation(AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line"><span class="title">    AvlTreeNode</span> <span class="tag">&lt;T&gt;</span>left = <span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">    <span class="keyword">node</span>.<span class="title">left</span> = left.right;</div><div class="line">    left.right = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">    node</span>.height = Math.max(height(<span class="keyword">node</span>.<span class="title">left</span>), height(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    left.height = Math.max(<span class="keyword">node</span>.<span class="title">height</span>, height(left.left)) + <span class="number">1</span>;</div><div class="line">    return left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RR旋转：
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode rightRightRotation(AvlTreeNode<span class="tag">&lt;T&gt;</span> <span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line"><span class="title">    AvlTreeNode</span> <span class="tag">&lt;T&gt;</span>right = <span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">    <span class="keyword">node</span>.<span class="title">right</span> = right.left;</div><div class="line">    right.left = <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">    node</span>.height = Math.max(height(<span class="keyword">node</span>.<span class="title">left</span>), height(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    right.height = Math.max(<span class="keyword">node</span>.<span class="title">height</span>, height(right.right)) + <span class="number">1</span>;</div><div class="line">    return right;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）LR与RL
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/avl4.png" alt="img">
&lt;/center&gt;
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/avl5.png" alt="img">
&lt;/center&gt;
LR的旋转稍微复杂一点，首先对不平衡节点k3的左孩子k1进行一次“RR”旋转，这样树变成了LL不平衡状态，再进行一次“LL”旋转即可达到平衡
同样RL的旋转情况与之一一对应，先进行一次“LL”旋转然后进行一次“RR”旋转
LR与RL旋转：
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode leftRightRotation(AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    node</span>.<span class="attr">left=</span>rightRightRotation(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">    return leftLeftRotation(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div><div class="line"><span class="title"></span></div><div class="line"><span class="title">public</span> AvlTreeNode rightLeftRotation(AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    node</span>.<span class="attr">right=</span>leftLeftRotation(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">    return rightRightRotation(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>
<p>插入节点
插入过程和BST一样，但它会导致树不平衡，所以需要旋转来维持树的平衡：递归查询插入点，然后判断是否平衡，并根据不平衡类型做相应的旋转
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode insert(T key, AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    if</span>(<span class="keyword">node</span><span class="title">==null</span>)&#123;</div><div class="line">        <span class="keyword">node</span><span class="title">=new</span> AvlTreeNode(key);</div><div class="line">        return <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">    &#125;</span></div><div class="line"><span class="title">    if</span>(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)==<span class="number">0</span>)&#123;</div><div class="line">        throw new RuntimeException(<span class="string">"节点值重复了"</span>);</div><div class="line">    &#125;else if(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">left</span>=insert(key,<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        if(height(<span class="keyword">node</span>.<span class="title">left</span>)-height(<span class="keyword">node</span>.<span class="title">right</span>)&gt;<span class="number">1</span>)&#123;</div><div class="line">            if(<span class="keyword">node</span>.<span class="title">left</span>.key.compareTo(key)&gt;<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">node</span><span class="title">= leftLeftRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;else</span> &#123;</div><div class="line">                <span class="keyword">node</span><span class="title">= leftRightRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">    &#125;else</span> &#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">right</span>=insert(key,<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        if(height(<span class="keyword">node</span>.<span class="title">right</span>)-height(<span class="keyword">node</span>.<span class="title">left</span>)&gt;<span class="number">1</span>)&#123;</div><div class="line">            if(<span class="keyword">node</span>.<span class="title">right</span>.key.compareTo(key)<span class="tag">&lt;0)&#123;</span></div><div class="line"><span class="tag">                node=rightRightRotation(node);</span></div><div class="line"><span class="tag">            &#125;else &#123;</span></div><div class="line"><span class="tag">                node=rightLeftRotation(node);</span></div><div class="line"><span class="tag">            &#125;</span></div><div class="line"><span class="tag">        &#125;</span></div><div class="line"><span class="tag">    &#125;</span></div><div class="line"><span class="tag">    node.height=Math.max(height(node.left),height(node.right))+1;</span></div><div class="line"><span class="tag">    return node;</span></div><div class="line"><span class="tag">&#125;</span></div></pre></td></tr></table></figure></p>
<p>删除过程
删除过程首先定位到删除的节点，找出最“接近”（左子树高则选择左子树最大节点，然后处理左子树使其平衡，然后递归向上判断平衡；同样对于右子树高的情况，先找出右子树最小的节点来替代当前点，然后处理右子树使其平衡，最后递归向上使其平衡）的节点来替换它，最后处理子树平衡再向上递归处理不平衡
代码如下：
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public AvlTreeNode remove(T key,AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="keyword">node</span><span class="title">)&#123;</span></div><div class="line"><span class="title">    if</span>(<span class="keyword">node</span><span class="title">==null</span>||<span class="attr">key=</span>=null)&#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    if(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">left</span>=remove(key,<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        if(height(<span class="keyword">node</span>.<span class="title">right</span>)-height(<span class="keyword">node</span>.<span class="title">left</span>)&gt;<span class="number">1</span>)&#123;</div><div class="line">            if(height(<span class="keyword">node</span>.<span class="title">right</span>.left)&gt;height(<span class="keyword">node</span>.<span class="title">right</span>.right))&#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=rightLeftRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;else</span> &#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=rightRightRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">    &#125;else</span> if(<span class="keyword">node</span>.<span class="title">key</span>.compareTo(key)<span class="tag">&lt;0)&#123;</span></div><div class="line"><span class="tag">        node.right=remove(key,node.right);</span></div><div class="line"><span class="tag">        if(height(node.left)-height(node.right)&gt;</span><span class="number">1</span>)&#123;</div><div class="line">            if(height(<span class="keyword">node</span>.<span class="title">left</span>.left)&gt;=height(<span class="keyword">node</span>.<span class="title">left</span>.right))&#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=leftLeftRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;else</span> &#123;</div><div class="line">                <span class="keyword">node</span><span class="title">=leftRightRotation</span>(<span class="keyword">node</span><span class="title">);</span></div><div class="line"><span class="title">            &#125;</span></div><div class="line"><span class="title">        &#125;</span></div><div class="line"><span class="title">    &#125;else</span>&#123;</div><div class="line">        if(<span class="keyword">node</span>.<span class="title">left</span>==null)&#123;</div><div class="line">            AvlTreeNode <span class="attr">tmp=</span><span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">            node</span>=<span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">            tmp.<span class="attr">right=</span>null;</div><div class="line">        &#125;</div><div class="line">        else if(<span class="keyword">node</span>.<span class="title">right</span>==null)&#123;</div><div class="line">            AvlTreeNode <span class="attr">tmp=</span><span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">            node</span>=<span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">            tmp.<span class="attr">left=</span>null;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            if(height(<span class="keyword">node</span>.<span class="title">left</span>)&gt;height(<span class="keyword">node</span>.<span class="title">right</span>))&#123;</div><div class="line">                AvlTreeNode<span class="tag">&lt;T&gt;</span> <span class="attr">tmp=</span><span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">                while(tmp.right!=null)&#123;</div><div class="line">                    <span class="attr">tmp=</span>tmp.right;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">node</span>.<span class="title">key</span>=tmp.key;</div><div class="line">                <span class="keyword">node</span>.<span class="title">left</span>=remove(tmp.key,<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">            &#125;else&#123;</div><div class="line">                AvlTreeNode <span class="tag">&lt;T&gt;</span><span class="attr">tmp=</span><span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">                while(tmp.left!=null)&#123;</div><div class="line">                    <span class="attr">tmp=</span>tmp.left;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">node</span>.<span class="title">key</span>=tmp.key;</div><div class="line">                <span class="keyword">node</span>.<span class="title">right</span>=remove(tmp.key,<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(<span class="keyword">node</span><span class="title">!=null</span>) &#123;</div><div class="line">        <span class="keyword">node</span>.<span class="title">height</span> = Math.max(height(<span class="keyword">node</span>.<span class="title">left</span>), height(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    return <span class="keyword">node</span><span class="title">;</span></div><div class="line"><span class="title">&#125;</span></div></pre></td></tr></table></figure></p>
<h2>总结</h2>
<p>AVL插入删除过程需要处理平衡，删除过程较复杂。所以效率比BST低，但是查询操作稳定为O(lgn)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/01/21/design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/21/design/" itemprop="url">常用设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-21T20:01:51+08:00">
                2017-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/01/21/design/" class="leancloud_visitors" data-flag-title="常用设计模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>设计模式程序员写出优雅、结构优雅代码的必备基础，以下是研发中常见的一些设计模式！
&lt;!--more--&gt;</p>
<h2>适配器与外观模式</h2>
<p>适配器模式定义：将一个类的接口转化成客户期望的另一个接口，使得原本接口不兼容的类可以合作。</p>
<p>适配器使用过程：
（1）客户通过调用适配器的方法对适配器发出请求
（2）适配器使用被适配者接口把请求转化成被适配者的一个或多个调用接口
（3）客户接受调用的结果，并未察觉这是适配器起转换作用</p>
<p>适配器可以适配多个类，同时若一个系统存在新接口的同时也存在旧的接口，并且新旧接口都在使用，那么适配器可以同时实现2个接口，则适配器既可以当新的接口也可以当旧的接口使用。适配器结构图如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/adapter.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
适配器模式分为对象适配器和类适配器2种模式：对象适配器使用了组合的方式，委托给被调用者来实现，同时对象适配器可以适配类的所有子类；类适配器使用了多继承的方式，适配器继承了适配者和被适配者，所以它不需要实现被适配者，必要时候也可以覆盖被适配者的行为，但在java中不支持多继承！</p>
<p>适配器 VS 装饰者 VS 外观模式
装饰者 ：与责任相关，不改变原有的接口，加入新的责任和功能，可以包装多次
适配器 ：将接口转化为另一种接口，无需改变原有的代码
外观 ：让接口更简单，对子系统进行了封装</p>
<h2>外观模式</h2>
<p>外观模式定义：提供了一个统一的接口，用来访问子系统的一群接口。
外观定义了一个高层接口，让子系统更容易使用而不会修改它，当然你也可以直接使用子系统。外观模式使得客户实现从子系统中解耦，当以后系统升级改变时，只需要修改外观代码而不用修改客户代码。其中重要的一点是：适配器和外观模式都可以使用多个类，差别在于适配器改变原有的接口来满足需求，而外观模式简化了接口来访问子系统。</p>
<p>最小知识原则：只和你的密友谈话，注意和你交互的类有哪些，不要将过多的类耦合在一起。
要求：对于一个对象，最好应该只调用以下范围的方法
（1）该对象本身
（2）作为方法的参数传递进来的对象
（3）对象的任何组件
（4）方法内创建和实例化的对象</p>
<h2>装饰者模式</h2>
<p>解决的问题：开放-关闭原则（类应该对扩展开放，对修改关闭）
装饰者模式定义：动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案
装饰者模式意味着一群装饰者类，这些类用来包装具体组件，装饰者反映出被装饰组件的类型，事实上他们具有相同的类型（实现统一接口或集成同一超类），同时装饰者可以在被装饰者行为前后加上自己的行为来达到特定的目的，装饰者一般对组件的客户是透明的，具体的结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/decorate1.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
其中Compoment是基本组件，ConcreteComponent是具体需要装饰的对象，Decorator是装饰者抽象类，ConcrereDecoratorA／B是具体的装饰者类，用来包装ConcreteComponent，他们都继承与Component。</p>
<p>以星巴克咖啡为例：有多种饮料和调料，如何来描述和计算价格，若采用继承机构将会出现大量的类并且难于维护（计算价格特别麻烦），采用装饰者模式的结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/decorate2.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
同时jdk中的IO也是典型的装饰者模式，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/decorate3.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
装饰者模式缺点：虽然比继承更容易扩展，但是会导致设计中出现许多的小对象，如果过度使用会让程序较为复杂，难于理解。</p>
<h2>工厂模式</h2>
<p>工厂模式定义：
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。即工厂方法让类把实例化推迟到子类。
另一种看法：工厂方法将生产知识封装进各个创建者，创建者和产品是一种平行的类层级，以生产pizza为例，层次结构如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/factory1.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
抽象工厂模式定义：
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定类。
该模式使得客户不需要知道具体的产品是什么，客户从具体的产品中被解耦。
以pizza为例：如下图所示
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/factory2.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
工厂模式 vs 抽象工厂模式
工厂模式：利用继承方式，通过子类来实例化具体的产品
抽象工厂模式：利用组合方式，创建一个创建产品的抽象类，该类型子类定义了产品被产生的方法，然后实例化该工厂来产生具体的产品</p>
<h2>观察者模式</h2>
<p>OO原则
（1）封装变化
（2）多用组合（几个对象协同工作），少用继承
（3）针对接口编程，不针对实现编程
（4）为交互对象之间的松耦合设计不断努力</p>
<p>观察者模式定义
定义对象之间的一对多耦合，这样以来，当一个对象的状态变化时，它的所有依赖者都能收到通知并自动更新
该模式主要包含2部分：主题Subject、观察者Observer，主题负责提供对象的状态，增加删除观察者，并把对象的变化状态通知给观察者，具体的模式信息如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/observer1.png?imageMogr2/thumbnail/!40p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/observer2.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
以气象发布战为力例子，模式设计图如上所示：
weatherData实现Subject接口，实现register、remove（list持有对观察者的引用）、notify（调用所有观察者update方法通知他们）三个主要方法，CurrentCondition实现Observer借口实现update方法。
jdk中java.util.Observable java.util.Observer分别充当了主题和观察者角色，所以在实现该模式时无需自己实现细节，可以利用jdk来实现自己的观察者模式。</p>
<p>jdk观察者模式缺点：
（1）Observable是一个抽象类而不是借口，应该多使用接口而非抽象类，不利于扩展
（2）setChanged是一个protected方法，只能继承observable，否则不能通知观察者，不够灵活</p>
<p>可以借鉴jdk思想实现自己的通知方式，灵活使用观察者模式。</p>
<h2>代理模式</h2>
<p>代理模式的结构如下图：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/proxys.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
代理类Proxy和被代理类RealSubject都实现了同一接口，proxy负责realSubject的访问和控制。</p>
<p>JAVA中的代理RMI
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/javaproxy.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
RMI使用步骤：
（1）制作远程接口：扩展java.rmi.Remote所有方法都抛出异常RemoteException，确定变量和返回值都是可序列化的
（2）制作远程实现：实现远程接口，构造一个不带参数构造函数并声明RemoteException，利用rmi registry注册此服务
（3）利用rmic产生stub、skeleton：在远程实现类（非接口）执行rmic，执行rmiregistry，启动服务（注册对象）
（4）启动rmi registry（rmiregistry，使得客户可以查到代理的位置）
（5）开始远程服务</p>
<p>注意点：
（1）在启用远程服务前必须先启用rmiregistry
（2）变量和返回值都必须是可序列化的，否则运行时会出错
（3）客户在lookup代理时，必须有stub类（由rmic产生），否则stub对象无法被反序列化，客户端需要调用远程对象返回的序列化对象！
（4）服务端游stub与skeleton类，需要stub是因为stub是真正服务对象的替身，当对象被绑定时，真正绑定的对象是服务端的stub对象!</p>
<p>JDK中的动态代理 Proxy与InvocationHandler
InvocationHandler起辅助作用，将proxy产生的代理类请求交给真正对象去处理，具体的结构图如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/javaproxys.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h2>迭代器与组合模式</h2>
<p>迭代器模式定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示！
迭代器将元素游走遍历的职责交给迭代器，而不是聚合对象，这样简化了聚合接口的实现，让责任各得其所。</p>
<p>迭代器结构图如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/iterator.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
单一职责：一个类应该只有一个引起变化的原因
尽量让每个类保持单一责任</p>
<p>组合模式定义：允许你将对象组合成树形结构来表现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合（处理时忽略对象组合和个别对象之间的差异。</p>
<p>组合模式往往需要一个抽象类，类中的方法对于叶子结点和组合节点不同，有些方法适用于叶子结点，而有些节点适用于组合节点，所以在处理时根据情况覆盖抽象类方法，有时候还需要处理异常情况，否则需要进行类型判断对用户不再透明！</p>
<h2>单例模式</h2>
<p>单例模式定义：
只能创建一个对象，保证线程安全，提供全局访问点
注意点：线程安全、效率、私有构造函数、静态对象</p>
<p>方法：急切加载 、double-check(voliate)、枚举、静态内部类(静态私有内部类，final私有staic变量)
推荐后两者</p>
<h2>状态模式</h2>
<p>定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类！
使用方法：
（1）定义一个State接口，每一个接口都有一个对应的方法
（2）为系统中每一个状态实现State接口实现状态类，这些状态类负责相应状态下系统的行为
（3）将动作委托到状态类</p>
<p>系统状态可以被多个Context共享，将状态设计为静态变量</p>
<p>状态模式结构图如下所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/state.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;</p>
<h2>模版方法模式</h2>
<p>定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得之类可以在不改变算法结构的情况下，重新定义算法中的某些步骤，即由子类实现算法的部分实现！
JDK中Arrays.sort方法中comparable将compareTo方法的实现交由子类实现，是一种模版方法！</p>
<p>一般情况下，我们将抽象类中的算法的骨架设计为final类型的方法防止子类去修改，另外，可以在抽象类中将可选方法设计为hook（钩子）方法，子类可以选择覆盖来达到某种目的。</p>
<p>系统结构图：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/template1.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
好莱坞原则：别调用我们，我们会调用你！
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/template1.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
好莱坞原则：高层组件对底层组件的原则：别调用我，我会调用你</p>
<p>模版方法模式 VS 策略模式
都是封装算法，模版方法使用了继承，由子类去实现算法某一部分细节；策略模式使用了组合，用委托决定采用哪一个行为</p>
<h2>命令模式</h2>
<p>命令模式定义：将请求封装为命令对象，以便来使用不同的请求，队列或日志来参数化其他对象。命令模式也支持撤销操作。
命令对象在特定接受者上绑定一组动作来封装一个请求，命令是通过将动作和接受者绑定在一起做到的，命令对象通常只暴露一个execute方法，该方法被调用时，接受者就会进行相关的操作。从表面看，调用者不知道哪个接受者进行了哪些动作，从而通过命令对象将调用者和接受者进行了解耦。</p>
<p>命令模式的用途：命令可以讲运算块打包（一组动作和一个接受者），然后传来传去。命令对象甚至可以在不同的线程中被调用，所以它可以用来：（1）日程安排（2）线程池（3）工作队列</p>
<p>命令模式将发出请求的对象和执行请求的对象解耦，这两者之间是通过命令对象进行沟通的，命令对象封装了接受者和一组动作，命令支持撤销，通过宏命令（多组命令）可以对简单命令进行扩展。命令用于线程队列、日志系统、事物系统等。</p>
<p>Java代码 : https://github.com/lifeloner/designPattern</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/01/09/lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/09/lock/" itemprop="url">Lock与Synchronized</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-09T23:56:25+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concurrent/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrent</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/01/09/lock/" class="leancloud_visitors" data-flag-title="Lock与Synchronized">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java中通过锁实现同步的方式主要有2种：通过synchronized关键字和显示的lock。
&lt;!--more--&gt;</p>
<h2>synchronized</h2>
<p>其本质是对对象进行加锁，java中每一个对象都有内置锁，synchronized在修饰方法时也是对当前对象（this所指对象）进行加锁，对static方法加锁时是对该类进行加锁（类的class对象），所以对类的实例加锁和对类加锁互不影响。synchronized同步块是一种监视锁，反编译后可以看到monitor和exit monitor同步块，该区域内同一时刻只允许一个线程访问。注意加锁的粒度是线程而不是对象，jvm会记录线程获取锁的次数，当线程获取当前对象的内置锁时再进入同一对象的同步块时该线程获取次数会＋1，在该次数减为0之前其他线程无法获取当前锁，所以synchronized是可重入锁。</p>
<h2>lock</h2>
<p>显示的lock也是可重入锁，在lock和unlock之间代码块受锁的保护。lock相比synchronized更灵活，提供了lock、try lock、lockInterruptibly等多种灵活的方式。其中lock（）和synchronized一样是不可中断的阻塞方法，而try lock是非阻塞的，加锁成功直接返回true，否则反回false，try lock也可以带一个时间参数，如果在规定的时间获取锁返回true，否则直接退出反回false，在等待期间是可响应中断的，lockInterruptibly是阻塞可中断的。</p>
<h2>synchronized的继承性</h2>
<p>synchronized修饰的方法是不可继承的，这主要体现在：子类的方法不具有synchronized性质，若子类没有复写方法，同步依靠父类来提供；若子类复写了方法则该方法不具有同步特性。
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.study.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/7/28.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">methodOne</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"super method_one"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">6000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.study.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/7/28.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                 methodOne();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"child method_one"</span>);</div><div class="line">        <span class="keyword">super</span>.methodOne();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          ChildClass childClass=<span class="keyword">new</span> ChildClass();</div><div class="line">          childClass.testMethod();</div><div class="line">          childClass.testMethod();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两个线程都会执行methodOne方法，但同时只有一个线程能执行父类的methodOne方法。所以子类一方面可以依靠父类提供同步保证，若复写了父类的方法则需要自己提供同步机制。</p>
<h2>死锁问题</h2>
<p>线程在获取锁时，执行顺序不当往往会造成死锁，尤其在一个同步块中调用了另一个方法，而该方法中也有锁相关的操作，这种情况下存在潜在的死锁风险且不容易发现，synchronized在死锁时无法解决只能强制退出应用，下面是一个实例：
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.study.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/7/19.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> class DeadLockSynchronized &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="keyword">Object</span> a=<span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">        <span class="keyword">Object</span> b=<span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">                <span class="keyword">synchronized</span> (a)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">500</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (b)&#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(Thread.currentThread().getName()+<span class="string">" get a and b lock"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">                <span class="keyword">synchronized</span> (b) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">600</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (a) &#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(Thread.currentThread().getName() + <span class="string">" get a and b lock"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        System.out.<span class="built_in">println</span>(Thread.currentThread().getName()+<span class="string">" finshed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用lock能更灵活的避免死锁问题，可以尝试一次性申请所有锁，若失败则释放所有锁再重新尝试，代码如下：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package com.study.thread;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by fuyang on 16/8/6.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DealLock</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeadLock</span>(<span class="params">Lock one, Lock two, String a, String b, <span class="keyword">int</span> time</span>) </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (one.tryLock()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" get lock "</span> + a);</div><div class="line">                    Thread.sleep(<span class="number">600</span>);</div><div class="line">                    <span class="keyword">if</span> (two.tryLock()) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" get lock "</span> + b);</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            two.unlock();</div><div class="line">                            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" release lock "</span> + b);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    one.unlock();</div><div class="line">                    System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" release lock "</span> + a);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(time * <span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">" fail and retry"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        DealLock dealLock = <span class="keyword">new</span> DealLock();</div><div class="line">        Lock one = <span class="keyword">new</span> ReentrantLock();</div><div class="line">        Lock two = <span class="keyword">new</span> ReentrantLock();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                dealLock.testDeadLock(one, two, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"thread_one"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                dealLock.testDeadLock(two, one, <span class="string">"two"</span>, <span class="string">"one"</span>, <span class="number">3</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"thread_two"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如下：
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Connected <span class="built_in">to</span> <span class="keyword">the</span> target VM, address: <span class="string">'127.0.0.1:58776'</span>, transport: <span class="string">'socket'</span></div><div class="line">thread_one <span class="built_in">get</span> lock <span class="literal">one</span></div><div class="line">thread_two <span class="built_in">get</span> lock <span class="literal">two</span></div><div class="line">thread_one release lock <span class="literal">one</span></div><div class="line">thread_two release lock <span class="literal">two</span></div><div class="line">thread_one fail <span class="keyword">and</span> retry</div><div class="line">thread_one <span class="built_in">get</span> lock <span class="literal">one</span></div><div class="line">thread_one <span class="built_in">get</span> lock <span class="literal">two</span></div><div class="line">thread_one release lock <span class="literal">two</span></div><div class="line">thread_one release lock <span class="literal">one</span></div><div class="line">thread_two fail <span class="keyword">and</span> retry</div><div class="line">thread_two <span class="built_in">get</span> lock <span class="literal">two</span></div><div class="line">thread_two <span class="built_in">get</span> lock <span class="literal">one</span></div><div class="line">thread_two release lock <span class="literal">one</span></div><div class="line">thread_two release lock <span class="literal">two</span></div><div class="line">Disconnected <span class="built_in">from</span> <span class="keyword">the</span> target VM, address: <span class="string">'127.0.0.1:58776'</span>, transport: <span class="string">'socket'</span></div></pre></td></tr></table></figure></p>
<h2>Tips</h2>
<p>所以，在使用锁时一定要检查代码，考虑死锁的可能性，尤其注意锁的获取顺序。另外，synchronized的性能不如lock，若仅仅只是用来保证数据一致性而没有其他特殊要求，还是建议使用synchronized，jdk在每一个版本中都在不断优化内置锁的性能，所以它们差别很小，除非为了灵活性或其他需求而使用lock，使用lock时需要养成好习惯讲unlock写在finally语句块中防止程序异常也能够及时释放锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/photo.png"
               alt="lifeloner" />
          <p class="site-author-name" itemprop="name">lifeloner</p>
           
              <p class="site-description motion-element" itemprop="description">Keep Moving!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lifeloner" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Github
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2709035861/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:yangfu1992@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://jm.taobao.org/hire/" title="阿里中间件博客" target="_blank">阿里中间件博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jasongj.com/" title="牛人博客" target="_blank">牛人博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://cmsblogs.com/" title="Java精品博客" target="_blank">Java精品博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/u013256816" title="中间件博客" target="_blank">中间件博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://leetcode.com/gogoing/" title="leetcode" target="_blank">leetcode</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lifeloner</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3CEMw4GOysIloYEGhXyGXF2Y-gzGzoHsz", "geP0AJOCyAyAeJJS13hYX4Us");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
