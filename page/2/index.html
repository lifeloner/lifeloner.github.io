<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.css.network/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/photo.png?v=5.1.2" />






<meta name="description" content="Keep Moving!">
<meta property="og:type" content="website">
<meta property="og:title" content="lifeloner">
<meta property="og:url" content="https://lifeloner.github.io/page/2/index.html">
<meta property="og:site_name" content="lifeloner">
<meta property="og:description" content="Keep Moving!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lifeloner">
<meta name="twitter:description" content="Keep Moving!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键词搜索","hits_empty":"找不到关于${query}的文章","hits_stats":"找到${hits}篇相关文章，花费${time}ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lifeloner.github.io/page/2/"/>





  <title>lifeloner</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lifeloner</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">当你的才华还撑不起你的野心的时候，你就应该静下心来学习！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2017/01/09/gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/09/gc/" itemprop="url">Java GC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-09T20:04:12+08:00">
                2017-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/01/09/gc/" class="leancloud_visitors" data-flag-title="Java GC">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java垃圾回收器相关基础
&lt;!--more--&gt;</p>
<h2>Java内存区域</h2>
<p>Java与c＋＋很大的区别在于内存管理上，c＋＋中主要由程序员对内存进行申请和释放（new、delete／malloc、free），而java中内存交由JVM来管理，虽然这在一定程度上减少了java程序员的负担，但了解JVM内存管理、GC机制能够帮助我们写出高质量、高效率的代码、并能排除内存溢出、内存泄漏等常见问题，下面我们先了解一下java的内存区域。
JVM的内存区域划分如下图所示：
&lt;center&gt;<br>
<img src="http://oqcre1dsl.bkt.clouddn.com/memory.png?imageMogr2/thumbnail/!42p" alt="img">
&lt;/center&gt;
1.程序计数器
程序计数器是一块较小的内存空间，用于记录线程的虚拟机字节码指令地址，程序的分支、循环、跳转、异常处理、以及线程切换都依赖与该计数器完成，它是线程私有的内存空间。</p>
<p>2.java虚拟机栈
虚拟机栈也是线程私有的，它描述了java方法执行的内存模型：每一个方法执行时都会创建一个栈帧用于存放局部变量表、操作数、方法出口等信息。每一个方法的调用和结束对应着栈帧入栈和出栈操作。局部变量表存放了基本的类型（boolean、byte、char、int、long、float、double），引用类型（reference，简单理解为对象的内存地址而不是对象本身），returnAddress（返回地址即虚拟机一条字节码指令，局部变量表大小在编译器确定，运行期间不会改变。该区域中可能出现StackOverFlowError（栈深度超过JVM允许深度），OutOfMemoryError（无法申请足够内存）。</p>
<p>3.本地方法栈
与虚拟机栈很类似，区别在于虚拟机栈对应的是java方法，而本地方法栈对应的是native方法服务（如c＋＋），JVM对本地方法栈的语言、数据结构没有要求，有的虚拟机（如HotSpot）甚至把虚拟机栈和本地方法栈合二为一统一管理。</p>
<p>4.java堆
这部分区域对大家最熟悉不过了，它是JVM管理的内存区域中最大的一块，存放着对象的实例，为所有线程共享，几乎所有的对象实例都在堆上分配内存（几乎而不是完全绝对）。堆也是GC回收的主要的区域，同样该区域也会抛出 OutOfMemoryError异常。</p>
<p>5.方法区
方法区也为所有线程共享，存放了虚拟机加载的类信息、常量、静态变量、编译后的代码等数据。运行时常量池是方法区的一部分，用于存放编译期的常量、符号引用、直接引用。方法区也会抛出OutOfMemoryError异常。</p>
<p>6.直接内存
直接内存不是JVM运行时数据区的一部分，也不是JVM定义的内存区域。但该区域也被频繁使用，可能导致OutOfMemoryError异常。NIO出现，引入了基于channel和buffer的I／O方式，它可以使用native函数库直接分配堆外内存，然后通过java堆中的directByteBuffer对象作为该内存的应用进行操作，以此来避免java堆和native堆来回复制数据，提高了性能。</p>
<p>下面我们以HotSpot虚拟机为例，了解一下创建对象时堆内存分配以及对象的访问过程。
（1）对象创建
当使用new创建一个对象时，虚拟机首先在方法区的常量池中定位到一个类的符号引用，检查符号引用的类是否被加载、解析、初始化，具体细节可以阅读java类加载机制相关知识点。在类加载后，需要在堆中分配内存，堆中的内存常常不是规整的往往存在内存碎片，所以需要使用“空闲列表”的方式来选择分配的地址。在分配内存时还需要注意线程安全，防止出现给对象A分配内存后没修改地址而对象B使用了相同的地址指针，所以可以采用2种办法：一是使用同步方式（虚拟机采用CAS的原子语义方式而不是锁），二是给每个线程分配一小块缓冲（TLAB），当线程使用完TLAB后再同步分配内存。对象内存分配后，JVM将内存空间初始化为零值（不包括对象头），接下来虚拟机将对象所属类的元数据信息、对象哈希码、gc分代年龄、对象锁信息放入对象内存的对象头中，这样JVM的对象初始化工作完成了，但在程序员看来对象的字段都还没初始化，接下来执行&lt;init&gt;方法，按照构造函数要求对对象进行初始化，这样对象的整个初始化过程完成。
（2）对象访问
使用栈上的reference来操作堆中对象实例，应用定位和访问的方式有句柄和直接指针两种。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/point.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/direct.png" alt="img">
&lt;/center&gt;
句柄方式需要在堆中申请一块额外的内存，reference存储了句柄的的地址，句柄优势在于对象实例被移动时只会改变句柄中实例数据指针，reference不用改变。直接指针方式优势在于定位速度快，省掉一次指针定位时间，hotspot虚拟机采用的直接指针方式，在大量对象访问情况下性能提升比较客观。</p>
<h2>GC</h2>
<p>在学习GC前，我们首先需要明白几个问题：哪些内存需要回收？什么时候回收？怎么回收？</p>
<p>1.对象的存活
判断对象是否死亡方式有多种，其中主要的方式有：引用计数法、可达性分析法。
引用计数法：给对象添加一个引用计数器，每当有一个引用指向它，计数器加1，当引用失效，计数器减1，减为0则对象可以回收，但无法解决对象之间相互循环引用问题。
可达性分析法：通过GC Roots对象为起点，往下搜索，经过的路径称为引用链，当对象通过引用链和GC Roots不可达时则可以回收。java中使用可达性分析算法来判断对象存活情况，java中常见的GC Roots有虚拟机栈引用的对象，方法区中常量、静态变量引用的对象、本地方法栈JNI引用的对象。
即使对象与GC Roots不可达，对象也并非必死不可，对象死亡至少经历2个标记过程，首先前面提到的不可达是第一次标记，然后进行一次筛选来确定是否需要执行finalize方法，若对象没有复写finalize方法或者之前已经执行过finalize，那么虚拟机将不再执行finalize方法。在第一次标记后，并需要执行finalize时，finalize是对象逃脱回收的最后机会，对象被放在F－Queue队列中，然后由一个低优先级的Finalizer线程执行对象finalize方法，如果对象在finalize中把自己引用（this）赋值给某个类变量或对象成员变量，那它将被移除被回收的集合，如果仍没有逃脱那基本将被JVM真正回收。一个对象可以在GC时逃脱，但只能逃脱一次，因为finalize只能执行一次。
GC并不仅仅发生在堆中，在方法区（hotspot中成为永久代）也会发生GC，只是回收效率较低。永久代中回收的内容主要有常量和类，一个常量没有任何地方使用就被认为是废弃的可以进行回收了，但类的判断要求严格的多，需要满足的条件有：类所有实例被回收；加载类的ClassLoader被收回手；Class对象没有在任何地方引用，无法通过反射访问类方法和字段。只有满足这3个要求，JVM才有可能（并不一定）回收该类。</p>
<p>2.GC算法
主要的gc算法有4种：标记－清除算法，复制算法，标记－整理算法，分代收集算法。
（1）标记－清除算法
标记－清除算法分为标记、清除2个阶段，首先对需要回收的对象进行标记，完成后统一回收标记的对象。它存在2个缺点：标记清除过程效率低，而且gc后存在大量不连续的内存碎片，导致以后分配大内存对象时内存不足，不得不触发另一次gc。
（2）复制算法
复制算法思想是把内存容量划分为大小相等的2块，每次使用其中一块，当内存不足时将存活的对象复制到另一块内存，这样就不存在内存碎片问题。但这样内存的使用率较低，没有充分利用内存，有些浪费。IBM经过研究表明，大部分对象（约98%）都是朝生夕死，并不需要按照1:1来划分，所以提出了eden，survivor（2个survivor，eden，suivivor比例为8:1）区域，将eden，survivor中对象移动另一块survivor中，最后清理掉eden，survivor区域，这样仅仅浪费了10%的内存，这也是hotspot默认的方式，当不能保证不超过10%内存大小对象存活时，需要依赖其他内存（老年代）进行分配担保。当存活对象较多时，回收效率较低，所以复制算法一般用于年轻代。
（3）标记－整理算法
对于老年代，提出了另一种方法：标记－整理算法，相比标记－清除算法，他不是直接对对象进行回收，而是把存活对象移动到一端，然后清理到边界以外的内存区域。
（4）分代收集算法
分代收集算法根据对象存活时间把对象分为年轻代、老年代，根据每个阶段采取不同的收集算法，一般对于年轻代大量的对象会死去，一般采用复制算法，对于老年代对象存活旅高，也没有分配担保，一般使用标记－清除，标记－整理算法。</p>
<p>3.HotSpot GC算法实现
在gc前，首先需要找出GC Roots节点以及引用链，一般作为GC Roots的节点主要有全局性引用（常量、类静态属性）以及执行上下文（栈帧的本地变量表）。在可达性分析时需要保证一致性，在枚举gc roots以及引用链时，需要停止java线程的执行（stop the world），不然对象引用关系在不断变化。在线程停止，检查寻找gc roots时，jvm并不需要一个一个的检查，hotspot使用了OopMap数据结构来达到这个目的，该数据结构记录了对象偏移量上是什么类型数据。
在OopMap帮助下，hotspot快速完成gc roots枚举，但hotspot没有为每个指令都生成OopMap，只是在特定的位置纪录了这些信息，这些位置被称为安全点。程序执行时并非在所有地方都可以停止下来gc，只能在安全点暂停下来，所以一般的安全点选取在方法调用、循环跳转、异常跳转。在gc时需要使所有的线程都运行到最近的安全点（safe point）上，所以有2种方案，一是抢先式中断：在gc时中断全部线程，若线程不在安全点上让他恢复运行到安全点上，另一种是主动式中断：不主动中断线程，通过设置标志，让线程主动轮询标志，发现中断标志后自己中断挂起，轮询位置刚好和安全点重合。
对于线程处于sleep、blocked时，线程无法执行到安全点时，需要使用安全域来解决。线程进入安全域（safe region）后，gc时不需要关注处于安全域状态的线程。当线程离开安全域时需要检查是否已经完成gc过程，若没有完成必须等到整改gc完成才能离开安全域。</p>
<p>4.垃圾收集器
垃圾收集器是gc算法的具体实现，jvm中的垃圾收集器很多，不同的版本、不同厂商虚拟机提供的垃圾收集器差异也很大，常见的gc收集器如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/gc.png" alt="img">
&lt;/center&gt;
（1）Serial
serial收集器是单线程的收集器，同时在gc时必须停止其他工作线程（stop the world），该收集器主要用于运行在client模式下的虚拟机。
（2）ParNew
parent是serial的多线程版本，其他策略与serial基本一致，是工作在server模式下的虚拟机首选的新生代收集器，能够与cms配合工作。在单cpu下它还不如serial的性能，但在多核下并发效果还是有不少提升。
（3）Parallel Scavenge
parallel scavenge收集器也是基于复制算法的新生代收集器， 相比其他收集器，它主要关注吞吐量（cpu运行用户代码时间与gc时间比例），cms主要关注了停顿时间适用于用户交互的程序，响应速度快，parallel scavenge使用了快速完成运算任务，不需要太多交互。parallel scavenge提供了2个参数用于控制吞吐量：－XX：MaxGCPauseMillis用于保障gc时间不超过设定值，－XX：GCTimeRatio设置gc时间最多占总时间比例，同时它该提供了－XX：＋UseAdaptiveSizePolicy虚拟机会根据系统情况自动调节gc时间和吞吐量，所以改收集器是一种吞吐量优先收集器。
（4）Serial Old
serial old也是一个单线程的老年代收集器，使用标记－整理算法，在client模式下配合serial工作，在server模式下与parallel scavenge搭配使用，或作为cos的后备收集器，在其发生concurrent mode failure备用。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/serial.png" alt="img">
&lt;/center&gt;
（5）parallel old
该收集器也适用了标记－整理算法，用于配合 parallel scavenge（无法与cms配合工作），因为serial old但线程收集能力较差无法利用多cpu处理能力。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/parallel.png" alt="img">
&lt;/center&gt;
（6）CMS
CMS收集器是以获取最短停顿时间为目标的收集器，能够加快响应速度，它是基于标记－清理算法，收集过程包含4个过程：初始标记、并发标记、重新标记、并发清除。1、3阶段需要stop the world，初始阶段标记gc roots直接关联的对象，速度较快，并发标记对gc roots进行追踪，重新标记修正并发标记中程序继续运行的变动，该阶段比初始标记慢但远比并发标记快。整个过程耗时的并发标记、清除可以与用户并发执行，所以停顿时间较短。
CMS作为优秀的收集器也有3个明显的缺陷，首先CMS对cpu资源敏感，并发时和工作线程一起运行占用cpu资源，导致程序执行速度变慢，吞吐量降低。其次，cms存在浮动垃圾，可能出现concurrent mode failure导致另一次full gc，原因在于cms在并发清除阶段程序还在运行，所以会有新的内存和垃圾出现，cms无法在这次gc中回收它们，由于在该阶段必须有足够的内存留给用户线程执行，所以cms不能等到老年代被使用完才gc，需要流出一部分空间在并发清除阶段给用户线程使用。如果这个阶段剩下内存不够用户线程使用，那么就出现了concurrent mode failure失败，jvm不得不使用serial old进行一次full gc，停顿用户线程进行gc，时间更长了。最后，cms基于标记－清除算法实现，存在内存碎片问题，所以cms提供了参数，在多少次gc后需要进行一次内存整理过程。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/cms.png" alt="img">
&lt;/center&gt;
（7）G1
G1是当前gc中最前沿的研究成果，它不需要与其它垃圾收集器一起工作，相比其它收集器它的优势如下：
并行与并发：利用多cpu多核优势，减少stop the world时间，采用并发方式执行gc
分代回收：采用不同的方式处理新对象和旧对象，不需要配合其它收集器
空间整合：与cms的标记－清除不同，G1整体上基于标记－整理方式，局部上基于复制算法，都不会存在内存碎片问题
可预测停顿：不断能够减少停顿时间，还能建立可预测的时间模型，保证在M时间内gc时间不超过N
G1将java堆划分为大小相同的区域（Region），保留了新时代老年代概念，他避免了在整个堆进行全区域gc，G1跟踪各个region的价值大小（gc时间、回收大小）维护一个优先级列表，回收价值最大的region，保证了高效的回收效率。
在回收region时，对象的引用可能存在不同的region中，G1使用了Remembered Set来避免全表扫描引用关系，每一个region都有一个remembered set保存对象引用关系，G1收集过程分为4个步骤：初始标记、并发标记、最终标记、筛选回收。初始标记标记gc roots直接关联的对象，并发标记进行可达性分析，找出存活的对象，可与用户线程并发执行，最终标记修正并发阶段的变化，并将变化纪录在remembered set中，该过程需要停顿用户线程，最后筛选阶段根据region排序结果，按照优先级回收，该过程其实也可以做到并发执行，但仅仅回收一部分region速度较快，也没有太大必要。所以G1追求了低停顿，吞吐量没有改进。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/g1.png" alt="img">
&lt;/center&gt;
5 内存分配和回收策略
（1）对象优先分配在eden区域中，eden区域空间不足将发起MinorGC
（2）大对象直接进入老年代，jvm允许通过－XX：PretenureSize Threshold参数设置对象直接在老年代分配
（3）长期存活对象进入老年代，可设置－XX：MaxTenuring Threhold改变阈值
（4）动态对象年龄判断，jvm并不一定要求年龄达到阈值才能进入老年代，若survivor对象中相同年龄所有对象大小达到survivor一半，大于等于该年龄即可进入老年代
（5）空间分配担保，在Minor GC之前，虚拟机会检查老年代可用连续空间是否大于新生代对象总空间，若成立则Minor GC是安全的，否则需要查看是否允许担保失败，若允许则检查历次从新生代晋升到老年代的对象平均大小，若小于则进行Minor GC（虽然有风险），若不允许冒险或大于则进行一次 Full GC。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/11/10/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/10/linux/" itemprop="url">linux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-10T21:28:02+08:00">
                2016-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/11/10/linux/" class="leancloud_visitors" data-flag-title="linux">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>显示日期：date +%Y%m%d    date +%H：%M
显示日历al
cal 年月日：cal  month  year
&lt;!--more--&gt;
计算器：bc
quit退出
帮助指令：man
man 命令
数据同步磁盘：sync
关机：shutdown -t（秒）-r（重启） -h（停止系统服务后关机）
重启：reboot</p>
<p>改变群组： chgrp  -r（递归） 文件／目录
改变拥有者：chown -r  拥有者：群组 文件／目录
改变属性：chmod  -r 数字 文件／目录 （rwx：421）</p>
<p>目录所在磁盘信息：df   -a（所有）-k（kb） -m（mb）-h（gb，mb，kb自行显示） 文件／目录
当前目录所有文件容量：du -a(所有)  -s（总量）-k（kb）目录
连接档：in
hard link（硬连接、实际连接，指向同一档案、不占空间、删除原始档不受影响）
symbolic link（符号连接、快捷方式、占空间、删除原始档后不可用）
用法 ：in   -s（符号连接、默认硬连接） -f（若存在同名删除再建立） 源文件  目标文件</p>
<p>磁盘分割：fdisk  -l(所有装置)  装置名称
进入后会有一些命令，主要有：
l 显示所有硬盘信息；
n新增一个磁盘分区；
p显示磁盘分区
d删除一个磁盘分区
q不存储离开
w写入磁盘分区表离开
格式化磁盘：mke2fs  -b（设置bolck大小）-c（检查错误）磁盘名称
磁盘检验：fsck -A（所有装置扫描）-a（自动修复） -f（强制进行细部检查）
磁盘挂载：mount -a(所有磁盘全部挂载)  -t（指定格式类型） 装置名称   挂载点
卸载装置：umount 装置代号／挂载点</p>
<p>虚拟内存：
将目录格式化为swap档案格式：mkswap 目录
启动：swapon    目录
关闭：swapoff    目录</p>
<p>删除空的目录：rmdir -p（递归删除）目录
复制文档目录：cp  -l（hard link建立）-p（连属性一起复制过去）-r（递归）-s（symbolic link） -u（更新目标文件）  源文件   目标文件
删除档案目录：rm -f（强制） -r（递归） 文件／目录
移动档案／目录：mv   -f（强制） -u（更新） 源  目的</p>
<p>查看：cat   -n（行号） -A（显示特殊字符） 文件
一页一页翻动  ：more  文件
空格键：向下翻一页    enter：下一行    ／字符串：搜索字符串  :f ：显示文件名和行数   q：退出
less  文件
空格键：向下翻一页   pagedown：向下一页   pageup：向上一页   ／字符串：向下搜索字符串    ？／：向上搜索字符串    q：退出
取出前面几行：head   -n（n行）  文件
后面几行：tail  -n   文件
非ascll文件（二进制）：od  -t （类型）  文件
touch  -a（修改atime）-c（修改ctime）-m（修改mtime）文件</p>
<p>预设权限：umask 数字
设置隐藏属性：chattr +-= 文件
常见的：i：无法修改、增加 、删除     a：只能增加不能修改删除
查看隐藏属性：lsattr  -a(隐藏属性)  -R（递归子目录）  文件
文件类型：file  文件
文件查找：
查找执行档(命令)：which  -a（所有同名） 文件名
查找特定档案（二进制、源文件、man说明文件）：whereis     -b（二进制文件）-s（source来源） -m（manual路径下） 文件
locate  文件名（可以查找部分匹配文件名的文件） 文件名
find     路径  参数
（-name filename）
（-user username）
（-group name）</p>
<p>压缩打包：
gzip -d（解压缩） 文件
zcat：查看gzip压缩文件内容
bzip2  -z(压缩)  -d(解压缩)  文件
bzcat  ：查看bzip2压缩的文件
tar  -c(建立)  -x(解开) -t(查看)  -v（压缩过程显示文件）-f(使用档名)  -z(使用gzip)  -j(使用bzip2 )  -P（使用绝对路径）-p（保持原来文件属性）
eg：tar -zcvf   /tmp/a.tar.gz  /home /etc  把home 和 etc目录打包并gzip压缩到／tmp下的a中
tar -zxvf  ／tmp／a.tar.gz  ／home  将 文件中的home先gzip解压然后解开打包 最后放在当前目录下
dd  if=   of=    (bs= 默认512  count=)</p>
<p>截取命令：
cut：
-d  分割字符（单个字符）与 -f一起使用
-f  取出第几段  与-d配合使用
-c  取出固定的字符区间
eg：echo ￥path | cut -d ‘：’ -f 5      取出path种以：分割的第5块
export | cut -c 12-   取出export配置第12个开始后的所有字符
grep:
-c:计算匹配次数
-n：显示行号
-v:反过来没有匹配的那一行
-i：忽略大小写</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/09/04/classbytes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/04/classbytes/" itemprop="url">JVM字节码执行引擎和编译、优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-04T20:04:12+08:00">
                2016-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/04/classbytes/" class="leancloud_visitors" data-flag-title="JVM字节码执行引擎和编译、优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java作为跨平台的语言离不开jvm的支持，java语言首先经过javac编译器编译为class字节码文件然后被jvm解释、编译为本地机器码，然后被os执行，由于jvm中间这一层的存在所以java语言才能跨平台，同时除了java，ruby、scala等语言经过编译后的字节码只要符合jvm字节码规范也能够被jvm执行，所以字节码是一种规范，了解jvm执行引擎对学习java也很有帮助。
&lt;!--more--&gt;</p>
<h2>字节码执行引擎</h2>
<p>1.运行时栈帧结构
栈帧是支持jvm方法调用、执行的数据结构，是jvm运行时虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接、方法返回地址，每一个方法调用到结束对应了一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表存放了方法参数和局部变量，以slot（变量槽）为最小单位，操作数栈是一个后入先出的栈（LIFO），32位，方法返回值用于方法执行完将返回值返回上层方法调用，对于异常抛出未处理时是没有返回值（异常表处理），修改PC计数器。</p>
<p>2.方法调用
方法调用确定被调用方法的版本（具体来说是调用哪一个方法），class文件的编译不包括链接步骤，方法调用在class文件中是符号引用，需要转化为直接引用（入口地址）。</p>
<p>3.解析调用：
在类加载阶段把符号引用转化为直接引用，在方法运行前有可确定的调用版本并且在运行时不可变，也就是说在编译时确定了方法的调用。java中方法调用的直接码指令有：
1.invokestatic 静态方法
2.invokespecial 实例构造器&lt;init&gt;、私有方法、父类方法
3.invokeinterface方法接口，运行时确定是实现接口的对象
4.invokedynamic
5.invokevirtual虚方法
其中invoke static、invoke special都可以在解析阶段确定，invoke virtual中带有final的方法。解析调用是静态过程，在编译期确定了，不会到运行期再去完成。</p>
<p>4.分派：
分派调用可能是静态的也可能是动态的。
静态分派：重载，java中变量有静态类型（外观类型）、实际类型。静态类型在编译期已知，实际类型在运行期才可以确定，所以重载是属于静态分派，在编译期已经确定了，并不是由jvm来确定，重载时也会选择最佳的匹配方法。
动态分派：重写，根据对象实际类型选择方法调用。动态分派过程如下：
(1).找到对象实际类型C
(2).在类型C中找到与常量描述都相同的方法，进行访问权限校验，通过返回直接引用否则返回java.lang.IllegalAccessError
(3).否则，按照继承关系对父类进行第二步的搜索验证
(4).没有找到合适方法，抛出java.lang;AbstractMethodError
其中，静态分派调用是一方面会判断对象的静态类型也会判断方法的参数，所以它属于静态多分派；动态分派只会根据实际类型判断，所以属于动态多分派。
动态分派在实现时，jvm在方法区存放了一个虚方法表，同样invokeinterface存在一个接口方法表，虚方法表中存放了方法的实际入口地址，若子类未复写则子类和父类地址一致，指向父类入口，若复写了则指向子类实现的入口地址，方法表在类加载阶段连接是进行，初始化类变量后对方法表也进行了初始化。</p>
<h2>编译、优化</h2>
<p>Java语言的编译阶段主要有2种，包括了前端编译期（java－&gt;class）、运行期编译期（JIT编译器，字节码－&gt;机器码）。</p>
<p>1.早期编译
java编译器本身由java语言编写，它对代码的运行效率几乎没有任何优化措施，性能优化主要集中在JIT中。javac编译器的编译过程主要有3个过程：
1.1解析和填充符号表过程
词法分析、语法分析；填充符号表
2.1插入式注解处理器的注解处理过程
注解支持
3.1分析和字节码生产过程
语义分析（标注检查、数据流、控制流分析）；解语法糖（泛型、自动装箱）；字节码生成</p>
<p>2.晚期优化
混合编译模式：
java程序最初通过解释器进行解释执行，当jvm发现某个代码运行频繁时，将把这些代码认为“热点代码”，在运行时把这些代码编译成本地机器码进行各种层次优化，这些都由JIT编译器完成，下面以hotspot为例介绍运行期的优化方法。
主流的JVM都同时包含了解释器和编译器。解释器省去编译时间可以迅速启动，在程序运行中编译器可以把代码编译成本地代码提高执行效率，而且当编译器激进优化不成立时能够通过逆优化退回到解释执行。HotSpot中设置了2个即时编译器，分别为client、server，server优化程度更深更复杂。
	编译优化触发条件：
被编译优化的“热点代码”主要有2类：多次调用的方法、多次执行的循环体。第一种编译器以整个方法作为编译对象，后一种编译由循环体触发，但JIT还是会以整个方法（而不是循环体）作为编译对象，这种方式发生在方法执行过程中，成为栈上替换（on stack replacement）OSR，方法在栈上，方法被替换了。</p>
<p>热点代码的判定方法主要有2种：采样热点探测、计数器探测
	2.1基于采样热点探测：jvm周期性检查线程栈顶，某个方法经常出现则为热点代码，并能发现方法的调用关系，但容易受外界干扰（线程阻塞）
	2.2基于计数器热点探测：建立计数器，统计方法执行次数，超过阈值即为热点代码，但不能发现方法调用关系
	hotspot以第二种方法判断热点代码，计数器有方法计数器和回边计数器，方法调用计数器、回边计数器运行过程分别如下：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/method.png" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/huibian.png" alt="img">
&lt;/center&gt;
如果不做设置，方法调用计数器统计的不是绝对次数，而是相对次数，在一定时间的调用次数，超过一定时间会减半即热衰减，也可以设置来关闭热衰减。回边计数器，统计了方法中循环体的次数，回边计数器没有热衰退。在方法调用发出即使编译请求后，在代码编译未完成前仍然按解释方式执行，编译过程在后台编译线程中执行，也可以设置关闭后台编译，等待编译完成在执行编译后本地代码。
编译方式比解释方式执行速度快，一方面是执行本地代码快，另一方面JIT编译时进行了优化，主要的优化有：
1.公共子表达式消除
2.数组范围检查消除
3.方法内联
4.逃逸分析</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/09/04/classloader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/04/classloader/" itemprop="url">JVM类加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-04T20:04:12+08:00">
                2016-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/04/classloader/" class="leancloud_visitors" data-flag-title="JVM类加载机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>类从被加载到虚拟机内存中开始到卸载出内存，整个的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备、解析阶段统成为连接，7阶段关系如下图：
&lt;!--more--&gt;
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/classloader.jpg" alt="img">
&lt;/center&gt;
其中，加载、验证、准备、初始化、卸载顺序是确定的，而解析阶段不一样，可以在初始化之后再开始，这是为了支持java的运行时绑定。这些阶段通常都是互相交叉混合进行，在一个阶段执行过程中调用激活另一个阶段。</p>
<h2>类加载时机</h2>
<p>java虚拟机规范没有约束加载阶段，由具体的虚拟机实现来把握，而初始化阶段却有严格的规定，以下五种情况必须对类进行初始化：</p>
<p>（1）使用new、getstatic、putstatic、invokestatic字节码指令时，类没有初始化，必须对类进行初始化
（2）使用reflect对类进行反射调用
（3）初始化类时，父类未初始化则需要触发类初始化
（4）jvm启动，会初始化指定包含main方法那个类
（5）jdk1.7动态语言支持，java.lang.invoke.methodhandle实例后的解析结果REF_getStatiic、REF_putStatiic、REF_invokeStatiic的方法句柄，这个方法句柄对应类没有初始化，首先要初始化该类</p>
<p>对于这5种初始化场景成为类主动引用，除此之外其他的方式成为被动引用，不会触发初始化，常见的被动引用有：</p>
<p>（1）子类使用父类中static字段
（2）new对象数组
（3）使用类的final static字段</p>
<h2>加载过程</h2>
<p>加载阶段jvm完成以下3件事情：
（1）通过类的全限定名来获取类的二进制字节流
（2）将字节流代表的静态存储结构转化为方法区运行时数据结构
（3）在内存中（方法区）生产代表这个类的class对象</p>
<p>其中第一条并没有指定必须从class文件获取，其实有很多技术建立在这一基础上：
（1）从zip包获取：jar、war、ear格式基础
（2）网络获取，applet
（3）运行时生产，动态代理技术，proxy，cglib
（4）数据库或其他文件获取</p>
<h2>验证</h2>
<p>验证阶段保证了class文件的字节流信息符合jvm要求，不会危害jvm安全，主要包含了：
（1）文件格式验证
（2）元数据验证
（3）字节码验证
（4）符号应用验证</p>
<p>具体验证内容需要对类文件结构有一定理解。</p>
<h2>准备</h2>
<p>准备阶段为类变量分配内存设置变量初始值，这里分配的是static变量，而非实例对象，并将static变量初始化为“零值”，而final static变量在准备阶段以及赋值为指定的值。</p>
<h2>解析</h2>
<p>解析阶段将常量池中符号引用替换为直接引用，主要包含：
（1）类、接口解析
（2）字段解析
（3）类方法解析
（4）接口方法解析</p>
<h2>初始化</h2>
<p>初始化是类加载最后一步，该阶段开始执行用户java代码，在准备阶段对类变量赋值为零值，而初始化将对类变量赋初始值。从另一个角度来说初始化阶段是执行类构造器&lt;clinit&gt;方法过程，&lt;clinit&gt;收集类变量赋值和static块（有先后顺序），有以下几点需要注意：
（1）jvm保证子类clinit执行前，父类clinit已经执行完毕
（2）clinit对于类并非必须，没有类变量和static也就不需要了
（3）接口不能使用static块，但有变量初始化过程，与类不同之处在于接口clinit方法不需要执行父接口clinit方法，除非使用了父接口的变量
（4）jvm会保证clinit方法的同步、加锁，只执行一次</p>
<h2>类加载器</h2>
<p>java中任何一个类，都需要一个类加载器来进行加载，比较2个类是否相等，需要保证其来自的class文件相同并且被同一类加载器加载，否则是2个不同的类。java中类加载机制称为双亲委派模型，如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/doubleparent.jpg" alt="img">
&lt;/center&gt;
(1).BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。
(2).Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
(3).Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</p>
<p>上述三个JDK提供的类加载器虽然是父子类加载器关系，但是没有使用继承，而是使用了组合关系，加载顺序如下：</p>
<p>(1).如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。
(2).每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。
(3).如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。</p>
<p>在JDK1.2之前，自定义类加载器都要覆盖loadClass方法去实现加载类的功能，JDK1.2引入双亲委派模型之后，loadClass方法用于委派父类加载器进行类加载，只有父类加载器无法完成类加载请求时才调用自己的findClass方法进行类加载，因此在JDK1.2之前的类加载的loadClass方法没有遵循双亲委派模型，因此在JDK1.2之后，自定义类加载器不推荐覆盖loadClass方法，而只需要覆盖findClass方法即可。
双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。</p>
<h2>Tomcat案例分析</h2>
<p>tomcat web服务器解决的问题：
（1）不同web应用使用了同一个第三方类库的不同版本，需要包装不同webapp类库可以相互独立
（2）同一web服务器上的webapp使用的java类库相互共享，如spring，如果将所有类库都进行加载，加载的类太多，方法区可能会溢出，所以需要解决共享问题
（3）web服务 器需要保证自身安全，自身类库和webapp类库隔离
（4）某一个webapp的jsp应用
tomcat采用了不同的类加载器来解决这些问题，它有／common、／server、／shared目录，web应用的类库在自己目录／WEB_INF下,一共有4类目录，tomcat在处理时采用了如下方式：
（1）／common：被tomcat和所有webapp共享
（2）／server：只能被tomcat使用
（3）／shared：只能被所有webapp使用
（4）／webapp／web－info：仅对某一webapp使用
类加载器如下：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/tomcat.png?imageMogr2/thumbnail/!40p" alt="img">
&lt;/center&gt;
tomcat遵循了双亲委派机制，而OSGI作为一种灵活的类加载架构，对类加载有更大的启发，以后有时间多学习学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/07/22/maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/22/maven/" itemprop="url">Maven</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-22T23:08:48+08:00">
                2016-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/07/22/maven/" class="leancloud_visitors" data-flag-title="Maven">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Maven 是一个项目管理和构建自动化工具，它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统，和用来运行定义在生命周期阶段中插件目标的逻辑。
使用maven创建项目后，文件目录如下：
&lt;!--more--&gt;</p>
<table>
<thead>
<tr>
<th style="text-align:left">目录</th>
<th style="text-align:center">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">${basedir}</td>
<td style="text-align:center">存放 pom.xml和所有的子目录</td>
</tr>
<tr>
<td style="text-align:left">${basedir}/src/main/java</td>
<td style="text-align:center">项目的 java源代码</td>
</tr>
<tr>
<td style="text-align:left">${basedir}/src/main/resources</td>
<td style="text-align:center">项目的资源，比如说 property文件</td>
</tr>
<tr>
<td style="text-align:left">${basedir}/src/test/java</td>
<td style="text-align:center">项目的测试类，比如说 JUnit代码</td>
</tr>
<tr>
<td style="text-align:left">${basedir}/src/test/resources</td>
<td style="text-align:center">测试使用的资源</td>
</tr>
</tbody>
</table>
<p>maven中重要的一个文件是pom文件，上面是一个简单的pom文件：其中groupId, artifactId, packaging, version 叫作 maven 坐标，它能唯一的确定一个项目。有了 maven 坐标，我们就可以用它来指定我们的项目所依赖的其他项目，插件，或者父项目。在复杂的项目中，大项目一般会分成几个子项目。在这种情况下，每个子项目就会有自己的 POM 文件，然后它们会有一个共同的父项目。这样只要构建父项目就能够构建所有的子项目了，子项目的 POM 会继承父项目的 POM。
下面我们从maven库，生命周期，依赖库来对maven进行介绍：</p>
<h2>Maven库</h2>
<p>maven库分本地库、中央存储库、远程存储库。其中，本地库指 maven 下载了插件或者 jar 文件后存放在本地机器上的拷贝。在 Linux，mac os 上，它的位置在 ~/.m2/repository，在 Windows XP 上，在 C:\Documents and Settings\username.m2\repository ，在 Windows  上，在 C:\Users\username.m2\repository，我们可以修改setting.xml中localRepository结点来改变本地库的位置。当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 – http://repo1.maven.org/maven2/ 查找下载。在Maven中，当你声明的库不存在于本地存储库中，也没有不存在于Maven中心储存库，可以设置从远程存储库中搜索，设置的方式如下，会从java.net中搜索需要的jar：</p>
<p>所以Maven的依赖库查询顺序为：
在 Maven 本地资源库中搜索，如果没有找到，进入第 2 步，否则退出。
在 Maven 中央存储库搜索，如果没有找到，进入第 3 步，否则退出。
在java.net Maven的远程存储库搜索，如果没有找到，提示错误信息，否则退出。</p>
<h2>Maven 生命周期</h2>
<pre><code>  Maven的生命周期就是对所有的构建过程进行抽象和统一。包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。Maven有三套相互独立的生命周期，分别是clean、default和site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面。
</code></pre>
<p>clean生命周期：清理项目，包含三个phase。
1）pre-clean：执行清理前需要完成的工作
2）clean：清理上一次构建生成的文件
3）post-clean：执行清理后需要完成的工作</p>
<p>default（build）生命周期：构建项目，重要的phase如下。
1）validate：验证工程是否正确，所有需要的资源是否可用。
2）compile：编译项目的源代码。
3）test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。
4）Package：把已编译的代码打包成可发布的格式，比如jar。
5）integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。
6）verify：运行所有检查，验证包是否有效且达到质量标准。
7）install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。
8）Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</p>
<p>site生命周期：建立和发布项目站点，phase如下
1）pre-site：生成项目站点之前需要完成的工作
2）site：生成项目站点文档
3）post-site：生成项目站点之后需要完成的工作
4）site-deploy：将项目站点发布到服务器</p>
<p>各个生命周期相互独立，一个生命周期的阶段前后依赖，如mvn clean install，调用clean生命周期的clean阶段和default的install阶段，实际执行pre-clean和clean，install以及之前所有阶段。maven插件目标可以绑定到生命周期阶段上。一个生命周期阶段可以绑定多个插件目标。当 maven 在构建过程中逐步的通过每个阶段时，会执行该阶段所有的插件目标。</p>
<h2>Maven依赖管理</h2>
<pre><code>  赖是使用Maven坐标来定位的，而Maven坐标主要groupId, artifactId, version构成，随着项目的增大，依赖越来越多，兼容性和冲突问题将会出现，maven通过依赖范围和传递性依赖以及排除依赖来管理依赖问题。下面是一个简单的依赖配置文件：
</code></pre>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>maven不但下载了 junit-3.8.1.jar，还下载了它的 POM 文件。这样 maven 就能检查 junit 的依赖关系，把它所需要的依赖也包括进来。依赖的主要几个元素如下：</p>
<p>groupId,artifactId和version：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖
type: 依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值是jar
scope: 依赖的范围
optional: 标记依赖是否可选
exclusions: 用来排除传递性依赖
scope指依赖范围，主要有compile、test、provided、runtime、system这几类，是用来控制依赖与这三种classpath(编译classpath、测试classpath、运行classpath)的关系，它们的范围如下：
compile: 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行
test: 测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效
provided: 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。
runtime: 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。
system: 系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。</p>
<p>当我们引入第三方jar包的时候，难免会引入传递性依赖，有些时候这是好事，然而有些时候我们不需要其中的一些传递性依赖，可以在们可以使用exclusions元素声明排除依赖，exclusions可以包含一个或者多个exclusion子元素，因此可以排除一个或者多个传递性依赖。需要注意的是，声明exclusions的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖，不会出现重复。
当同一个模块，所依赖的几个模块版本都相同时，可以使用maven里的属性做分类依赖，依赖版本升级时改一处即可，如Spring Framework的依赖，可以使用 如下方式：</p>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>2.5.6<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在dependency中使用这个版本即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/07/19/concurrenthashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/19/concurrenthashmap/" itemprop="url">Concurrenthashmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-19T00:28:08+08:00">
                2016-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concurrent/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrent</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/07/19/concurrenthashmap/" class="leancloud_visitors" data-flag-title="Concurrenthashmap">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家都知道Java集合框架中，hashmap是非线程安全的，在并发环境下会出现错误情况，具体的原因分析参考：hashmap线程安全性。java也提供了相应的线程安全类，如hashtable、ConcurrentHashMap等。下面介绍一下ConcurrentHashmap。
&lt;!--more--&gt;
首先hashtable也是线程安全的，通过分析源码发现hashtable是通过synchronized同步了整个hash表，只允许一个线程对hashtable进行读写，所以并发时造成多个线程等待效率较低。而ConcurrentHashMap允许多个线程并发操作，其关键在于使用了锁分离技术，它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。对于有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。</p>
<p>ConcurrentHashmap的结构如下：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/concurrenthashmap.png" alt="img">
&lt;/center&gt;
由上图可以看出，ConcurrentHashmap是整个hash表，它由多个（默认16个）segment组成，相当于一个hashtable，hashentry是链表一个节点。下面看一下主要的源代码：
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractMap&lt;K</span>, <span class="title">V&gt;</span>  <span class="title">implements</span> <span class="title">ConcurrentMap&lt;K</span>, <span class="title">V&gt;</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> int segmentMask;</div><div class="line">    <span class="keyword">final</span> int segmentShift;</div><div class="line">    <span class="keyword">final</span> <span class="type">Segment</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;[] segments;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这表明ConcurrentHashmap的segment是不可变的，扩容只能增加segment的大小，其数量不会发生变化。segment的源码如下：
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397</span>L;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HashEntry是volatile，则其修改对于其他线程是可见的，hashentry源码如下：
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt;&#123;</div><div class="line">	<span class="keyword">final</span> K key;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">	<span class="keyword">volatile</span> V value; </div><div class="line">	<span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了value不是final的，其它值都是final的，所以不能从hash链的中间或尾部添加或删除节点，为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。
ConcurrentHashmap这种设计，保证读取操作能够读取到几乎最新的修改，所以读操作大多数情况了不需要加锁。</p>
<p>下面看一下remove操作：
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">    hash = hash(<span class="built_in">key</span>.hashCode());</div><div class="line">    <span class="keyword">return</span> segmentFor(hash).remove(<span class="built_in">key</span>, hash, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个操作是先定位到段，然后委托给段的remove操作。当多个删除操作并发进行时，只要它们所在的段不相同，它们就可以同时进行。下面是Segment的remove方法实现：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/conmaprm.png" alt="img">
&lt;/center&gt;
整个操作是在持有segment锁的情况下执行的，先定为代需要删除的节点e，然后将e前面的节点都复制一遍，因为entry是不可变的，所以必须要复制前面的节点，这种不可变性使得不需要同步从而节省了时间。例如删除前的数据为：1、2、3、4，删除3后链表变为：2、1、4。 整个remove实现并不复杂，但是需要注意如下几点。第一，当要删除的结点存在时，删除的最后一步操作要将count的值减一。这必须是最后一步操作，否则读取操作可能看不到之前对段所做的结构性修改。第二，remove执行的开始就将table赋给一个局部变量tab，这是因为table是 volatile变量，读写volatile变量的开销很大。编译器也不能对volatile变量的读写做任何优化，直接多次访问非volatile实例变量没有多大影响，编译器会做相应优化。</p>
<p>接下来看一下put操作：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/conmapput.png" alt="img">
&lt;/center&gt;
修改数据是不能并发进行的，所以该方法也是在持有segment锁的情况下执行，然后判断是否超限确保容量不足时能够rehash。接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n。</p>
<p>然后看一下get操作：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/conmapget.png?imageMogr2/thumbnail/!80p" alt="img">
&lt;/center&gt;
get操作不需要锁。第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count 变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。接下来就是根据hash和key对hash链进行遍历找到要获取的结点，对hash链进行遍历不需要加锁的原因在于链指针next是final的。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在 table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。
最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。因为put操作的语句：tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value)，在这条语句中，HashEntry构造函数中对value的赋值以及对tab[index]的赋值可能被重新排序，这就可能导致结点的值为空，所以可能需要在加锁情况在在读一遍：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/conmapread.png?imageMogr2/thumbnail/!70p" alt="img">
&lt;/center&gt;
contains方法更简单了，他不需要读值，所以不需要加锁了。
最后看一下size（）操作：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/conmapsize.png" alt="img">
&lt;/center&gt;
size方法主要思路是先在没有锁的情况下对所有段大小求和，如果不能成功（这是因为遍历过程中可能有其它线程正在对已经遍历过的段进行结构性更新），最多执行RETRIES_BEFORE_LOCK次，如果还不成功就在持有所有段锁的情况下再对所有段大小求和。在没有锁的情况下主要是利用Segment中的modCount进行检测，在遍历过程中保存每个Segment的modCount，遍历完成之后再检测每个Segment的modCount有没有改变，如果有改变表示有其它线程正在对Segment进行结构性并发更新，需要重新计算。</p>
<p>ConcurrentHashmap主要的方法大概这么多，其同步的方法在于使用了分段锁、final、volatile等减少了同步的范围，并保证了可见行。它的实现也比较复杂，需要多多思考和理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/07/18/violate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/18/violate/" itemprop="url">Violate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-18T00:19:22+08:00">
                2016-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Concurrent/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrent</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/07/18/violate/" class="leancloud_visitors" data-flag-title="Violate">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java高并发环境下，多个线程之间可能存在资源共享情况，可能造成了数据不一致情况。很多人都想到可以利用加锁的方式来实现，如java中的synchronized同步块和Lock，然而这种方式虽然可以解决问题，但加锁的本质是thread，只允许同一时刻只有一个线程来访问同步块，而在有些情况下我们并不需要严格的同步，只保证能读写最新的值即可，所以volatile能达到这个效果。
&lt;!--more--&gt;
在学习java并发编程前，我们先简单了解一下java内存模型。</p>
<h2>JMM</h2>
<p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/jmm.png?imageMogr2/thumbnail/!50p" alt="img">
<img src="http://oqcre1dsl.bkt.clouddn.com/readwrite.png?imageMogr2/thumbnail/!38p" alt="img">
&lt;/center&gt;
read and load 从主存复制变量到当前工作内存
use and assign  执行代码，改变共享变量值
store and write 用工作内存数据刷新主存相关内容</p>
<p>如：x＝1这条语句     执行线程必须先在自己的工作线程中对变量x所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值1写入主存中。
下面继续分析并发编程中原子性、可见行、顺序性等概念。</p>
<h2>原子性</h2>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，这些操作是不可被中断的，要么执行，要么不执行，这和数据库中事物的原子性概念很类似。</p>
<p>如 x = 10;  y = x;     x＋＋；x＝x＋1
在上面4个语句中，只有第一个是原子操作，其他都是复合操作，语句2包含2个操作，它先要去读取x的值，再将x的值写入工作内存，语句3和4都包含3个操作：读取x的值，进行加1操作，写入新的值  。
所以只有简单的读取、赋值（变量之间的相互赋值不是原子操作）才是原子操作，另外在32位机器上，long等64位数据赋值也不是原子操作。</p>
<h2>可见性</h2>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2>有序性</h2>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行，如下例子所示：</p>
<p>int i = 0;
boolean flag = false;
i = 1;                //1
flag = true;          //2</p>
<p>上面例子中，语句1和2之间没有任何关系，jvm不能保证1一定在2前面执行，因为有可能发生指令重排序。指令重排序是指处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。下面是另一个例子：</p>
<p>int a = 10;
int r = 2;
a = a + 3;   //1
r = a*a;     //2</p>
<p>这种情况下语句2不会在语句1前面执行，因为r的计算依赖语句1的操作结果。
所以有序性只保证程序最终执行结果和代码顺序执行的结果是一致的，并没有强调执行语句必须与程序代码一致，这样在单个线程中不会出现任何问题，然而在多个线程下会存在问题，上面例子中语句1，2在不同线程中，则r的值有可能不正确。要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。</p>
<p>java中volatile关键字来保证了一定的“有序性”，同样synchronized和Lock也可以保证有序性。另外jvm内存模型中具备了一些先天的有序性：happens-before 原则，具体规则如下：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<h2>volatile剖析</h2>
<p>在简单理解了jmm后，我们先在分析一下volatile关键字的作用。
volatile实际上有2个作用：
1).保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2).禁止进行指令重排序(内存屏障），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</p>
<p>下面结合一些经典的例子讲解一下：在java中，thread的stop方法是极不推荐的，为了停止线程通常的做法设置一个标记：</p>
<p>//线程1
boolean stop = false;
while(!stop){
doSomething();
}
//线程2
stop = true;</p>
<p>线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。用volatile修饰之后会强制将修改的值立即写入主存，导致线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取，所以stop的值就是最新的值，线程就停止了。</p>
<p>下面是另一个典型的例子：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        final Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)</div><div class="line">            Thread.<span class="keyword">yield</span>();</div><div class="line">        System.<span class="keyword">out</span>.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的操作大多数情况下都不是1000，因为volatile并不能保证原子性。上述例子中关键在于inc＋＋这个复合操作，分为读取、增加、写入三部操作，假设线程1从主存中读取了值，然后将值加一但还未写入主存，此时线程2也从内存中读取了值（此时和线程1读取的值一样，因为线程1还没将结果写入）然后增加写入，此时线程1继续执行，它已经不需要读取inc的值了，直接把计算的结果写入，所以这个时候线程2的增加操作被覆盖，导致只增加一次。使用synchronized和lock可以保证执行结果的正确性，也可以使用concurrent包下面的AtomicInteger类等。</p>
<p>volatile不能保证操作的原子性，但可以保证有序性。在单例模式中，通常通过double－check来提升单例的执行效率：
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line"></div><div class="line">    private volatile static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="attribute">instance</span>==null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="attribute">instance</span>==null)</div><div class="line">                   <span class="built_in"> instance </span>= new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里使用volatile关键在于instance = new Singleton()这条语句本质包括了3个步骤：
1:在堆中分配内存    2： 初始化堆中的对象   3:将堆中对象引用复制给instance
然后，上述三步中2和3是有可能发生指令重排序的，若先执行了3，此时instance非null，但堆中对象未初始化不能使用，若另一线程刚好执行到getInstance（）第一行，在判断 if(instance==null) 时程序会出现异常，所以volatile内存屏障防止了指令重排序，保证了2先于3发生。</p>
<h2>总结：</h2>
<p>volatile在某些情况下能保证并发的执行效率，但它并不能保证原子性，所以使用volatile时synchronized和lock一定能达到同样的效果，但反过来就不能保证。理解java中并发编程需要对jvm和操作系统有一定的了解，还需要多多学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/07/16/dispatchservlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/16/dispatchservlet/" itemprop="url">SpringMVC框架概括</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-16T22:56:57+08:00">
                2016-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Frameworks/" itemprop="url" rel="index">
                    <span itemprop="name">Frameworks</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/07/16/dispatchservlet/" class="leancloud_visitors" data-flag-title="SpringMVC框架概括">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SpringMVC是web开发中一种优良的MVC框架，它分离了控制器、模型对象、分派器以及处理程序对象的角色。当前的MVC框架有多种，主要有Struts1.x、Struts2、SpringMVC，而这些MVC框架都是在围绕着Controller进行重构和改善，他们主要的特点可以简单的概括为下图。
&lt;!--more--&gt;
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/servlet.png" alt="img">
&lt;/center&gt;
Struts1.x是一个早期的MVC框架实现，它保留了servlet中HttpServletRequest和HttpServletResponse这两大接口作为参数，另外它将返回值改为ActionForward完成对响应结果的处理，除此之外它增加了ActionMapping和ActionForm两大参数，相比传统的servlet，它优化了逻辑处理过程。struts2主要有2个创新点，首先消除了HttpServletRequest或者HttpServletResponse这样的原生Servlet对象，其次将请求参数和响应数据从响应方法中剥离到controller对象中的属性。这样整个Controller类彻底与Web容器解耦，摆脱了servlet的束缚，最后servlet引入了ThreadLocal模式，使得Controller成为一个线程安全的对象被servlet模型使用，它的拦截器、OGNL等技术使它成为一个流行的MVC框架。</p>
<p>SpringMVC的创新之处在于它引入Annotation来完成请求-响应的映射关系 ，在JDK1.5普及之后，Annotation作为一种新兴的Java语法，逐渐被大家熟知和应用。另外SpringMVC在响应方法上，可以支持多种多样不同的参数类型和返回值类型，当参数类型为Model时，SpringMVC将会自动将请求参数封装于Model内部而传入请求方法；当返回值类型是String时，直接表示SpringMVC需要返回的视图类型和视图内容，在写Controller的代码时可以随心所欲，不再受到任何契约的束缚。</p>
<p>SpringMVC的主要工作流程如下图所示：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/springmvc.png" alt="img">
&lt;/center&gt;</p>
<ol>
<li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter，如果成功获得HandlerAdapter后，此时将开始执行拦截器的方法，拦截器的作用是拦截用户请求并在执行controller中方法之前或之后进行相应的处理，主要有3个方法，boolean preHandle在处理请求之前被调用，当一     个请求中存在多个拦截器时，拦截器会根据其声明顺序依次执行其preHandle 方法，返回为false 时则请求结束，后续拦截器和对应Handler都不会再被调用，当返回值为true 时就会继续调用下一个拦截器的preHandle方法。 void postHandle是处理请求之后DispatcherServlet 对视图进行渲染之     前被调用。postHandle方法被调用的顺序与拦截器声明的顺序相反。 void afterCompletion在DispatcherServlet 渲染视图之后被调用，当对应的拦截器的preHandle方法的返回值为true时才会执行，主要用于进行资源清理工作。
4.DispatcherServlet调用ViewResolver，ViewResolver根据ModelAndView对象中的信息解析得到对应的View对象（使用了freemarker的视图解析器）；
5.DispatcherServlet调用View，View根据ModelAndView对象中Model中的数据进行页面渲染；
6.DispatcherServlet返回响应给用户。</li>
</ol>
<p>在项目使用Spring MVC首先需要在web.xml配置对应的servlet，servlet-mapping配置指定了由Spring MVC 处理的请求的路径。
在web.xml中也可以通过配置context-param来指定spring配置文件的路径，可以指定多个配置文件的路径。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/appservlet.png" alt="img">
&lt;/center&gt;
在spring的配置文件中配置ViewResolver，HandlerMapping和HandlerAdapter，项目中可以使用freemarker实现视图， &lt;mvc:annotation-driven/&gt;配置会在spring容器中注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/applicationcontext.png" alt="img">
&lt;/center&gt;
最后在controller类中调用service类进行业务处理，最终结合了mybaits操作修改了数据库。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/07/16/springmvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/16/springmvc/" itemprop="url">SpringMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-16T21:50:21+08:00">
                2016-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Frameworks/" itemprop="url" rel="index">
                    <span itemprop="name">Frameworks</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/07/16/springmvc/" class="leancloud_visitors" data-flag-title="SpringMVC">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>SpringMVC请求与controller映射</h1>
<p>SpringMVC通过DispatcherServlet 来处理请求信息，其中servlet-mapping配置指定了由Spring MVC 处理的请求的路径。下图中url-pattern被指定为/，这与/*有很大不同。
&lt;!--more--&gt;
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/dispatcherservlet.png" alt="img">
&lt;/center&gt;
Tomcat在启动时会扫描web.xml文件，得到servlet的映射数据servletMappings，据此可以知道每个servlet处理的请求路径。通过分析源码，通常把路径4类：</p>
<ol>
<li>以 /* 结尾的。 path.endsWith(&quot;/*&quot;)</li>
<li>以 <em>. 开头的。 path.startsWith(&quot;</em>.&quot;)</li>
<li>是否是 /      path.equals(&quot;/&quot;)</li>
<li>以上3种之外的</li>
</ol>
<p>上述4种映射处理后会被放入 wrapper中，这里Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收，其中4类servlet对应的wrapper如下：</p>
<ol>
<li>/* 对应的Servlet会放在wildcardWrappers中</li>
<li>*. 会被放到extensionWrappers中</li>
<li>/ 会被放到defaultWrapper中(缺省)</li>
<li>其他的映射都被放到exactWrappers中(精确匹配某一路径)</li>
</ol>
<p>用户的请求过来时，会对请求的url进行匹配，匹配规则的先后顺序如下：</p>
<ol>
<li>精确匹配，使用contextVersion的exactWrappers</li>
<li>前缀匹配，使用contextVersion的wildcardWrappers</li>
<li>扩展名匹配，使用contextVersion的extensionWrappers</li>
<li>使用资源文件来处理servlet，使用contextVersion的welcomeResources属性，这个属性是个字符串数组</li>
<li>使用默认的servlet，使用contextVersion的defaultWrapper</li>
</ol>
<p>下面我们继续分析对于某个具体的请求(如http://ip:port/contextPath/path)
SpringMVC如何找到对应的Controller方法，即请求与Controller之间的映射关系。DispatcherServlet根据url得到对应的HandlerAdapter进行处理，处理过程中有几个重要的接口，HandlerMethodArgumentResolver、HandlerMethodReturnValueHandler。HandlerAdapter在处理每个请求时会实例化一个ServletInvocableHandlerMethod对象进行处理，处理请求时会根据ServletInvocableHandlerMethod的属性argumentResolvers（这个属性是它的父类InvocableHandlerMethod中定义的）进行处理，其中argumentResolvers属性是一个HandlerMethodArgumentResolverComposite类，这个类是实现了HandlerMethodArgumentResolver接口的类， 处理响应的时候，会根据ServletInvocableHandlerMethod的属性returnValueHandlers进行处理，returnValueHandlers属性是一HandlerMethodReturnValueHandlerComposite类，这个类是实现了HandlerMethodReturnValueHandler接口的类，这2个属性都在ServletInvocableHandlerMethod实例化的时候被赋值（通过HandlerAdapter的属性进行赋值），HandlerAdapter的相关属性是在HandlerAdapter进行实例化由Spring容量注入。</p>
<p>在常见的注解中，使用@ResponseBody注解的话最终返回值会被RequestResponseBodyMethodProcessor类处理，该类同时实现了HandlerMethodReturnValueHandler和HandlerMethodArgumentResolver这两个接口，所以它支持的请求类型是Controller方法参数中带有@RequestBody注解，支持的响应类型是Controller方法带有@ResponseBody注解，其他常用的HandlerMethodArgumentResolver实现类如下：
1.RequestParamMethodArgumentResolver
支持带有@RequestParam注解的参数或带有MultipartFile类型的参数
2.RequestParamMapMethodArgumentResolver
支持带有@RequestParam注解的参数 &amp;&amp; @RequestParam注解的属性value存在 &amp;&amp; 参数类型是实现Map接口的属性
3.PathVariableMethodArgumentResolver
支持带有@PathVariable注解的参数 且如果参数实现了Map接口，@PathVariable注解需带有value属性
4.MatrixVariableMethodArgumentResolver
支持带有@MatrixVariable注解的参数 且如果参数实现了Map接口，@MatrixVariable注解需带有value属性
5.RequestResponseBodyMethodProcessor
方法参数中带有@RequestBody注解
6.ServletRequestMethodArgumentResolver
参数类型是实现或继承或是WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、Locale、TimeZone、InputStream、Reader、HttpMethod这些类。
7.ServletResponseMethodArgumentResolver
参数类型是实现或继承或是ServletResponse、OutputStream、Writer这些类
8.RedirectAttributesMethodArgumentResolver
参数是实现了RedirectAttributes接口的类
9.HttpEntityMethodProcessor
参数类型是HttpEntity</p>
<p>常用的HandlerMethodReturnValueHandler实现类如下：
1.ModelAndViewMethodReturnValueHandler
返回值类型是ModelAndView或其子类
2.ModelMethodProcessor
返回值类型是Model或其子类
3.ViewMethodReturnValueHandler
返回值类型是View或其子类
4.HttpHeadersReturnValueHandler
返回值类型是HttpHeaders或其子类
5.ModelAttributeMethodProcessor
返回值有@ModelAttribute注解
6.ViewNameMethodReturnValueHandler
返回值是void或String</p>
<p>SpringMVC中将一个类添加@Controller以表示该类是一个controller，其他常用的注解如下：</p>
<p>1.@RequestMapping</p>
<p>用来标记请求的路径，它可以标记在类上面，也可以标记在方法上，当方法上和类上都标记了@RequestMapping的时候，那么对应的方法对应的Url就是类上的加方法上的。在RequestMapping中还可以指定一个属性method，其主要对应的值有RequestMethod.GET和RequestMethod.POST，@RequestMapping中还有一个属性params，可以通过该属性指定请求参数中必须包含某一参数，或必须不包含某一参数，或某参数的值必须是什么，以此来缩小指定的映射范围。</p>
<p>2.@PathVariable
可以标记在方法的参数上，利用它标记的参数可以利用请求路径传值，下面是一个具体的例子
@RequestMapping(value=&quot;/comment/{blogId}&quot;, method=RequestMethod.POST)
public void comment(Comment comment,@PathVariable int blogId, HttpSession session, HttpServletResponse response) throws IOException
		}</p>
<p>3.@RequestParam
用来给参数传值的，但是它是从头request的参数里面取值，相当于request.getParameter(&quot;参数名&quot;)方法。它的取值规则跟@PathVariable是一样的，当没有指定的时候，默认是从request中取名称跟后面接的变量名同名的参数值，当要明确从request中取一个参数的时候使用@RequestParam(&quot;参数名&quot;)。</p>
<p>4.返回值</p>
<ul>
<li>返回一个ModelAndView，其中Model是一个Map，里面存放的是一对对的键值对，其可以直接在页面上使用，View是一个字符串，表示的是某一个View的名称</li>
<li>返回一个字符串，这个时候如果需要给页面传值，可以给方法一个Map参数，该Map就相当于一个Model，往该Model里面存入键值对就可以在页面上进行访问了</li>
<li>返回一个Model也就是一个Map，这个时  返回一个Model也就是一个Map，这个时候将解析默认生成的view name</li>
<li>任何其他类型的对象。这个时候就会把该方法返回类型对象当做返回Model模型的一个属性返回给视图使用，这个属性名称可以通过在方法上给定@ModelAttribute注解来指定，否则将默认使用该返回类名称作为属性名称。</li>
</ul>
<p>5.@SessionAttributes
	只能声明在类上，而不能声明在方法上，表示模型对象的特定属性具有 Session 范围的作用域
	如：@SessionAttributes(types = {User.class,Dept.class},value={&quot;attr1&quot;,&quot;attr2&quot;})</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lifeloner.github.io/2016/07/16/mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifeloner">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifeloner">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/16/mybatis/" itemprop="url">Mybatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-16T21:33:12+08:00">
                2016-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Frameworks/" itemprop="url" rel="index">
                    <span itemprop="name">Frameworks</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/07/16/mybatis/" class="leancloud_visitors" data-flag-title="Mybatis">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MyBatis是支持普通SQL查询和高级映射的优秀持久层框架。它消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录。
&lt;!--more--&gt;
MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心，它是SqlSessionFactoryBuilder对象通过配置文件Configuration类实例中来构建SqlSessionFactory对象，在使用时常通过Spring来集成和整合，下面是SqlSessionFactory的基本配置文件。
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/sessionfactory.png" alt="img">
&lt;/center&gt;
可以看出，sqlSessionFactory被注册为spring容器中的bean，配置了使用的数据源，还有mybatis配置文件的位置、mapper xml文件的位置。sqlSessionFactory主要用来产生sqlSession，而sqlSession在Spring中使用了它的实现类sqlSessionTemplate，还定义了mapper接口的包路径，这里配置的MapperScannerConfigurer会将basePackage里的mapper接口注册为spring容器中的bean，并同时注入sqlSessionTemplate到mapper接口对象中，否则需要单独定义每一个mapper接口的bean。具体的Spring配置如下：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/template.png" alt="img">
&lt;/center&gt;
由上面分析可以看出，sqlSessionFactory的产生流程如下：首先sqlSessionFactoryBean根据mybatis配置文件构造出configuration对象，.然后通过sqlSessionFactoryBuilder的build方法构造出一个sqlSessionFactory实例，sqlSession的产生是通过sqlSessionFactory创建了它的实现类sqlSessionTemplate。</p>
<p>下面继续分析Mybatis中mapper接口，通常在程序中我们通过如下方式使用mapper：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mapper.png" alt="img">
&lt;/center&gt;
在上面的spring配置中，将basePackage里的mapper接口注册为spring容器中的bean，在session调用getMapper时，扫描basePackage内的所有mapper接口并将这些bean设置为MapperFactoryBean.class，还添加了sqlSessionTemplate对象的引用。所以mapper对象由MapperFactoryBean来创建，在调用SqlSessionTemplate.getMapper时会调用MapperRegistry的getMapper方法，进而又通过了MapperProxyFactory对象创建mapper对象，MapperRegistry还记录了mapper接口和MapperProxyFactory对象的映射关系。MapperProxy类实现了InvocationHandler接口，mapper对象是其实是实现了对应mapper接口的动态代理对象，对mapper接口方法的调用都会调用代理对象的invoke方法，mapper对象的创建流程如下图：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/mapperpeoxy.png" alt="img">
&lt;/center&gt;
所以mybatis整合spring时，先通过SqlSessionFactoryBean创建了SqlSessionFactory，SqlSessionFactory创建了sqlSession，然后通过MapperFactoryBean生成了mapper对象，mapper对象的创建使用了java动态代理，mapper接口方法的调用都在代理对象的invoke方法中完成。</p>
<p>下面继续分析一条sql语句的执行过程：
&lt;center&gt;
<img src="http://oqcre1dsl.bkt.clouddn.com/sql.png" alt="img">
&lt;/center&gt;
在getMapper方法得到mapper对象后，调用接口相关的语句时，经过上面的分析会调用MapperProxy对象的invoke方法(每一个MapperProxy对应一个dao接口)，然后会触发MapperMethod调用excute方法，该方法会根据根据类型去选择到底执行sqlSession中的哪个方法（insert、update、delete、select），然后执行相应的SqlSession的CRUD方法，之后会执行Excutor的doQueryQ方法，最后一步一步的封装最终通过PreparedStatement处理相关sql语句，然后执行结果逐步返回给sqlsession。
最后在Mapper的的映射文件...Maper.xml文件中有很多动态sql语句，大大减少了sql语句拼接的复杂度，主要有insert、update、delete、select、if、choose、when、otherwise、where、set、foreach、trim等标签，具体的使用可参考帮助文档。
MyBatis的动态sql语句http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/photo.png"
               alt="lifeloner" />
          <p class="site-author-name" itemprop="name">lifeloner</p>
           
              <p class="site-description motion-element" itemprop="description">Keep Moving!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lifeloner" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Github
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2709035861/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:yangfu1992@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://jm.taobao.org/hire/" title="阿里中间件博客" target="_blank">阿里中间件博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jasongj.com/" title="牛人博客" target="_blank">牛人博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://cmsblogs.com/" title="Java精品博客" target="_blank">Java精品博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/u013256816" title="中间件博客" target="_blank">中间件博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://leetcode.com/gogoing/" title="leetcode" target="_blank">leetcode</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lifeloner</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3CEMw4GOysIloYEGhXyGXF2Y-gzGzoHsz", "geP0AJOCyAyAeJJS13hYX4Us");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
